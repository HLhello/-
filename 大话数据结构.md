## CHA1 数据结构绪论

### 1.1

### 1.2

### 1.3 

- 程序设计 = 数据结构 + 算法

### 1.4

- 数据，数据元素，数据项，数据对象，数据结构

- 数据：是描述客观事务的符号，是计算机中可以操作的对象，能被计算机识别，并输入给计算机处理的符号集合

- 数据结构：数据元素之间存在一种或多种特定关系的数据元素的集合

### 1.5

- 逻辑结构：数据对象中数据元素之间的相互关系
  - 集合结构
  - 线性结构
  - 树形结构
  - 图形结构
- 物理结构（存储结构）：是指数据的逻辑结构在计算机中的存储形式
  - 顺序存储结构
  - 链式存储结构

### 1.6

- 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称
  - 原子类型
  - 结构类型
- 抽象数据类型（Abstract Data Type，ADT）是指一个数学模型及在定义该模型上的一组操作

## CH2 算法

- 2.1 数据结构与算法的关系
- 2.2 两种算法的比较
- 2.3 算法定义

  - 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
- 2.4 算法的特性

  - 输入输出，有穷性，确定性，可行性
- 2.5 算法设计的要求

  - 正确性，可读性，健壮性
  - 时间效率高和存储量第
- 2.6 算法效率的度量方法

  - 时候统计方法
    - 这种方法主要通过设计好的测试程序和数据，利用计算机计时对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
  - 事前分析估算法
    - 一个程序的运行时间，依赖于算法的好坏和问题的输入规模
- 2.7 函数的渐进增长

  - 这就是洛必达法则，其中自变量为执行一次的计算次数
- 2.8 算法时间复杂度 TODO

  - 即算法的时间度量，记作T(n) = O(f(n))
  - 在进行算法分析是，语句总的执行次数T(n)是关于问题的规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级
- 2.9 常见的时间复杂度
- 2.10 最坏情况与平均情况
- 2.11 算法的空间复杂度
  - 一般考虑时间复杂度二不考虑空间复杂度

## CHA3 线性表

- 3.1 线性表的定义

  - 线性表（List）零个或多个元素的有限序列
    - 前驱元素，直接前驱
    - 后继元素，直接后继
    - 线性表元素的个数n（n>=0）定义为线性表的长度，当n等于0时，称为空表
  - 在复杂的线性表中，一个数据元素可以由若干个数据项组成

- 3.2 线性表的抽象数据类型

  - ```
    ADT 线性表（List）
    Data
    	线性表的数据对象集合为{a1,a2,...,an},每个元素的类型均为datetype，其中，除了第一个元素，每一个元素都有且只有一个直接前驱元素，除了最后一个元素，每一个元素都有且只有一个直接后继元素，数据之间的关系是一对一的关系
    Operation
    	InitList（*L）：初始化操作，建立一个空的线性表L
    	ListEmpty（L）：若线性表为空，返回true，否则返回false
    	ClearList（*L）：将线性表清空
    	GetElem（L,i,*e）：将线性表L中第i个元素返回给e
    	LocateElem（L,e）：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功，否则，返回0表示失败
    	ListInsert（*L，i，e）：在线性表中第i个位置插入新元素e
    	ListDelete（*L,i,*e）：删除线性表L中第i个位置的元素，并用e返回其值
    	ListLength（L）：返回线性表L的元素个数
    endDat
    ```

  - 线性表顺序存储的优缺点

    - 优点
      - 无需为表示表中的元素之间的逻辑关系而增加额外的存储空间
      - 可以快速取出表中任意位置的数
    - 缺点
      - 插入和删除需要移动大量的元素
      - 当线性表长度变化较大时，难以确定存储空间的容量
      - 造成存储空间的碎片

  - 查找，插入和删除的时间复杂度

    - 无论查找哪一个数据时间负复杂度都是O(1)
    - 插入和删除最好情况将数据移动1次，时间复杂度O(1)
    - 插入和删除最坏情况将数据移动n次，时间复杂度O(n)
    - 所以插入和删除时间复杂度为O(n)

- 3.3 线性表的链式存储结构

  - 单链表的整表创建思路（头插法与尾插法）
    - 声明一指针p和计数器变量i
    - 初始化一个空链表
    - 让L的头结点指针指向NULL，即建立一个头结点的单链表
    - 循环
      - 生成一个新节点赋值给p
      - 随机生成一数字赋值给p的数据域
      - 将p插入到头结点与前一新节点之间
  - 单链表的整表删除
    - 声明一节点p和q
    - 将第一个几点赋值给p
    - 循环
      - 将下一个节点赋值给q
      - 释放p
      - 将q赋值给p
  - 单链表结构与顺序存储结构的优缺点
    - 存储方式的分配上
      - 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
      - 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
    - 时间性能
      - 查找
        - 顺序存储结构O(1)
        - 单链表O(n)
      - 插入和删除
        - 顺序存储结构需要平均移动表长一般的元素，时间为O(n)
        - 单链表在指出某位置的指针后，插入和删除的时间仅为O(1)
      - 空间性能
        - 顺序存储结构需要预先分配固定的内存，分大了，浪费，分小了，不够用
        - 单链表只在需要时分配内存空间
  - 总结
    - 在一些频繁查找，删除和插入较少的操作较少时，采用顺序存储结构
    - 表中元素变化比较大，建议使用链式存储

- 3.4 静态链表

  - 用数组描述的链表称为静态链表
  - 静态链表的优缺点
    - 优点——在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点
    - 缺点——没有解决了连续存储分配带来的表长难以确定的问题，失去顺序存储结构随机存取的特性

- 3.5 循环链表

  - 将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单循环链表，简称循环链表

  - 双向链表是在单链表的每个节点中，在设置一个指向其前驱节点的指针域

  - ```c
    typedef struct DulaNode
    {
        Elemtype data;
        struct DulaNode *perior;
        struct DulaNode *next;
    }
    ```

## CHA4 栈与队列

- 4.1 栈（stack）

  - 栈是限定仅在表尾进行插入和删除操作的线性表
    - 我们把允许插入和删除的一段称为栈顶，另一端称为栈底
    - 不含任何数据元素的栈称为空栈
    - 栈又称为后进先出（last in first out）的线性表，简称LIFO
    - 首先栈是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系
    - 其次栈是特殊的线性表，只能在表尾进行插入和删除的操作
    - 栈底是固定的，最先进栈的只能在栈底
  - 栈的插入操作叫做进栈，也称为压栈，入栈
  - 栈的删除操作，叫做出栈，也叫做弹栈

- 4.2 栈的抽象数据类型

  - ```
    ADT 栈（stack）
    Data
    	同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系
    Operation
    	InitStack(*s):初始化操作，建立一个空栈
    	DestoryStack(*s):若栈存在，则销毁他
    	ClearStack(*s):将栈清空
    	StackEmpty(s):若栈为空，返回true，否则返回false
    	GetTop(s,*e):若栈存在且非空，用e返回s的栈顶元素
    	Push(*s,e):若栈存在，且非空，插入新元素e到栈中并成为栈顶元素
    	Pop(*s,*e):删除栈s中栈定的元素，并用e返回其值
    	StackLength(s):返回栈s的个数
    endADT
    ```

- 4.3 顺序栈的实现以及共享栈的实现

- 4.4 栈的链式存储结构及实现

  - 栈的链式存储结构，简称为链栈
    - 将栈顶放在单链表的头部
    - 对于链栈来说基本不存在满栈的情况，除非内存已经没有可以使用的空间

- 4.5 比较链栈与普通栈

  - 链栈的进出栈时间复杂度均为O(1)
  - 顺序在和链栈的时间复杂度相同
  - 顺序在需要事先定义一个固定的长度，可能会存在内存空间浪费的问题，但他的优势是存取时定位很方便
  - 链栈要求每个元素有指针域，同样增加内存开销，但是在某些情况的下栈的长度变化很大，时大时小，使用链栈方便一些

- 4.6 栈的作用

  - 栈实现了递归

    - 回忆斐波那契数列，兔子，楼梯，汉诺塔，这些程序是如何实现的

    - 递归的定义：把一个直接调用自己，或者通过一系列的调用语句间接的调用自己的函数，称作递归函数
      - 每个递归函数必须至少有一个条件，满足时不再递归，开始出栈

  - 栈实现四则运算表达式求值

    - 先乘除，后加减，从左算到右

  - 一种不需要括号的后缀表示法，我们把它称之为逆波兰（RPN）
    - 例： 9 + ( 3 - 1 ) x 3 + 10 / 2（中缀表达式）（标准s四则运算表达式）
    - RPN表示：9 3 1 - 3 x + 10 2 / +（后缀表达式）
    - 运算规则
      - 从左到右遍历表达式的每个数字和符号，遇到数字进栈，遇到是符号，就将处于栈顶的两个数字出栈进行运算，运算结果进栈，一直到最终获得结构
    - 中缀表达式转后缀表达式
      - 从左到有遍历每个中缀表达式的数字和符号，
      - 若是数字就输出，即成为后缀表达式的一部分，
      - 若是符号则判断其与栈顶符号的优先级，
        - （A）优先级不高于栈顶符号，则栈顶元素依次出栈并输出，
          - 不高于==》小于等于就是不高于
        - （A）将当前符号进栈，
        - （B）若碰到（），左括号压入栈中，直到右括号准备入栈（配对成功）
        - （B）将左右括号之间的符号弹出
        - （B）一直把左括号也弹出，再压入下一个元素
      - 一直到最终输出后缀表达式为止

    计算机利用栈思想以及后缀表达式进行四则运算

    1. 将中缀表达式转换为后缀表达式
    2. 将后缀表达式进行运算得出结构

- 4.7 队列

  - 队列是只允许在一端进行插入操作，而在另一端进行删除惭怍的线性表

    - 队列是一种先入先出的线性表（first in first out）简称FIFO
    - 允许插入的一端称为队尾，允许删除的一端称为队头

  - 队列的抽象数据类型

    - ```
      ADT 队列（queue）
      Data
      	同线性表，元素具有相同的类型，相邻元素具有前驱和后继的关系
      Operation
      	InitQueue(*Q)初始化操作，建立一个空队列Q
      	DestroyQueue(*Q)若队列Q存在，则销毁他
      	ClearQueue(*Q)将队列清空
      	QueueEmpty(Q)若队列Q为空，返回True，否则返回False
      	GetHead(Q,*e)若队列存在且非空，用e返回队头元素
      	EnQueue(*Q,e)若队列存在，插入新元素e到队列中并成为队尾元素
      	DeQueue(*Q,e)删除队列Q中的队头元素，并用e返回其值
      	QueueLength(Q)返回队列的元素个数
      endADT
      ```

  - 线性表有两种存储方式，顺序存储和链式存储

    - 栈与队列都是线性表，所以都有顺序队列和链式队列
    - 虽然有两种实现方式，但是两种实现方式各有优缺点

  - 队列顺序存储的不足

    - 队列的顺序存储实现方式与线性表的的顺序存储相差不多，只不过是插入只能在队头，删除只能在队尾，线性表的顺序存储还可以在中间插入
    - 从时间复杂度看，在插入时，线性表的时间复杂度与队列的时间复杂度在一个量级上

  - 对于队列顺序存储不足的改进思路

    - 1. 设置队头
         - 和队尾指针，定义顺序存储的数组，这样做的目的是让队头元素不必只在下标为0的位置上，队头元素出队后，将队头指针向后移，这样做之后，在队列中插入和删除元素时间复杂度都变成O(1)
         - 缺点是这样使得顺序存储的数组利用率随着出队元素的增加而减，队列的长度越来越短，但是队头元素之前空着的存储位置也被浪费掉了，假溢出现象
    - 2. 循环对列的定义
         - 解决假溢出的办法解释后面满了，就从头开始，将队列的这种首尾相接的顺序存储结构称为循环队列
         - 这样的话头指针和尾指针有可能会指向同一个下标，在指向同一个下标时有两种情况，一种是队列是空的，一种是队列是满的，如何区分呢？有两种解法
           - 1） 可以设置一个flag信号，flag==0，队列空，flag==1队列满、
           - 2） 保留一个空元素，在(rear+1)%QueueSize == front 时就认为队列满了
    - 第一种解法判断简单，但是每个队列结构体得多定义一个flag信号，但问题是无法分辨当rear == flag时，队列到底是什么状态，这个到底怎么判断呢？？是不是加一个count， 进来一个加1，出去一个减1，对呀，设置一个计数器不就得了，或者可以这样，初始flag时将flag置0，当flag为0时不能进行出队操作，只能进队，然后只要有一个元素进队，就置1，不行还是计数器方便。进队加1，出队减1，初始化队列是置0，为0时只能进队，记满MAXSIZE只能出队不能进队，不用flag信号
    - 第二种解法是有一个空元素，这个比较好办，只要判断(rear+1)%QueueSize == front就可以了
    - 这么看来第二种解法是最简单的

- 4.8 队列的链式存储

  - 队列的链式存储其实就是线性表的单链表，但是只能从尾进头出而已
  - 如何初始化一个队列链表呢
    - 定义一个有结构体，成员是两个指针，一个头指针，一个尾指针，指针的类型是链表元素的结构体
    - 链表元素的结构体包含数据成员以及指向下一元素的指针成员
    - 初始化时将头指针和为指针都指向一个链表的的元素，data不做赋值，*next赋值为NULL
  - 总的来说，如果能确定队列长度最大值的情况下，建议使用循环队列，如果无法预估队列的长度，则使用链队列
  - 循环队列的入队出队操作以及链队列的入队出队操作本质上都是O(1)的，都是常数时间，链队列的每次出队和入队在节点内存的释放和申请上还是存在一定的时间开销的

- 知识点树

  - 顺序栈---》两栈共享空间
  - 顺序队列---》循环队列
  - 链式存储  ---》链栈，队列栈

## CHA5 串

- 5.1字符串的概念

  -  串是由零个或者多个字符组成的有限队列，又叫字符串
    -  一般记为 s = "a1a2...an"(n>=0)
    -  s是字符串的名称，用双引号括起来的字符序列是串的值，双引号不是字符串的内容
    -  所谓字符列，说明串的相邻字符之间具有前驱和后继的关系
    -  串中的字符数目n称为串的长度
    -  零个字符的串称为空串（null string）
  -  一些特别的概念
    - 空格串，只包含空格的串，不是空串，空格串是有内容有长度的，而且可能不止一个空格	
    - 子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应的包含所有子串的称为主串
    - 子串的位置，子串的第一个字符在主串中的序号
    - Unicode的前256个字符的编码与ASCII的完全相同
  -  与线性表比较
     -  串的逻辑结构和线性表很相似，不同之处是串针对的是字符集，也就是串中的元素都是字符，
     -  线性表更关注单个元素的操作
     -  串更多的是查找子串的位置，得到指定的字符串，替换子串在这样的操作

- 5.2 串的比较

  - 比如 silly 与 stupid

    - 在计算机中的大小取决于挨个字母的前后顺序，事实上是通过组成串的字符的编码来确定的
    - 第一个字母，相同
    - 第二个字母，i在t前，t>i
    - 于是silly<stupid
  - 字符串 s = "a1a2...an"; t = "b1b2...bm";
    - if(m=n && ai==bi)   s == t;  1<=i<=(m||n) ;  eg: happy = happy
    - if(m>n &&ai==bi)    s<t;  1<= i <= min{m,n};  eg: happ<happy
    - if(k<=min{m,n},ak<bk)    s<t;  eg: happen<happy

- 5.3 串的抽象数据类型

  - ```
    ADT 串（string）
    Data
    	串中元素仅由一个字符构成，相邻元素具有前驱和后继的关系
    Operation
    	StrAssign(T,*chars) 生成一个其值等于字符串常量chars的串T
    	StrCopy(T,S) 串S存在，由串S复制得串T
    	Clearstring(S) 串S存在，将串清空
    	StringEmpty(S) 串为空，返回True，否则返回True
    	StrLength(S) 返回串S的长度
    	StrCompare(S,T) 若S>T返回<0，若S=T返回0，若S<T返回>0
    	Concat(T,S1,S2) 由T返回S1和S1连接成的新串
    	Substring(Sub,S,pos,len) 串S存在，1<=pos<=StrLength(S)+1,且0<=len<=Strlength(S)-pos+1，用sub返回S的第pos个长度为Len的子串
    	Index(S,T,pos) 用pos返回S和T中相同子串的位置
    	Repalce(S,T,V) 使用V替换S中所有与T相等的不重叠的子串
    	StrInsert(S,pos,T) 在串S的第pos个字符之前插入T
    	StrDelete(S,pos,len) 从串S中删除pos位置长为len的子串
    ```

- 5.4 串的存储结构

  - 串的顺序存储结构
    - 串的顺序存储结构，使用一组地址连续的存储单元来存储串中的字符序列的
  - 串的链式存储结构
    - 由于串结构的特殊性，结构中每个元素都是一个字符，如果应用链表一个节点对应一个字符，会造成空间的浪费，所以一个节点存储一个子串，节点未被沾满使用#代替，
    - 这样一个节点存储多少个字符就会直接影响效率
    - 链式结构存储字符串除了在连接串和某些串操作有一定方便之外，总的来说不如顺序串灵活，性能也不如顺序存储结构好

- 5.5 模式匹配算法（子串的定位操作通常称为串的模式匹配）

  -  朴素的模式匹配算法

    - 朴素模式匹配算法的时间复杂度 为O((n-m+1)*m)
    - 十分低效

  - KMP模式匹配算法

    - 定义两个变量i，j，一个是主串的下标i，一个是子串下标j，
    - 在朴素匹配时，i是有回溯的的，
    - 在KMP匹配时，i取消了无效的回溯，变化的只有指向子串的下标的j
    - 那么j如何变化呢，我们考虑T串的首字符与自身后面字符的比较
    - 也就是说j的变化和主串没有什么关系，我们关注的是子串的结构以及是否重复的问题
    - 例如T = "abcdef",没有任何重复的字符，所以j就从6变到1
    - 例如T = "abcabx",前两个字符ab与x之前的ab是相等的，j就从6变到了3
    - 那么kmp算法做的就是调整j的值，让i不用回溯

  - 如何调整j的值呢？——next数组值推导

    - 有三条规则来找出next[j]

      - 1） 当j=1时，next[1] = 0;
      - 2） 当max{ k|1<k<j，且 'p1...'p(k-1)= 'p(j-k+1)...'p(j-1)} 不为空时，
      - 3） 其他情况，next[j] = 1;

    - 得到next[]这个数组后，在进行比较时，如果此时比较到了i=j=6不相等的时候，此时i不动，j=next[6]直接进行比较

    - eg 

      - | j       | 123456 |
        | ------- | ------ |
        | 模式串T | abcabx |
        | next[j] | 011123 |

      - 串T与s = "abcababca..."比较

      - 显然，比较到 i = j = 6 时不相等

      - 这时i不动，j = next[6] = 3,直接比较i=6 j=3时是否相等

    - **注：** KMP算法仅当模式与主串之间存在许多部分匹配的现象是才能体现出他的优势

  - KMP模式匹配算法的改进

    - 还是有缺陷，比如当比较s="aaaaabc"时会出现好多不必要的操作
    - 如何改进呢？
    - 将next的函数修正值存在nextval中

  - 算法理解了，但是没有代码实现，感觉字符串这块不太重要，以后有时间在说吧

## CHA6 树

- 6.1 树	
  - 一对一的为线性结构，还有一对多的情况需要处理
  - 树（Tree）是n（n>=0）个节点的有限集，n=0时称为空树
  - 在任意一个非空树中
    - 1） 有且仅有一个特定的称为根（root）的节点
    - 2） 当n>1时，其余节点可以分为m（m>0）个互不相交的有限集，T1,T2,...,Tm，其中每一个集合本身又是一颗树，并且称为根的子树
    - 插图TODO【树的图】
  - **注意：** 
    - n>0时根节点是唯一的，不能存在多个根节点
    - m>0时子树的个数没有限制，但他们一定是互不相交的
  - 节点分类
    - 度（degree）：节点拥有子树的数量称为度，树的度是树内各节点的度的最大值
    - 叶节点（Leaf）：度为0的节点
    - 度不为0的节点称为非终端节点或分支节点，除了根节点外，分支节点也是称为内部节点
  - 节点间的关系
    - 节点的子树的根称为该节点的孩子（child）
    - 该节点称为孩子的双亲（parents）
    - 同一个双亲的孩子之间互称为兄弟（sibling）
    - 节点的祖先是从根到该节点所经分支上的所有节点
    - 以某节点为根的子树中的任一节点都称为该节点的子孙
  - 树的其他概念
    - 节点的层次（level）：从根开始定义起，根为第一层，根的孩子为第二层，以此类推
    - 双亲在同一层的节点称为堂兄弟
    - 树的深度（depth）：树中节点的最大层次就是数的深度（高度）
    - 有序树：如果将树中节点的鸽子树看成是从左至右是有次序的，不能互换的，就是有序树，反之称为无序树
    - 森林（forest）：是（m>=0）棵互不相交的树，对于树中每个节点而言，其子树的集合就是森林
- 6.2 树的存储结构
  - 对于存储结构的设计，可以综合顺序存储和链式存储的特点，是一个非常灵活的过程，一个存储结构设计的是否合理，取决于基于该存储结构的运算是否适合，是否方便，时间复杂度好不好等
  - 双亲表示法（不一定有孩子，但一定有双亲）
    - 在每个节点中附设一个指示器只是其双亲节点在数组中的位置
  - 孩子表示法
    - 把每个节点的孩子节点排列起来，以单链表做存储结构，则n个节点右n个孩子链表，如果是叶子节点则此单链表为空，然后n个头指针有组成一个线性表，采用顺序存储结构，存放进一个一维数组中
    - 每个节点有多个指针域，其中每个指针指向一颗子树的根节点，我们把这种方法叫做多重链表表示法
    - 1）一种是指针域的个数就等于树的度，这种方法对于树中各节点的度相差很大时，显然是很浪费空间的，对于度相差很小时，那就意味着开辟的空间被充分利用了，缺点反而变成了优点
    - 2） 每个节点指针域的个数等于该节点的度，专门取一个位置来存储节点指针域的个数，这种方法空间利用率倒是上去了，可是数据结构的维护变得复杂了，在运算时间上会带来损耗
  - 孩子兄弟表示法
    - 任意一颗树，他的节点的第一个孩子如果存在就是唯一的，他的右兄弟如果存在也是唯一的，因此我们设置两个指针，分别指向该节点的第一个孩子和此节点的有兄弟
    - 这种方法最大的好处是他把一颗复杂的树变成了二叉树
- 6.3 二叉树（binary tree）
  - 二叉树（binary tree）：是是n（n>=0）个节点的有限集，n=0时称为空二叉树树，或者由一个根节点的和两颗互不相交的、分别称为左子树和右子树的二叉树组成
  - 二叉树特点
    - 每个节点最多有两颗子树，所以二叉树中不存在度大于2的节点，**不是只有两颗子树，而是最多有两颗**，没有子树或者有一颗子树也时可以的
    - 左子树和右子树是有顺序的，次序不能任意颠倒，就像人的左右手
    - 即使树中某节点只有一颗子树，也要区分是左子树还是右子树，
  - 二叉树的五种形态
    - 空二叉树
    - 只有一个根节点
    - 根节点只有左子树
    - 根节点只有右子树
    - 根节点既有左子树又有右子树
  - 特殊的二叉树
    - 斜树
      - 所有节点都只有左子树的二叉树称为左斜树
      - 所有节点都只有右子树的二叉树称为右斜树
    - 满二叉树
      - 在一颗二叉树中，所有分支节点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树
      - 满二叉树的特点
        - 叶子节点只能出现在最下一层
        - 叶子节点的度一定是2
        - 同样深度的二叉树中，满二叉树节点最多，叶子节点也最多
    - 完全二叉树
      - 对一颗具有n个节点的二叉树按层序编号，如果编号为i（1<=i<=n）的节点同与同言样深度的满二叉树中编号为i的节点在二叉树中位置完全相同，则称这颗二叉树为完全二叉树
      - 注：满二叉树一定是完全的，完全二叉树不一定是满的
      - 特点
        - 1）叶子节点只能出现在最下面两层
        - 2）最下层的叶子一定集中在左部连续
        - 3）倒数二层，若有叶子节点，一点都在右部连续位置
        - 4）如果节点的度为1，则该节点只有左孩子，即不存在只有右子树的情况
        - 5）同样接待你数的二叉树，完全二叉树的深度最小