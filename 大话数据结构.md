## CHA1 数据结构绪论

### 1.1

### 1.2

### 1.3 

- 程序设计 = 数据结构 + 算法

### 1.4

- 数据，数据元素，数据项，数据对象，数据结构

- 数据：是描述客观事务的符号，是计算机中可以操作的对象，能被计算机识别，并输入给计算机处理的符号集合

- 数据结构：数据元素之间存在一种或多种特定关系的数据元素的集合

### 1.5

- 逻辑结构：数据对象中数据元素之间的相互关系
  - 集合结构
  - 线性结构
  - 树形结构
  - 图形结构
- 物理结构（存储结构）：是指数据的逻辑结构在计算机中的存储形式
  - 顺序存储结构
  - 链式存储结构

### 1.6

- 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称
  - 原子类型
  - 结构类型
- 抽象数据类型（Abstract Data Type，ADT）是指一个数学模型及在定义该模型上的一组操作

## CH2 算法

- 2.1 数据结构与算法的关系
- 2.2 两种算法的比较
- 2.3 算法定义

  - 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
- 2.4 算法的特性

  - 输入输出，有穷性，确定性，可行性
- 2.5 算法设计的要求

  - 正确性，可读性，健壮性
  - 时间效率高和存储量第
- 2.6 算法效率的度量方法

  - 时候统计方法
    - 这种方法主要通过设计好的测试程序和数据，利用计算机计时对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
  - 事前分析估算法
    - 一个程序的运行时间，依赖于算法的好坏和问题的输入规模
- 2.7 函数的渐进增长

  - 这就是洛必达法则，其中自变量为执行一次的计算次数
- 2.8 算法时间复杂度 TODO

  - 即算法的时间度量，记作T(n) = O(f(n))
  - 在进行算法分析是，语句总的执行次数T(n)是关于问题的规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级
- 2.9 常见的时间复杂度
- 2.10 最坏情况与平均情况
- 2.11 算法的空间复杂度
  - 一般考虑时间复杂度二不考虑空间复杂度

## CHA3 线性表

- 3.1 线性表的定义

  - 线性表（List）零个或多个元素的有限序列
    - 前驱元素，直接前驱
    - 后继元素，直接后继
    - 线性表元素的个数n（n>=0）定义为线性表的长度，当n等于0时，称为空表
  - 在复杂的线性表中，一个数据元素可以由若干个数据项组成

- 3.2 线性表的抽象数据类型

  - ```
    ADT 线性表（List）
    Data
    	线性表的数据对象集合为{a1,a2,...,an},每个元素的类型均为datetype，其中，除了第一个元素，每一个元素都有且只有一个直接前驱元素，除了最后一个元素，每一个元素都有且只有一个直接后继元素，数据之间的关系是一对一的关系
    Operation
    	InitList（*L）：初始化操作，建立一个空的线性表L
    	ListEmpty（L）：若线性表为空，返回true，否则返回false
    	ClearList（*L）：将线性表清空
    	GetElem（L,i,*e）：将线性表L中第i个元素返回给e
    	LocateElem（L,e）：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功，否则，返回0表示失败
    	ListInsert（*L，i，e）：在线性表中第i个位置插入新元素e
    	ListDelete（*L,i,*e）：删除线性表L中第i个位置的元素，并用e返回其值
    	ListLength（L）：返回线性表L的元素个数
    endDat
    ```

  - 线性表顺序存储的优缺点

    - 优点
      - 无需为表示表中的元素之间的逻辑关系而增加额外的存储空间
      - 可以快速取出表中任意位置的数
    - 缺点
      - 插入和删除需要移动大量的元素
      - 当线性表长度变化较大时，难以确定存储空间的容量
      - 造成存储空间的碎片

  - 查找，插入和删除的时间复杂度

    - 无论查找哪一个数据时间负复杂度都是O(1)
    - 插入和删除最好情况将数据移动1次，时间复杂度O(1)
    - 插入和删除最坏情况将数据移动n次，时间复杂度O(n)
    - 所以插入和删除时间复杂度为O(n)

- 3.3 线性表的链式存储结构

  - 单链表的整表创建思路（头插法与尾插法）
    - 声明一指针p和计数器变量i
    - 初始化一个空链表
    - 让L的头结点指针指向NULL，即建立一个头结点的单链表
    - 循环
      - 生成一个新节点赋值给p
      - 随机生成一数字赋值给p的数据域
      - 将p插入到头结点与前一新节点之间
  - 单链表的整表删除
    - 声明一节点p和q
    - 将第一个几点赋值给p
    - 循环
      - 将下一个节点赋值给q
      - 释放p
      - 将q赋值给p
  - 单链表结构与顺序存储结构的优缺点
    - 存储方式的分配上
      - 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
      - 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
    - 时间性能
      - 查找
        - 顺序存储结构O(1)
        - 单链表O(n)
      - 插入和删除
        - 顺序存储结构需要平均移动表长一般的元素，时间为O(n)
        - 单链表在指出某位置的指针后，插入和删除的时间仅为O(1)
      - 空间性能
        - 顺序存储结构需要预先分配固定的内存，分大了，浪费，分小了，不够用
        - 单链表只在需要时分配内存空间
  - 总结
    - 在一些频繁查找，删除和插入较少的操作较少时，采用顺序存储结构
    - 表中元素变化比较大，建议使用链式存储

- 3.4 静态链表

  - 用数组描述的链表称为静态链表
  - 静态链表的优缺点
    - 优点——在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点
    - 缺点——没有解决了连续存储分配带来的表长难以确定的问题，失去顺序存储结构随机存取的特性

- 3.5 循环链表

  - 将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单循环链表，简称循环链表

  - 双向链表是在单链表的每个节点中，在设置一个指向其前驱节点的指针域

  - ```c
    typedef struct DulaNode
    {
        Elemtype data;
        struct DulaNode *perior;
        struct DulaNode *next;
    }
    ```

## CHA4 栈与队列

- 4.1 栈（stack）

  - 栈是限定仅在表尾进行插入和删除操作的线性表
    - 我们把允许插入和删除的一段称为栈顶，另一端称为栈底
    - 不含任何数据元素的栈称为空栈
    - 栈又称为后进先出（last in first out）的线性表，简称LIFO
    - 首先栈是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系
    - 其次栈是特殊的线性表，只能在表尾进行插入和删除的操作
    - 栈底是固定的，最先进栈的只能在栈底
  - 栈的插入操作叫做进栈，也称为压栈，入栈
  - 栈的删除操作，叫做出栈，也叫做弹栈

- 4.2 栈的抽象数据类型

  - ```
    ADT 栈（stack）
    Data
    	同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系
    Operation
    	InitStack(*s):初始化操作，建立一个空栈
    	DestoryStack(*s):若栈存在，则销毁他
    	ClearStack(*s):将栈清空
    	StackEmpty(s):若栈为空，返回true，否则返回false
    	GetTop(s,*e):若栈存在且非空，用e返回s的栈顶元素
    	Push(*s,e):若栈存在，且非空，插入新元素e到栈中并成为栈顶元素
    	Pop(*s,*e):删除栈s中栈定的元素，并用e返回其值
    	StackLength(s):返回栈s的个数
    endADT
    ```

- 4.3 顺序栈的实现以及共享栈的实现

- 4.4 栈的链式存储结构及实现

  - 栈的链式存储结构，简称为链栈
    - 将栈顶放在单链表的头部
    - 对于链栈来说基本不存在满栈的情况，除非内存已经没有可以使用的空间

- 4.5 比较链栈与普通栈

  - 链栈的进出栈时间复杂度均为O(1)
  - 顺序在和链栈的时间复杂度相同
  - 顺序在需要事先定义一个固定的长度，可能会存在内存空间浪费的问题，但他的优势是存取时定位很方便
  - 链栈要求每个元素有指针域，同样增加内存开销，但是在某些情况的下栈的长度变化很大，时大时小，使用链栈方便一些

- 4.6 栈的作用

  - 栈实现了递归

    - 回忆斐波那契数列，兔子，楼梯，汉诺塔，这些程序是如何实现的

    - 递归的定义：把一个直接调用自己，或者通过一系列的调用语句间接的调用自己的函数，称作递归函数
      - 每个递归函数必须至少有一个条件，满足时不再递归，开始出栈

  - 栈实现四则运算表达式求值

    - 先乘除，后加减，从左算到右

  - 一种不需要括号的后缀表示法，我们把它称之为逆波兰（RPN）
    - 例： 9 + ( 3 - 1 ) x 3 + 10 / 2（中缀表达式）（标准s四则运算表达式）
    - RPN表示：9 3 1 - 3 x + 10 2 / +（后缀表达式）
    - 运算规则
      - 从左到右遍历表达式的每个数字和符号，遇到数字进栈，遇到是符号，就将处于栈顶的两个数字出栈进行运算，运算结果进栈，一直到最终获得结构
    - 中缀表达式转后缀表达式
      - 从左到有遍历每个中缀表达式的数字和符号，
      - 若是数字就输出，即成为后缀表达式的一部分，
      - 若是符号则判断其与栈顶符号的优先级，
        - （A）优先级不高于栈顶符号，则栈顶元素依次出栈并输出，
          - 不高于==》小于等于就是不高于
        - （A）将当前符号进栈，
        - （B）若碰到（），左括号压入栈中，直到右括号准备入栈（配对成功）
        - （B）将左右括号之间的符号弹出
        - （B）一直把左括号也弹出，再压入下一个元素
      - 一直到最终输出后缀表达式为止

    计算机利用栈思想以及后缀表达式进行四则运算

    1. 将中缀表达式转换为后缀表达式
    2. 将后缀表达式进行运算得出结构

- 4.7 队列

  - 队列是只允许在一端进行插入操作，而在另一端进行删除惭怍的线性表

    - 队列是一种先入先出的线性表（first in first out）简称FIFO
    - 允许插入的一端称为队尾，允许删除的一端称为队头

  - 队列的抽象数据类型

    - ```
      ADT 队列（queue）
      Data
      	同线性表，元素具有相同的类型，相邻元素具有前驱和后继的关系
      Operation
      	InitQueue(*Q)初始化操作，建立一个空队列Q
      	DestroyQueue(*Q)若队列Q存在，则销毁他
      	ClearQueue(*Q)将队列清空
      	QueueEmpty(Q)若队列Q为空，返回True，否则返回False
      	GetHead(Q,*e)若队列存在且非空，用e返回队头元素
      	EnQueue(*Q,e)若队列存在，插入新元素e到队列中并成为队尾元素
      	DeQueue(*Q,e)删除队列Q中的队头元素，并用e返回其值
      	QueueLength(Q)返回队列的元素个数
      endADT
      ```

  - 线性表有两种存储方式，顺序存储和链式存储

    - 栈与队列都是线性表，所以都有顺序队列和链式队列
    - 虽然有两种实现方式，但是两种实现方式各有优缺点

  - 队列顺序存储的不足

    - 队列的顺序存储实现方式与线性表的的顺序存储相差不多，只不过是插入只能在队头，删除只能在队尾，线性表的顺序存储还可以在中间插入
    - 从时间复杂度看，在插入时，线性表的时间复杂度与队列的时间复杂度在一个量级上

  - 对于队列顺序存储不足的改进思路

    - 1. 设置队头
         - 和队尾指针，定义顺序存储的数组，这样做的目的是让队头元素不必只在下标为0的位置上，队头元素出队后，将队头指针向后移，这样做之后，在队列中插入和删除元素时间复杂度都变成O(1)
         - 缺点是这样使得顺序存储的数组利用率随着出队元素的增加而减，队列的长度越来越短，但是队头元素之前空着的存储位置也被浪费掉了，假溢出现象
    - 2. 循环对列的定义
         - 解决假溢出的办法解释后面满了，就从头开始，将队列的这种首尾相接的顺序存储结构称为循环队列
         - 这样的话头指针和尾指针有可能会指向同一个下标，在指向同一个下标时有两种情况，一种是队列是空的，一种是队列是满的，如何区分呢？有两种解法
           - 1） 可以设置一个flag信号，flag==0，队列空，flag==1队列满、
           - 2） 保留一个空元素，在(rear+1)%QueueSize == front 时就认为队列满了
    - 第一种解法判断简单，但是每个队列结构体得多定义一个flag信号，但问题是无法分辨当rear == flag时，队列到底是什么状态，这个到底怎么判断呢？？是不是加一个count， 进来一个加1，出去一个减1，对呀，设置一个计数器不就得了，或者可以这样，初始flag时将flag置0，当flag为0时不能进行出队操作，只能进队，然后只要有一个元素进队，就置1，不行还是计数器方便。进队加1，出队减1，初始化队列是置0，为0时只能进队，记满MAXSIZE只能出队不能进队，不用flag信号
    - 第二种解法是有一个空元素，这个比较好办，只要判断(rear+1)%QueueSize == front就可以了
    - 这么看来第二种解法是最简单的

- 4.8 队列的链式存储

  - 队列的链式存储其实就是线性表的单链表，但是只能从尾进头出而已
  - 如何初始化一个队列链表呢
    - 定义一个有结构体，成员是两个指针，一个头指针，一个尾指针，指针的类型是链表元素的结构体
    - 链表元素的结构体包含数据成员以及指向下一元素的指针成员
    - 初始化时将头指针和为指针都指向一个链表的的元素，data不做赋值，*next赋值为NULL
  - 总的来说，如果能确定队列长度最大值的情况下，建议使用循环队列，如果无法预估队列的长度，则使用链队列
  - 循环队列的入队出队操作以及链队列的入队出队操作本质上都是O(1)的，都是常数时间，链队列的每次出队和入队在节点内存的释放和申请上还是存在一定的时间开销的

- 知识点树

  - 顺序栈---》两栈共享空间
  - 顺序队列---》循环队列
  - 链式存储  ---》链栈，队列栈

## CHA5 串

- 5.1字符串的概念

  -  串是由零个或者多个字符组成的有限队列，又叫字符串
    - 一般记为 s = "a1a2...an"(n>=0)
    - s是字符串的名称，用双引号括起来的字符序列是串的值，双引号不是字符串的内容
    - 所谓字符列，说明串的相邻字符之间具有前驱和后继的关系
    - 串中的字符数目n称为串的长度
    - 零个字符的串称为空串（null string）
  - 一些特别的概念
    - 空格串，只包含空格的串，不是空串，空格串是有内容有长度的，而且可能不止一个空格	
    - 子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应的包含所有子串的称为主串
    - 子串的位置，子串的第一个字符在主串中的序号

- 5.2 串的比较

  - 比如 silly 与 stupid

    - 在计算机中的大小取决于挨个字母的前后顺序，事实上是通过组成串的字符的编码来确定的
    - 第一个字母，相同
    - 第二个字母，i在t前，t>i
    - 于是silly<stupid

  - Unicode的前256个字符的编码与ASCII的弯弯相同
