## CHA1 数据结构绪论

### 1.1

### 1.2

### 1.3 

- 程序设计 = 数据结构 + 算法

### 1.4

- 数据，数据元素，数据项，数据对象，数据结构

- 数据：是描述客观事务的符号，是计算机中可以操作的对象，能被计算机识别，并输入给计算机处理的符号集合

- 数据结构：数据元素之间存在一种或多种特定关系的数据元素的集合

### 1.5

- 逻辑结构：数据对象中数据元素之间的相互关系
  - 集合结构
  - 线性结构
  - 树形结构
  - 图形结构
- 物理结构（存储结构）：是指数据的逻辑结构在计算机中的存储形式
  - 顺序存储结构
  - 链式存储结构

### 1.6

- 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称
  - 原子类型
  - 结构类型
- 抽象数据类型（Abstract Data Type，ADT）是指一个数学模型及在定义该模型上的一组操作

## CH2 算法

- 2.1 数据结构与算法的关系
- 2.2 两种算法的比较
- 2.3 算法定义

  - 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
- 2.4 算法的特性

  - 输入输出，有穷性，确定性，可行性
- 2.5 算法设计的要求

  - 正确性，可读性，健壮性
  - 时间效率高和存储量第
- 2.6 算法效率的度量方法

  - 时候统计方法
    - 这种方法主要通过设计好的测试程序和数据，利用计算机计时对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
  - 事前分析估算法
    - 一个程序的运行时间，依赖于算法的好坏和问题的输入规模
- 2.7 函数的渐进增长

  - 这就是洛必达法则，其中自变量为执行一次的计算次数
- 2.8 算法时间复杂度 TODO

  - 即算法的时间度量，记作T(n) = O(f(n))
  - 在进行算法分析是，语句总的执行次数T(n)是关于问题的规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级
- 2.9 常见的时间复杂度
- 2.10 最坏情况与平均情况
- 2.11 算法的空间复杂度
  - 一般考虑时间复杂度二不考虑空间复杂度

## CHA3 线性表

- 3.1 线性表的定义

  - 线性表（List）零个或多个元素的有限序列
    - 前驱元素，直接前驱
    - 后继元素，直接后继
    - 线性表元素的个数n（n>=0）定义为线性表的长度，当n等于0时，称为空表
  - 在复杂的线性表中，一个数据元素可以由若干个数据项组成

- 3.2 线性表的抽象数据类型

  - ```
    ADT 线性表（List）
    Data
    	线性表的数据对象集合为{a1,a2,...,an},每个元素的类型均为datetype，其中，除了第一个元素，每一个元素都有且只有一个直接前驱元素，除了最后一个元素，每一个元素都有且只有一个直接后继元素，数据之间的关系是一对一的关系
    Operation
    	InitList（*L）：初始化操作，建立一个空的线性表L
    	ListEmpty（L）：若线性表为空，返回true，否则返回false
    	ClearList（*L）：将线性表清空
    	GetElem（L,i,*e）：将线性表L中第i个元素返回给e
    	LocateElem（L,e）：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功，否则，返回0表示失败
    	ListInsert（*L，i，e）：在线性表中第i个位置插入新元素e
    	ListDelete（*L,i,*e）：删除线性表L中第i个位置的元素，并用e返回其值
    	ListLength（L）：返回线性表L的元素个数
    endDat
    ```

  - 线性表顺序存储的优缺点

    - 优点
      - 无需为表示表中的元素之间的逻辑关系而增加额外的存储空间
      - 可以快速取出表中任意位置的数
    - 缺点
      - 插入和删除需要移动大量的元素
      - 当线性表长度变化较大时，难以确定存储空间的容量
      - 造成存储空间的碎片

  - 查找，插入和删除的时间复杂度

    - 无论查找哪一个数据时间负复杂度都是O(1)
    - 插入和删除最好情况将数据移动1次，时间复杂度O(1)
    - 插入和删除最坏情况将数据移动n次，时间复杂度O(n)
    - 所以插入和删除时间复杂度为O(n)

- 3.3 线性表的链式存储结构

  - 单链表的整表创建思路（头插法与尾插法）
    - 声明一指针p和计数器变量i
    - 初始化一个空链表
    - 让L的头结点指针指向NULL，即建立一个头结点的单链表
    - 循环
      - 生成一个新节点赋值给p
      - 随机生成一数字赋值给p的数据域
      - 将p插入到头结点与前一新节点之间
  - 单链表的整表删除
    - 声明一节点p和q
    - 将第一个几点赋值给p
    - 循环
      - 将下一个节点赋值给q
      - 释放p
      - 将q赋值给p
  - 单链表结构与顺序存储结构的优缺点
    - 存储方式的分配上
      - 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
      - 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
    - 时间性能
      - 查找
        - 顺序存储结构O(1)
        - 单链表O(n)
      - 插入和删除
        - 顺序存储结构需要平均移动表长一般的元素，时间为O(n)
        - 单链表在指出某位置的指针后，插入和删除的时间仅为O(1)
      - 空间性能
        - 顺序存储结构需要预先分配固定的内存，分大了，浪费，分小了，不够用
        - 单链表只在需要时分配内存空间
  - 总结
    - 在一些频繁查找，删除和插入较少的操作较少时，采用顺序存储结构
    - 表中元素变化比较大，建议使用链式存储

- 3.4 静态链表

  - 用数组描述的链表称为静态链表
  - 静态链表的优缺点
    - 优点——在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点
    - 缺点——没有解决了连续存储分配带来的表长难以确定的问题，失去顺序存储结构随机存取的特性

- 3.5 循环链表

  - 将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单循环链表，简称循环链表

  - 双向链表是在单链表的每个节点中，在设置一个指向其前驱节点的指针域

  - ```c
    typedef struct DulaNode
    {
        Elemtype data;
        struct DulaNode *perior;
        struct DulaNode *next;
    }
    ```

## CHA4 栈与队列

- 4.1 栈（stack）

  - 栈是限定仅在表尾进行插入和删除操作的线性表
    - 我们把允许插入和删除的一段称为栈顶，另一端称为栈底
    - 不含任何数据元素的栈称为空栈
    - 栈又称为后进先出（last in first out）的线性表，简称LIFO
    - 首先栈是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系
    - 其次栈是特殊的线性表，只能在表尾进行插入和删除的操作
    - 栈底是固定的，最先进栈的只能在栈底
  - 栈的插入操作叫做进栈，也称为压栈，入栈
  - 栈的删除操作，叫做出栈，也叫做弹栈

- 4.2 栈的抽象数据类型

  - ```
    ADT 栈（stack）
    Data
    	同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系
    Operation
    	InitStack(*s):初始化操作，建立一个空栈
    	DestoryStack(*s):若栈存在，则销毁他
    	ClearStack(*s):将栈清空
    	StackEmpty(s):若栈为空，返回true，否则返回false
    	GetTop(s,*e):若栈存在且非空，用e返回s的栈顶元素
    	Push(*s,e):若栈存在，且非空，插入新元素e到栈中并成为栈顶元素
    	Pop(*s,*e):删除栈s中栈定的元素，并用e返回其值
    	StackLength(s):返回栈s的个数
    endADT
    ```

- 4.3 顺序栈的实现以及共享栈的实现

- 4.4 栈的链式存储结构及实现

  - 栈的链式存储结构，简称为链栈
    - 将栈顶放在单链表的头部
    - 对于链栈来说基本不存在满栈的情况，除非内存已经没有可以使用的空间

- 4.5 比较链栈与普通栈

  - 链栈的进出栈时间复杂度均为O(1)
  - 顺序在和链栈的时间复杂度相同
  - 顺序在需要事先定义一个固定的长度，可能会存在内存空间浪费的问题，但他的优势是存取时定位很方便
  - 链栈要求每个元素有指针域，同样增加内存开销，但是在某些情况的下栈的长度变化很大，时大时小，使用链栈方便一些

- 4.6 栈的作用

  - 栈实现了递归

    - 回忆斐波那契数列，兔子，楼梯，汉诺塔，这些程序是如何实现的

    - 递归的定义：把一个直接调用自己，或者通过一系列的调用语句间接的调用自己的函数，称作递归函数
      - 每个递归函数必须至少有一个条件，满足时不再递归，开始出栈

  - 栈实现四则运算表达式求值
