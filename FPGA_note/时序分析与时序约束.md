1. 

时序分析

2. 

时序分析本质上就是一种时序检查，目的是检查设计中所有的D触发器是否能够正常工作

也就是

检查D触发器的同步端口（数据输入端口）的变化是否满足建立时间要求（setup）和保持时间要求（hold）

> 大部分是上升沿采样，在时钟跳变沿，也就是寄存器采样之前数据就需要稳定下来，如果没有稳定下来的话，输入端D的数据就很有可能不能被稳定的打入到输出端，数据段打入寄存器之后也要保持一定的时间，不能保持稳定的话可能使D端的数据不能正确的传送到Q端轻则数据出错，重则出现亚稳态的处理

检查D触发器的异步端口（异步复位端口）的变化是否满足恢复时间要求（recovery）和移除时间要求（removal）

> 异步端口的时序分析不太常见
>
> 时钟上升沿向前到recovery时间，如果复位释放的时间点在recovery时间之内，寄存器在时钟沿就不能处在一个稳定的复位状态，如果在时钟上升沿之后的removal时间段内释放了复位，时钟沿采样后可能也不会处于一个稳定的复位状态

3. 

时序分析有哪些类型

​	时序分析包括静态时序分析（STA）和动态时序分析。

动态时序分析：将布局布线生成的布线延迟信息反标注到门级网表中进行仿真，检查是否存在时序违例，此时的仿真包括门延迟和布线延迟信息，能够较好反应芯片的实际工作情况，因为不可能产生完备的测试向量，覆盖门级网表中的每一条路径，因此在动态时序分析中，无法暴露一些路径上可能存在的问题

> 仿真需要输入激励，激励覆盖时序路径不完全，就算是写了很多case也不能保证完全测试到所有时序路径；还有一个问题就是每一个case中加入了门级的延迟，所以需要的内存就很大，并且跑完一个case需要很长时间

静态时序分析：采用穷尽分析方法来提取整个电路存在的所有时序路径，计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足时序要求，通过对最大路径延时和最小路径延时的分析，找出违背时序约束的错误。他不需要输入向量就能穷尽所有的路径，且运行速度很快，占用内存较少，不仅可以对芯片设计进行全面的时序功能检查，而且还可利用时序分析的结果来优化设计，因此静态时序分析已经越来越多的被利用到数字集成电路设计的验证中

> STA主要是通过成熟优秀的EDA工具进行的，工具把整个设计分成一小段一小段的时序路径，将每一段时序都进行上述四个时序的检查，在检测的过程中用户必须通过时序的约束告诉工具一些基本的信息，工具需要一些信息才能进行检测，静态时序分析虽然不直观，只会告诉你某条路径存在时序违例，告诉时序违例有多大，具体是怎么出现这个违例的，可能需要通过一些时序分析报告来分析数据路径时钟路径的延迟等信息来进一步确定，好处就是他会分析每一条时序路径，

4. 

时序分析工具

静态时序分析工具

动态时序分析工具

静态时序分析之前需要做什么准备工作

​	撰写基本的时序约束文件，告知时序引擎一些必要的信息（比如时钟，输入输出延时等）。若没有正确的时序约束，那么时序分析的结果是没有意义的

> 时序分析之前理清整个设计中的时钟路径和复位路径，每条时钟路径上经过哪些模块，有没有组合逻辑；复位路径上不要出现组合逻辑，比如将复位信号与其他复位信号进行与或运算，这些都是不推荐的，我们一般希望时钟路径，复位路径上是比较干净的，用户逻辑不要加在时钟路径和复位路径
>
> 需要些一些基本的约束文件，时钟信息，输入输出延时都要告知时序分析引擎，如果没有这些信息，就不能进行正确的时序分析，产生的时序分析报告也是没有意义的

5. 

D触发器中Tsetup，Thold，Tco的由来

> Tco时钟端检测到输出沿或者跳变沿的时候输出端稳定下来——？

6. 

时序分析常用的术语

源时钟

目的时钟

发起沿

捕获沿

7. 

一条普通时序路径的三要素

源时钟路径

数据路径

目的时钟路径

> 一般来说源时钟和目的时钟的起点都是相同的

8. 

FPGA常见的四种时序路径

第一种：从FPGA的输入端口到目的寄存器的数据输入端口

这种路径没有源时钟路径，用户需要越是Input Delay和时钟来告知时序引擎必要信息，时序引擎才能正确的分析这种路径

9. 

FPGA常见的四种时序路径

第二种：从源寄存器的时钟端口到目的寄存器的数据输入端口

这种时序路径是最常见的，用户需要约束源时钟和目的是时钟告知时序引擎必要的信息，时序引擎才能正确的分析这种时序路径

10.  

FPGA常见的四种时序路径

第三种：从源寄存器的时钟端口到FPGA的输出端口

这种路径没有目的时钟路径，用户需要约束Output Delay 和时钟来告知时序引擎的必要信息，时序引擎才能正确的分析这种路径

11. 

FPGA常见的四种时序路径

第四种：从FPGA的输入端口到FPGA的输出端口

这种路径中只有数据路径，用户需要约束Input Dealy 和Output Dealy，告知时序殷勤必要的信息，时序引擎才能正确的分析这种时序路径

> 很少见，重点考虑的就是上面三种路径

12. 

时序引擎是如何进行setup检查的

首先确定建立时间要求（建立时间的捕获沿—建立时间的发起沿）

> 建立时间要求一定都是大于0 的
>
> 这里的时序分析都是以vivado为例子
>
> 这里面主要考虑三种情况
>
> 1. 目的时钟和源时钟频率相同
>    1. 建立时间分析为目的时钟向右推，遇到的第一个时钟跳变沿，不考虑延时的话是一个时钟周期
> 2. 目的时钟和源时钟频率有最小公倍数
>    1. 如果有最小公倍数，那么就是说建立时间时刻以被穷尽的，我们从这些建立时间最小的来分析，如果最小的都可以满足，那么比最小的大的当然可以满足
> 3. 目的时钟和原始没有最小公倍数
>    1. 会从当前时刻分析附近的1000个时钟周期，从中找出最小的setup时间，但这时的分析已经不可靠了，这1000个找了，下一个1000已经不确定了

13. 

   时序引擎是如何进行setup检查的

​	第一步确定建立时间要求

​	第二步计算数据的需求时间

​	第三步计算数据到达时间

​	第四部计算setup的裕量（slack）

14. 

setup分析实例

data require time

data arrival time

15. 

setup分析实例

setup slack 

16.

根据公式分析哪些因素会导致setup为负

> 时钟歪斜一般来说没有在时钟路径上加一些组合逻辑或者一些其他操作的话，一般都很小
>
> Tsu，Tco的值是寄存器的特性无法改变，在使用block ram的时候，这两个个值可能比较大，这时需要仔细考虑
>
> 正常情况下需要考虑的的是setup requirement，Tlogic，Tnet，这三个会影响比较大
>
> setup requirement在同一个时钟的情况下，时序分析引擎在选择launch clock和capture clock一般情况下是正确的
>
> 有时候源时钟路径和目的时钟路径可能是不同的时钟，但是还是属于同步时钟的两个时钟，在这种情况下，capture edge 和launch edge 有可能会被选错，如果选错的情况下，setup requirement有可能会很小，这条路径在任何情况小都不可能满足时序要求了，在这种情况下，用户只能手动的设置约束调整正确
>
> 对于从同一个时钟源出来的经过pll分频器的时钟，由同一时钟源产生的，频率和相位可能不同，对于有同一个时钟源的时钟的话，他们都属于同步时钟，都可以进行时序分析
>
> logic 就是组合逻辑路径太长了，比如进行一个大位宽的乘加运算，可能就会导致组合逻辑就很长，中间就会有很多LUT
>
> Tnet布线延迟，在某些情况下，一根网线延迟是不超过1ns的，但是不排除特殊情况，比如某些模块可能会出现拥塞，如果出现拥塞，就会导致延迟很长，达到2ns，3ns都是有可能的

17. 

setup requirement 与实际情况不符合

> 比如同步同频不同相位的时钟，相位偏移很小，按照时序引擎的的分析方法，setup clock 向右推找到的第一个时钟跳变沿作为capture edge的话，就有可能导致setup requirement太小，这样就可能使得设计时序违例可能性增加

18. 

clk skew为负值，且很大

> 一般来说时钟歪斜可正可负，关注的是他很大的时候
>
> BUFGCE、MMCM、PMMCM是什么
>
> MMCM一般来说是有相位补偿和延时补偿，经过MMCM路径的延迟不仅没有增加，可能还会减少

19. 

Tsu/Tco很大

> 注意使用block ram 时应该尽量降低信号的扇出，因为block ram 的位置相对比较固定，如果控制信号扇出很大，那么可能导致布线延迟比较大

20. 

工程示例

> 非首字置出的fifo，fifo的uTco非常大，在这条路径上增加别的组合逻辑的话，就有可能违例，所以block ram 的输出打一拍比较好

21. 

Tlogic比较大

> 逻辑延迟一般由用户写代码造成的
>
> 通过一个lut和一根网线的延迟大概的延迟为0.5ns左右
>
> 某些情况下网线延迟很大，多一级逻辑层级会多好几个ns
>
> 如何判断某一条路径是不是逻辑层级过大的长路径呢？延迟过大呢？
>
> 时钟周期 = 0.5ns * 逻辑层级，如果时钟周期小于等于逻辑层级的延迟就说明时序路径就属于长路径了，这时候主要优化的力度就应该针对逻辑层级的延迟，时序违例大概率就是由长路径组成的

22. 

项目示例

23. 

Tnet 大

> 一般来说，发生较大布线延迟的话，首先看设计整体的资源利用率是不是很大
>
> 设计整体资源利用率一般包括两个，一个是CLB可编程逻辑模块，clb中包括寄存器和lut，第二个是BRAM，主要实现用户的存储需求
>
> 如果设计的CLB或BRAM的资源利用率过高，都会导致设计整体发生拥塞，从设计整体去入手
>
> BRAM这些模块位于FPGA芯片中固定的位置，这些位置会导致布线延迟会高于一般的资源
>
> 根据综合产生的报告，观察哪些某块的利用率特别高，针对这些模块进行优化，将模块资源利用率降下来，从而让设计整体的资源利用率降下来，减轻设计拥塞
>
> 有时候设计整体的资源利用率不是很高，但是某一个模块资源利用率很高，比如某一个模块被多次例化，针对这个模块进行优化
>
> 优化的手段主要是优化分布式ram，分布式ram占用的是clb中的一种专用的lut，这种lut既可以作为分布式ram也可以做为组合逻辑，如果将这种lut作为分布式ram，某些相邻的寄存器就不能用了，这就会导致实际的一些资源被浪费掉
>
> 一般来说主要是优化这些寄存器堆，也就是分布式ram和black ram的大小以及一些信号的扇出太大
>
> 比如说一个fifo的输出数据同时要被四个模块采样，这样扇出就很大，如果不对这个扇出做优化，这些扇出很大的相关信号的布线延迟就会很大
>
> 优化扇出的方法有两种，一种是在xilinx中设置max_fin_out进行设置，这种情况有时候会失效，某些时候这种方法会失效；第二种推荐的方法是手动去复制这些寄存器，（？？？？没有搞太懂）被复制的寄存器在综合的时候要加一些属性，因为综合的时候可能会把这些寄存器当做冗余的寄存器给优化掉

24. 

项目示例

1：23：01

