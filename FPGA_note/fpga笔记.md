## 设计流程

1. 设计定义
2. 模块划分，接口定义
3. 设计输入（verilog vhdl，sv）
4. 分析和综合（quartus，vivado，ise）
5. 功能仿真（modelsim）
6. IO分配，布局布线
7. 时序仿真
8. 配置文件的生成，配置（烧写）fpga
9. 在线调试（嵌入式逻辑分析仪）

## 学习要点

基本逻辑

接口逻辑：uart can spi lvds

状态机，线性序列机（计数器，按时间分片）

IP的使用，第三方厂家，包括计数器，io接口，fft，各种软核CPU

接口设计

时序分析，时序约束

## wire与reg的区别

wire

- wire型数据通常用来表示用以assign关键字指定的组合逻辑信号
- verilog程序模块中输入输出信号类型默认时自动定义为wire型
- wire型信号可以用作任何方程式的输入，也可以用作assign语句或实例原件的输出

reg

- reg型数据常用来表示always模块内的指定信号，常代表触发器
- 在时序逻辑always模块内被赋值的每一个信号都必须被定义为reg型
- reg型数据的默认初始值是不定值

触发器和锁存器的区别

- 锁存器靠控制信号的电平实现数据的保存
- 触发器靠控制信号的边沿变化实现数据的保存

## cpld与fpga的异同

- fpga是在cpld之后发展出的一种更复杂的pld
- fpga集成了更多且更复杂的资源，包括可配置的逻辑块，时钟资源，时钟管理模块，块存储资源，互联资源，专用dsp模块，输入/输出块，XADC模块等，在一些高性能的fpga内还提供了吉比特收发器和PCI-E模块等硬核资源
- cpld使用与或阵列，fpga使用查找表结构，这是fpga最基本的原理

## 查找表LUT（look-up table）原理

- 由布尔逻辑代数理论可知，对于一个n输入的逻辑运算，最多产生2的n次方个不同的组合，如果预先将每个逻辑输入对应的结果保存在一个存储单元中，就相当于实现了逻辑门电路的功能
- fpga内的组合逻辑电路均由查找表实现
- LUT实现组合逻辑电路的功能由输入决定，而不是由复杂度决定
- LUT实现组合逻辑有固定的传输延迟 

- 相较于传统的逻辑门电路，LUT实现组合逻辑电路的功能克服了以下缺点
  - 逻辑门电路的输入变量从输入经过逻辑门运算后送到逻辑输出变量，存在一定的延时，延迟大小与逻辑电路的复杂度相关，并且是不确定的，延迟时间的不确定，工作频率就不确定，工作频率与时序逻辑电路的工作速度密切相关，由于工作速度的不确定，从而影响到了整个电路的性能
  - 逻辑电路的复杂度与输入逻辑变量的个数和逻辑电路所使用的逻辑门的数量有关，很明显，逻辑电路输入变量越多，电路越复杂

## 约束文件

- xlinix vivado集成开发环境使用xlinix 设计约束（xlinix design constraints，XDC）
- XDC是基于标准的synopsys设计约束（synopsys design constraints，SDC）的
- XDC文件特点
  - 不是简单的字符串，遵循tcl语法命令
  - 通过vivado tcl 翻译器就可以像理解tcl命令那样理解他们
  - 可以读取tcl指令，然后按照顺序对命令进行分析
- 如何添加XDC
  - 在设计的不同阶段均可添加XDC，将约束保存在一个或者多个XDC文件中
  - 通过read_xdc命令
  - 将他添加到其中一个设计工程的约束集中
- 通过TCL脚本生成的约束，可以通过下面的方法运行TCL脚本
  - 运行source命令
  - 将TCL叫脚本添加到其中一个设计工程约束集中

## 模块端口定义

- 三种模块端口定义，input， output， inout

- 我是这么理解的，首先在模块命后的括号内定义端口，然后声明端口
  - 声明端口时同时声明端口的数据类型，没有声明端口类型的情况下默认为线网类型，端口类型有线网（net）型和寄存器（reg）型
  - 有符号（signed）型数据，无符号型数据，没有声明端口有无符号时，默认为无符号型的端口

## verilog的描述方式

- 行为级描述是verilog hdl最高抽象级别的描述方式，可以按照要求来实现一个设计算法，而不用关心具体的实现方式，但是行为级描述是不可以被综合的，行为级描述语句可以描述逻辑行为，包括initial语句和always语句，用于对设计进行仿真，不能转化为实际的电路结构。

- 寄存器传输级（rtl）级描述，数据流描述，可以理解为在一个复杂的数字系统中，应该包含有数据流和控制流，控制流用于控制数据的流向，寄存器传输，任何数据从输入到输出，都需要经过寄存器来对数据重定序，这样，保证数据从输入到输出满足书序收敛的条件，不会出现竞争冒险与亚稳定状态。完成后将转化为实际的电路

## 系统任务和函数，编译器指令

- 以" $ "开始的标识符表示系统任务或者系统函数
- 以" ` "开始的的某些表示符看做编译器指令

## verilog 中数字的使用

- 不太理解：" 在任何时候，负数应该使用二进制补码形式表示 "，这是啥意思？

- ```<+/-><size><'base_format><number>```
- 第一的尖括号里为正负，可正可负也可以不写，不写默认为正数或者无符号数
- 第二个尖括号为位宽，在使用数字时必须带位宽，位宽包括有符号数的符号位
  - 未指定位宽，默认位宽至少32位
  - size位宽小于number位宽，将高位截断，保留低位
  - size位宽大于number位宽，根据正负（符号位）补全，正数补0，负数补1；无符号数补0；number最高位为x/z则同样补x/z
- 第三个尖括号为数的格式，base_format = {b, o, d, h, sb, so, sd, sh}，s代表为有符号数，
  - 可有与第一个尖括号中的正负搭配使用，完全的定义，不会产生歧义
  - 也可以只有第一个尖括号中的正负不写s，有点问题哎，尽量避免这样的定义
  - 也可以没有第一个尖括号的正负值有后面的s，当然是默认为正的有符号数
- 第四个尖括号中可以出现的数字为 number = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, x, z, ?}(不区分大小写)以及作为连接符的下划线"_",
  - x不确定态，z高阻态，？作用同z
  - x,z,?，根据base_format的定义，所代表的位宽可以为1,2,4，当然十进制的话我也不知啦，不要那么用，没有意义

## 属性attribute

- 参见数字设计权威指南何宾

- 知道但不会用，感觉是指定一些特定的东西，在综合是加进去，比如之前用过的探针属性，属性有自己的名字，以及自己对应的值

## testbench文件中的时间定义

```1 s = 1,000 ms = 1,000,000 μs = 1,000,000,000 ns = 1,000,000,000,000 ps```

皮秒，符号ps（英语：picosecond ），1皮秒等于一万亿分之一秒（```10^(-12)s```）

``` 1,000 ps= 1ns```

```1,000,000 ps = 1μs ```

```1,000,000,000 ps = 1ms```

```1,000,000,000,000 ps = 1s```

纳秒，符号ns（英语：nanosecond ），1纳秒等于十亿分之一秒（```10^(-9)s```）

```1 ns= 1000ps```

```1,000 ns= 1μs ```

```1,000,000ns = 1ms```

```1,000,000,000 ns= 1s```

微秒，符号μs（英语：microsecond ），1微秒等于一百万分之一秒（```10^(-6)s```）

```0.000 001 μs= 1ps```

```0.001 μs= 1ns```

```1,000 μs= 1ms```

```1,000,000 μs= 1s```
毫秒，符号ms（英语：millisecond ），1毫秒等于一千分之一秒（10-3秒）

```0.000 000 001 ms= 1ps``` 

```0.000 001 ms= 1ns ```

```0.001 ms = 1μs ```

```1000 ms = 1s```

```verilog
`timescale 1ns/1ps //单位/精度
#100 //延时100ns
//-------------------------
`timescale 10ns/1ps
#100//延时100*10ns
#0.1//0.1ns = 1ps，仿真精确到小数点后一位
```

## 时钟管理单元（PLL，DLL）

​	PLL（Phase-Locked Loop）相位锁定的环路，也就是常说的锁相环，锁相环在模拟电路和数字电路系统中均有广泛的应用，很多mcu芯片如stm32，msp430，等都集成了片上的pll，用来通过片外较低频率的晶振产生的时钟倍频得到较高频率的时钟信号以供mcu内核和片上的外设使用，在很多的洗衣芯片中也用到得了pll来通过较低的晶振时钟得到符合协议要求的时钟信号，例如典型的usb协议芯片

- 锁相环 PLL
  - PLL （phase locked loop，锁相环），模拟电路
  - pll与dll的区别：pll是数字的，dll是模拟的，pll精度较高
  - 特性：能够将输入的周期信号就行分频和倍频，并最终输出一个或多个稳定的，与输入信号频率和相位相关的信号
  - 总结：能够通过对输入的时钟信号进行分频，倍频，相位控制，从而得到一路或者多路更高或者更低的时钟信号

## 参数传递

- define 与localparam和parameter最大的区别就是 define 可以跨文件传递参数；parameter只能在模块间传递参数；而localparam只能在其所在的module中起作用，不能参与参数传递。

  1. 新建参数模块文件（我命名为para.v）；

  2. 在para.v文件中使用'define宏定义参数（部分）

     ```verilog 
     //`define+name+参数 　
     `define 　　STATE_INIT	3'd0
     `define 　　STATE_IDLE	3'd1
     `define 　　STATE_WRIT	3'd2
     `define 　　STATE_READ	3'd3
     `define 　　STATE_WORK	3'd4
     `define 　　STATE_RETU	3'd5
     ```

  3. 在需要调用参数的文件init.v中使用`include "para.v"：

     ````include "para.v"```

4. 在init.v文件需要参数的地方使用`name 调用（部分）：`

    ````state_init <= `STATE_INIT;```

  5. localparam与parameter的区别与用法

- parameter可用作在顶层模块中例化底层模块时传递参数的接口；

- localparam的作用域仅仅限于当前module，不能作为参数传递的接口。

- ```Verilog
  //用法
  parameter       DATA_WIDTH = 16;
  parameter       ADDR_WIDTH =  5;
  localparam      DW = DATA_WIDTH - 1;
  localparam      AW = ADDR_WIDTH - 1;
  
  ```

## FPGA的资源

- 可编程逻辑功能块——类比电路板的各种元器件

- 可编程I/O口——类比电路板的输入输出

- 可编程内部互联资源——元器件之间的通信总线

## 电源设计

- cyclone IV E 需要三组供电
  - 内核供电   1.0V；非低电压版本为1.2V
  - pll模拟电路供电，数字电路供电1.2V，模拟电路供电固定的2.5V，使用LDO器件 
  - I/O单元供电，电压值从1.2V~3.3V（1.2；1.5；1.8；2.5；3.0；3.3），共6中可选值，IO Bank 每个bank的IO供电都可以不同

## 配置电路设计

- cyclone IV E 基于SRAM的结构的，SRAM掉电就会丢失，因此系统上电后，必须要有配置电路将正确的配置数据加载到SRAM中，然后FPGA才能正常运行
- 五种配置方式（AS，AP，PS，FPP，JTAG）
  - AS 主动串行方式，电路简单，成本低廉，常用语中小容量的FPGA
  - AP主动并行方式，消耗引脚比较多，常用于配置过程的时间要求较高
  - PS被动串行方式，使用一个外部的主机MCU或者CPLD，常用于通过网络方式对fpga的升级
  - JTAG配置方式，可以在器件正常工作过程中捕获运行数据，JTAG指令具有最高优先级
- 对FPGA进行配置
  - FPGA中没有flash，FPGA基于sram架构，掉电程序丢失，FPGA程序存储在外部的flash中，叫做epcs， 实际上是就是spf flash芯片（stm32 片上程序一般存储在flash中）
  - 使用jtag直接配置 .sof，FPGA 掉电，就会变成白片
  - 使用外部器件进行片配置，flash不会丢失，FPGA上电时主动加载程序
  - 使用外部的控制器进行配置

## 硬件乘法单元

- 18*18硬件乘法器，乘数和被乘数输入宽度最大为18位的乘法器
- 乘法器电路复杂，使用fpga内部资源能实现，但是性能会受限，也消耗更多的面积，不利于降低成本和功耗
- 硬件乘法单元在芯片设计时功能和布局都已经确定，即使不使用，他也在
- 每个硬件乘法电路也能拆分成两个位宽为9的存储器 

## 编码方式的区别

对于状态机

- 独热码，每一个状态均使用一个寄存器， 在于状态比较时仅仅需要比较一位， 相比其他译码电路简单；

- 格雷码，所需寄存器数与二进制码一样，译码复杂，但相邻位只跳动一位，一般用于异步多时钟域多 bit 位的转换，如异步 FIFO；

- 二进制码，最为常见的编码方式，所用寄存器少，译码较复杂。 

对于计算

- BCD 码中最常用的是 8421 码，其各个 bit 权值分别是 8d、 4d、 2d、 1d
- 同理 5421 码各位的权依次为 5d、 4d、 2d、 1d。 5421 码特点是最高位连续 5 个 0 后连续 5 个 1，故其当计数器采用这种编码时，最高位可产生对称方波输出
- 余 3 码是在 8421 码上加 0011b 的出来的；
- 格雷码的特点是任意两个相邻的代码只有一位二进制数不同，编码格式不唯一；
- 余 3 循环码具有格雷码的特点并且编码的首尾可以连接来进行循环，这样可用反馈移位寄存器来实现，硬件实现简单。 

- BCD码利于十进制的计算

  BCD 码的运算规则： BCD 码是十进制数，而运算器对数据做加减运算时，都是按二进制运算规则进行处理的。这样，当将 BCD 码传送给运算器进行运算时，其结果需要修正。修正的规则是：当两个 BCD 码相加，如果和等于或小于 1001b(即十进制数 9)，不需要修正；如果相加之和在 1010b 到 1111b(即十六进制数 0AH～0FH)之间，则需加 6d 也就是 0110 进行修正；如果相加时，本位产生了进位，也需加 6 进行修正。下面举例说明：计算 5+8，将 5和 8 转换为 8421 BCD 码后输入加法器，则运算如下： 0101 + 1000 = 1101 结果大于 9d，+0110b 即加 6d 修正得出 10011b，补充高位为 0001_0011b。 即 5+8=13，结论正确。

  BCD 码的主要应用之一就是数码管，假设要将十进制数 158 显示， 一般解决办法是把需要显示的十进制数的个、十、百、千位数等进行拆分，即把 158 拆分出 1、 5、 8，然后查出对应的数码管显示段码再送去给数码管连接的 IO 口。这个过程可以进行下面的运算：先进行除法运算 158/100 得出百位 1，再取余 158%100 = 58 后继续进行除法运算 58 / 10 得出十位 5，再进行一次取余 158%10 ，得到个位 8。以上过程可以看出需要除法，但是由于除法运算是比较消耗计算时间导致整体需要的指令周期太久。但是如果先将其转换为 BCD 码，则可大幅度减少运算时间。 具体应用将在数码管一讲中详细介绍。 

## 三种状态机写法的区别

- 同步状态机的原理结构和设计
  1. 下一状态 = F（当前状态，输入信号）
  2. 输出信号 = G（当前状态，输入信号）mealy状态机
  3. mealy状态机：时序逻辑的输出不但取决于状态还取决于输入，大部分都是mealy状态机
  4. moore状态机：时序逻辑电路的输出只取决于当前状态

- 时序逻辑电路与组合逻辑电路的区别
  - 时序电路输出状态不仅取决于当前输入，也取决与当前的电路状态
  - 组合逻辑电路输出只取决于当前输入

状态机描述方式，可分为一段式、两段式以及三段式。

- 一段式，整个状态机写到一个 always 模块里面。 在该模块中既描述状态转移，又描述状态的输入和输出。
- 两段式，用两个 always 模块来描述状态机。 其中一个 always 模块采用同步时序描述状态转移， 另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律及其输出。 
- 三段式，在两个 always 模块描述方法基础上，使用三个 always 模块。 一个 always 模块采用同步时序描述状态转移，一个 always 采用组合逻辑判断状态转移条件，描述状态转移规律，另一个 always 模块描述状态输出(可以用组合电路输出，也可以时序电路输出)。 

三种状态机的问题

- 可以看出两段式有限状态机与一段式有限状态机的区别是将时序部分（状态转移）和组合部分（判断状态转移条件和产生输出）分开，写为两个 always 语句，即为两段式有限状态机。将组合部分中的判断状态转移条件和产生输出再分开写，则为三段式有限状态机。
- 二段式在组合逻辑特别复杂时，注意需在后面加一个触发器以消除组合逻辑对输出产生的毛刺的影响。三段式则没有这个问题， 这是由于第三个 always 会生成触发器。其实现在的器件根本不在乎这一点资源消耗，推荐使用二段式或者三段式以及输出寄存的状态机输出来描述有限状态机。
- 编写状态机还应主要注意的事项是，为了避免不必要的锁存器生成，需要穷举所有状态对应的输出动作，或者使用 default 来定义未定义状态动作；
- 在定义状态时， 推荐使用本地化参数定义 localparam，这样可以在编写时状态更清晰且不容易出错，也方便修改；在复位或者跑飞能回到初始态或者预定态；要有异步或者同步复位来确保状态机上电有个初始态。

## 两种fifo设置的区别

- normal synchronous FIFO mode 与 show-ahead synchronous FIFO mode区别

- 选则第一种普通方式则 rdreq 信号作为实际意义上的读请求信号，当该信号有效时 FIFO 中的控制逻辑从存储器中读取一个数据输出到 q 端。 
- 如果选中 Show-ahead 方式，则 rdreq 实际作为了读应答信号，即 rdreq 还没有有效时， q 端口上已经输出了一个有效的数据， rdreq 信号有效的时候则相当于通知 FIFO 内部的控制逻辑 q 端口上的数据已经被读取，则 FIFO 内部的逻辑会从 RAM 中再取出一个新的数据，在下一个时钟周期输出到 q 端口上。该模式在实际中应用也非常的普遍，因为 q 端口上的数据 与 rdreq 同时有效，没有读潜伏期。 

## readmemb与readmemh的使用

1. 在verilog中有$readmemh(“filename”, mem_name)命令，在使用这个命令时，”filename”中的路径要用反斜杠’/’，而不是斜杠’\’。如

   - $readmemh("F:/mydesigen/re_input.txt",re_input);

   - 上面的语句是正确的，而如果用斜杠就有问题，如

   - $readmemh("F:\mydesigen\re_input.txt",re_input);

2. readmemb（“D：/file1/file2/ramh.dat”，a）；即可以调用到放置在任意处的存储文件。当采用$readmemb（“ramh.dat”，a）；这种方式时，ramh.dat文件必须放置在工程下的simulation文件夹下，亲测其他放置都无效。

3. 关于存储文件后缀，.dat .txt 甚至不加后缀都可以，只要保证程序里调用的与文件夹中实际的一致，可以索引到即可

4. 对于需要的txt文件，其格式为每行一个数据，存储顺序。文档中由上至下，对应数组由低到高。

   - 例如用matlab产生文件则可以这样写

     ```fid0 = fopen('F:\path\re_input.txt','w+');```

     ```fprintf(fid0,'%x \n',real(info));```

     其中的换行符是必须的。同时，在matlab中，路径语句的斜杠’\’或是反斜杠’/’都没有问题。

5. 不可综合。readmemb、readmemh、initial 都是不可综合语句（怎么可以这样呢！那大数组怎么赋值？）也就是说只能在仿真时调试用。

6. 对于$readmemh对应的16进制文件，不用写成4'hA，最简单的A即可。

## AXI

- AXI（Advanced eXtensible Interface）是一种总线协议，该协议是ARM公司提出的AMBA（Advanced Microcontroller Bus Architecture）3.0协议中最重要的部分，
- AXI 是一种面向高性能、高带宽、低延迟的片内总线。它的地址/控制和数据相位是分离的，支持不对齐的数据传输，同时在突发传输中，只需要首地址，同时分离的读写数据通道、并支持Outstanding传输访问和乱序访问，并更加容易进行时序收敛。
- AXI 是AMBA 中一个新的高性能协议。AXI 技术丰富了现有的AMBA 标准内容，满足超高性能和复杂的片上（SoC）设计的需求。

## qsys？nios II？sopc？

qsys是一个工具，这个工具是用来帮助搭建系统的

nios II是一款cpu，是一个处理器

sopc是一种技术，可编程偏上系统，是一种解决方案

## sopc

sopc：使用FPGA通用逻辑搭建CPU和外围设备电路

Altera：nios II软核CPU，能跑到接近100兆32个通用寄存器，类似于arm7，性能也较为接近

xlinix：microblaze 软核cpu

arm cortex-A9 cortex-A53能够跑到900多兆，powerPC硬核，mc8051提供相应软核

片上嵌入双核arm A9，处理器和FPGA融合，异构计算

2013之前altera sopc 基于nios II 软核处理器

软核处理器-->没有硬核处理器的电路，使用FPGA通用逻辑阵列搭建起来的

硬核处理器-->电脑处理器，之类的

软核CPU的应用场景：网络传输，lcd显示界面，频谱分析仪，必须以FPGA为主，又需要一些显示

如果使用stm32以及FPGA比较难做，功耗难以降下来

soc片上系统

赛灵思叫zynq

使用qsys搭建一个nios II系统

stm32有两种数据总线，APB-->外设总线，AHB-->数据总线



## avalon总线

有两种

qsys遵循avalon总线规范

- 第一种是avalon mm（memory map）
- 第二种是avalon st（数据 ） 总线



