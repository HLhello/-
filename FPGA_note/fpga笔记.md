## 设计流程

1. 设计定义
2. 模块划分，接口定义
3. 设计输入（verilog vhdl，sv）
4. 分析和综合（quartus，vivado，ise）
5. 功能仿真（modelsim）
6. IO分配，布局布线
7. 时序仿真
8. 配置文件的生成，配置（烧写）fpga
9. 在线调试（嵌入式逻辑分析仪）

## 学习要点

基本逻辑

接口逻辑：uart can spi lvds

状态机，线性序列机（计数器，按时间分片）

IP的使用，第三方厂家，包括计数器，io接口，fft，各种软核CPU

接口设计

时序分析，时序约束

## wire与reg的区别

wire

- wire型数据通常用来表示用以assign关键字指定的组合逻辑信号
- verilog程序模块中输入输出信号类型默认时自动定义为wire型
- wire型信号可以用作任何方程式的输入，也可以用作assign语句或实例原件的输出

reg

- reg型数据常用来表示always模块内的指定信号，常代表触发器
- 在时序逻辑always模块内被赋值的每一个信号都必须被定义为reg型
- reg型数据的默认初始值是不定值

触发器和锁存器的区别

- 锁存器靠控制信号的电平实现数据的保存
- 触发器靠控制信号的边沿变化实现数据的保存

## cpld与fpga的异同

- fpga是在cpld之后发展出的一种更复杂的pld
- fpga集成了更多且更复杂的资源，包括可配置的逻辑块，时钟资源，时钟管理模块，块存储资源，互联资源，专用dsp模块，输入/输出块，XADC模块等，在一些高性能的fpga内还提供了吉比特收发器和PCI-E模块等硬核资源
- cpld使用与或阵列，fpga使用查找表结构，这是fpga最基本的原理

## 查找表LUT（look-up table）原理

- 由布尔逻辑代数理论可知，对于一个n输入的逻辑运算，最多产生2的n次方个不同的组合，如果预先将每个逻辑输入对应的结果保存在一个存储单元中，就相当于实现了逻辑门电路的功能
- fpga内的组合逻辑电路均由查找表实现
- LUT实现组合逻辑电路的功能由输入决定，而不是由复杂度决定
- LUT实现组合逻辑有固定的传输延迟 

- 相较于传统的逻辑门电路，LUT实现组合逻辑电路的功能克服了以下缺点
  - 逻辑门电路的输入变量从输入经过逻辑门运算后送到逻辑输出变量，存在一定的延时，延迟大小与逻辑电路的复杂度相关，并且是不确定的，延迟时间的不确定，工作频率就不确定，工作频率与时序逻辑电路的工作速度密切相关，由于工作速度的不确定，从而影响到了整个电路的性能
  - 逻辑电路的复杂度与输入逻辑变量的个数和逻辑电路所使用的逻辑门的数量有关，很明显，逻辑电路输入变量越多，电路越复杂

## 约束文件

- xlinix vivado集成开发环境使用xlinix 设计约束（xlinix design constraints，XDC）
- XDC是基于标准的synopsys设计约束（synopsys design constraints，SDC）的
- XDC文件特点
  - 不是简单的字符串，遵循tcl语法命令
  - 通过vivado tcl 翻译器就可以像理解tcl命令那样理解他们
  - 可以读取tcl指令，然后按照顺序对命令进行分析
- 如何添加XDC
  - 在设计的不同阶段均可添加XDC，将约束保存在一个或者多个XDC文件中
  - 通过read_xdc命令
  - 将他添加到其中一个设计工程的约束集中
- 通过TCL脚本生成的约束，可以通过下面的方法运行TCL脚本
  - 运行source命令
  - 将TCL叫脚本添加到其中一个设计工程约束集中

## 模块端口定义

- 三种模块端口定义，input， output， inout

- 我是这么理解的，首先在模块命后的括号内定义端口，然后声明端口
  - 声明端口时同时声明端口的数据类型，没有声明端口类型的情况下默认为线网类型，端口类型有线网（net）型和寄存器（reg）型
  - 有符号（signed）型数据，无符号型数据，没有声明端口有无符号时，默认为无符号型的端口

## verilog的描述方式

- 行为级描述是verilog hdl最高抽象级别的描述方式，可以按照要求来实现一个设计算法，而不用关心具体的实现方式，但是行为级描述是不可以被综合的，行为级描述语句可以描述逻辑行为，包括initial语句和always语句，用于对设计进行仿真，不能转化为实际的电路结构。

- 寄存器传输级（rtl）级描述，数据流描述，可以理解为在一个复杂的数字系统中，应该包含有数据流和控制流，控制流用于控制数据的流向，寄存器传输，任何数据从输入到输出，都需要经过寄存器来对数据重定序，这样，保证数据从输入到输出满足书序收敛的条件，不会出现竞争冒险与亚稳定状态。完成后将转化为实际的电路

## 系统任务和函数，编译器指令

- 以" $ "开始的标识符表示系统任务或者系统函数
- 以" ` "开始的的某些表示符看做编译器指令

## verilog 中数字的使用

- 不太理解：" 在任何时候，负数应该使用二进制补码形式表示 "，这是啥意思？

- ```<+/-><size><'base_format><number>```
- 第一的尖括号里为正负，可正可负也可以不写，不写默认为正数或者无符号数
- 第二个尖括号为位宽，在使用数字时必须带位宽，位宽包括有符号数的符号位
  - 未指定位宽，默认位宽至少32位
  - size位宽小于number位宽，将高位截断，保留低位
  - size位宽大于number位宽，根据正负（符号位）补全，正数补0，负数补1；无符号数补0；number最高位为x/z则同样补x/z
- 第三个尖括号为数的格式，base_format = {b, o, d, h, sb, so, sd, sh}，s代表为有符号数，
  - 可有与第一个尖括号中的正负搭配使用，完全的定义，不会产生歧义
  - 也可以只有第一个尖括号中的正负不写s，有点问题哎，尽量避免这样的定义
  - 也可以没有第一个尖括号的正负值有后面的s，当然是默认为正的有符号数
- 第四个尖括号中可以出现的数字为 number = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, x, z, ?}(不区分大小写)以及作为连接符的下划线"_",
  - x不确定态，z高阻态，？作用同z
  - x,z,?，根据base_format的定义，所代表的位宽可以为1,2,4，当然十进制的话我也不知啦，不要那么用，没有意义

## 属性attribute（参见数字设计权威指南何宾）

- 知道但不会用，感觉是指定一些特定的东西，在综合是加进去，比如之前用过的探针属性，属性有自己的名字，以及自己对应的值

## testbench文件中的时间定义

```1 s = 1,000 ms = 1,000,000 μs = 1,000,000,000 ns = 1,000,000,000,000 ps```

皮秒，符号ps（英语：picosecond ），1皮秒等于一万亿分之一秒（```10^(-12)s```）

``` 1,000 ps= 1ns```

```1,000,000 ps = 1μs ```

```1,000,000,000 ps = 1ms```

```1,000,000,000,000 ps = 1s```

纳秒，符号ns（英语：nanosecond ），1纳秒等于十亿分之一秒（```10^(-9)s```）

```1 ns= 1000ps```

```1,000 ns= 1μs ```

```1,000,000ns = 1ms```

```1,000,000,000 ns= 1s```

微秒，符号μs（英语：microsecond ），1微秒等于一百万分之一秒（```10^(-6)s```）

```0.000 001 μs= 1ps```

```0.001 μs= 1ns```

```1,000 μs= 1ms```

```1,000,000 μs= 1s```
毫秒，符号ms（英语：millisecond ），1毫秒等于一千分之一秒（10-3秒）

```0.000 000 001 ms= 1ps``` 

```0.000 001 ms= 1ns ```

```0.001 ms = 1μs ```

```1000 ms = 1s```

```verilog
`timescale 1ns/1ps //单位/精度
#100 //延时100ns
//-------------------------
`timescale 10ns/1ps
#100//延时100*10ns
#0.1//0.1ns = 1ps，仿真精确到小数点后一位
```

## 状态机

一段式状态机，两段式状态机，三段式状态机

同步状态机的原理结构和设计

1. 下一状态 = F（当前状态，输入信号）
2. 输出信号 = G（当前状态，输入信号）mealy状态机

- mealy状态机：时序逻辑的输出不但取决于状态还取决于输入，大部分都是mealy状态机
- moore状态机：时序逻辑电路的输出只取决于当前状态

## pll

phase-locked loop

相位锁定的环路，也就是常说的锁相环，锁相环在模拟电路和数字电路系统中均有广泛的应用，很多mcu芯片如stm32，msp430，等都集成了片上的pll，用来通过片外较低频率的晶振产生的时钟倍频得到较高频率的时钟信号以供mcu内核和片上的外设使用，在很多的洗衣芯片中也用到得了pll来通过较低的晶振时钟得到符合协议要求的时钟信号，例如典型的usb协议芯片

## 参数传递

`` `define 与localparam和parameter最大的区别就是`define 可以跨文件传递参数；parameter只能在模块间传递参数；而localparam只能在其所在的module中起作用，不能参与参数传递。

  1. 新建参数模块文件（我命名为para.v）；

  2. 在para.v文件中使用'define宏定义参数（部分）

     ```verilog 
     //`define+name+参数 　
     `define 　　STATE_INIT	3'd0
     `define 　　STATE_IDLE	3'd1
     `define 　　STATE_WRIT	3'd2
     `define 　　STATE_READ	3'd3
     `define 　　STATE_WORK	3'd4
     `define 　　STATE_RETU	3'd5
     ```

  3. 在需要调用参数的文件init.v中使用`include "para.v"：

     ````include "para.v"```

4. 在init.v文件需要参数的地方使用`name 调用（部分）：`

    ````state_init <= `STATE_INIT;```

## FPGA的资源

可编程逻辑功能块——类比电路板的各种元器件

可编程I/O口——类比电路板的输入输出

可编程内部互联资源——元器件之间的通信总线

## 电源设计

- cyclone IV E 需要三组供电
  - 内核供电   1.0V；非低电压版本为1.2V
  - pll模拟电路供电，数字电路供电1.2V，模拟电路供电固定的2.5V，使用LDO器件 
  - I/O单元供电，电压值从1.2V~3.3V（1.2；1.5；1.8；2.5；3.0；3.3），共6中可选值，IO Bank 每个bank的IO供电都可以不同

## 配置电路设计

- cyclone IV E 基于SRAM的结构的，SRAM掉电就会丢失，因此系统上电后，必须要有配置电路将正确的配置数据加载到SRAM中，然后FPGA才能正常运行
- 五种配置方式（AS，AP，PS，FPP，JTAG）
  - AS 主动串行方式，电路简单，成本低廉，常用语中小容量的FPGA
  - AP主动并行方式，消耗引脚比较多，常用于配置过程的时间要求较高
  - PS被动串行方式，使用一个外部的主机MCU或者CPLD，常用于通过网络方式对fpga的升级
  - JTAG配置方式，可以在器件正常工作过程中捕获运行数据，JTAG指令具有最高优先级
- 对FPGA进行配置
  - FPGA中没有flash，FPGA基于sram架构，掉电程序丢失，FPGA程序存储在外部的flash中，叫做epcs， 实际上是就是spf flash芯片（stm32 片上程序一般存储在flash中）
  - 使用jtag直接配置 .sof，FPGA 掉电，就会变成白片
  - 使用外部器件进行片配置，flash不会丢失，FPGA上电时主动加载程序
  - 使用外部的控制器进行配置

## 时序逻辑电路与组合逻辑电路的区别？

- 时序电路输出状态不仅取决于当前输入，也取决与当前的电路状态
- 组合逻辑电路输出只取决于当前输入

## 硬件乘法单元

- 18*18硬件乘法器，乘数和被乘数输入宽度最大为18位的乘法器
- 乘法器电路复杂，使用fpga内部资源能实现，但是性能会受限，也消耗更多的面积，不利于降低成本和功耗
- 硬件乘法单元在芯片设计时功能和布局都已经确定，即使不使用，他也在
- 每个硬件乘法电路也能拆分成两个位宽为9的存储器 

## 编码方式的区别

对于状态机

- 独热码，每一个状态均使用一个寄存器， 在于状态比较时仅仅需要比较一位， 相比其他译码电路简单；

- 格雷码，所需寄存器数与二进制码一样，译码复杂，但相邻位只跳动一位，一般用于异步多时钟域多 bit 位的转换，如异步 FIFO；

- 二进制码，最为常见的编码方式，所用寄存器少，译码较复杂。 

对于计算

- BCD 码中最常用的是 8421 码，其各个 bit 权值分别是 8d、 4d、 2d、 1d
- 同理 5421 码各位的权依次为 5d、 4d、 2d、 1d。 5421 码特点是最高位连续 5 个 0 后连续 5 个 1，故其当计数器采用这种编码时，最高位可产生对称方波输出
- 余 3 码是在 8421 码上加 0011b 的出来的；
- 格雷码的特点是任意两个相邻的代码只有一位二进制数不同，编码格式不唯一；
- 余 3 循环码具有格雷码的特点并且编码的首尾可以连接来进行循环，这样可用反馈移位寄存器来实现，硬件实现简单。 

- BCD码利于十进制的计算

  BCD 码的运算规则： BCD 码是十进制数，而运算器对数据做加减运算时，都是按二进制运算规则进行处理的。这样，当将 BCD 码传送给运算器进行运算时，其结果需要修正。修正的规则是：当两个 BCD 码相加，如果和等于或小于 1001b(即十进制数 9)，不需要修正；如果相加之和在 1010b 到 1111b(即十六进制数 0AH～0FH)之间，则需加 6d 也就是 0110 进行修正；如果相加时，本位产生了进位，也需加 6 进行修正。下面举例说明：计算 5+8，将 5和 8 转换为 8421 BCD 码后输入加法器，则运算如下： 0101 + 1000 = 1101 结果大于 9d，+0110b 即加 6d 修正得出 10011b，补充高位为 0001_0011b。 即 5+8=13，结论正确。

  BCD 码的主要应用之一就是数码管，假设要将十进制数 158 显示， 一般解决办法是把需要显示的十进制数的个、十、百、千位数等进行拆分，即把 158 拆分出 1、 5、 8，然后查出对应的数码管显示段码再送去给数码管连接的 IO 口。这个过程可以进行下面的运算：先进行除法运算 158/100 得出百位 1，再取余 158%100 = 58 后继续进行除法运算 58 / 10 得出十位 5，再进行一次取余 158%10 ，得到个位 8。以上过程可以看出需要除法，但是由于除法运算是比较消耗计算时间导致整体需要的指令周期太久。但是如果先将其转换为 BCD 码，则可大幅度减少运算时间。 具体应用将在数码管一讲中详细介绍。 

## 三种状态机写法的区别

状态机描述方式，可分为一段式、两段式以及三段式。

- 一段式，整个状态机写到一个 always 模块里面。 在该模块中既描述状态转移，又描述状态的输入和输出。
- 两段式，用两个 always 模块来描述状态机。 其中一个 always 模块采用同步时序描述状态转移， 另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律及其输出。 
- 三段式，在两个 always 模块描述方法基础上，使用三个 always 模块。 一个 always 模块采用同步时序描述状态转移，一个 always 采用组合逻辑判断状态转移条件，描述状态转移规律，另一个 always 模块描述状态输出(可以用组合电路输出，也可以时序电路输出)。 

三种状态机的问题

- 可以看出两段式有限状态机与一段式有限状态机的区别是将时序部分（状态转移）和组合部分（判断状态转移条件和产生输出）分开，写为两个 always 语句，即为两段式有限状态机。将组合部分中的判断状态转移条件和产生输出再分开写，则为三段式有限状态机。
- 二段式在组合逻辑特别复杂时，注意需在后面加一个触发器以消除组合逻辑对输出产生的毛刺的影响。三段式则没有这个问题， 这是由于第三个 always 会生成触发器。其实现在的器件根本不在乎这一点资源消耗，推荐使用二段式或者三段式以及输出寄存的状态机输出来描述有限状态机。
- 编写状态机还应主要注意的事项是，为了避免不必要的锁存器生成，需要穷举所有状态对应的输出动作，或者使用 default 来定义未定义状态动作；
- 在定义状态时， 推荐使用本地化参数定义 localparam，这样可以在编写时状态更清晰且不容易出错，也方便修改；在复位或者跑飞能回到初始态或者预定态；要有异步或者同步复位来确保状态机上电有个初始态。 

## IIC接口概述

## 时序分析系列问题

已经单开文件进行总结

## localparam与parameter的区别与用法

parameter可用作在顶层模块中例化底层模块时传递参数的接口；

localparam的作用域仅仅限于当前module，不能作为参数传递的接口。

```verilog
//用法
parameter       DATA_WIDTH = 16;
parameter       ADDR_WIDTH =  5;
localparam      DW = DATA_WIDTH - 1;
localparam      AW = ADDR_WIDTH - 1;

```

## AXI

- AXI（Advanced eXtensible Interface）是一种总线协议，该协议是ARM公司提出的AMBA（Advanced Microcontroller Bus Architecture）3.0协议中最重要的部分，
- AXI 是一种面向高性能、高带宽、低延迟的片内总线。它的地址/控制和数据相位是分离的，支持不对齐的数据传输，同时在突发传输中，只需要首地址，同时分离的读写数据通道、并支持Outstanding传输访问和乱序访问，并更加容易进行时序收敛。
- AXI 是AMBA 中一个新的高性能协议。AXI 技术丰富了现有的AMBA 标准内容，满足超高性能和复杂的片上（SoC）设计的需求。

## 时钟管理单元（PLL，DLL）

- 锁相环 PLL

  ​	PLL （phase locked loop，锁相环），模拟电路

  ​	pll与dll的区别：pll是数字的，dll是模拟的，pll精度较高

  ​	特性：能够将输入的周期信号就行分频和倍频，并最终输出一个或多个稳定的，与输入信号频率和相位相关的信号

  ​	总结：能够通过对输入的时钟信号进行分频，倍频，相位控制，从而得到一路或者多路更高或者更低的时钟信号

## qsys？nios II？sopc？

qsys是一个工具，这个工具是用来帮助搭建系统的

nios II是一款cpu，是一个处理器

sopc是一种技术，可编程偏上系统，是一种解决方案

## sopc

sopc：使用FPGA通用逻辑搭建CPU和外围设备电路

Altera：nios II软核CPU，能跑到接近100兆32个通用寄存器，类似于arm7，性能也较为接近

xlinix：microblaze 软核cpu

arm cortex-A9 cortex-A53能够跑到900多兆，powerPC硬核，mc8051提供相应软核

片上嵌入双核arm A9，处理器和FPGA融合，异构计算

2013之前altera sopc 基于nios II 软核处理器

软核处理器-->没有硬核处理器的电路，使用FPGA通用逻辑阵列搭建起来的

硬核处理器-->电脑处理器，之类的

软核CPU的应用场景：网络传输，lcd显示界面，频谱分析仪，必须以FPGA为主，又需要一些显示

如果使用stm32以及FPGA比较难做，功耗难以降下来

soc片上系统

赛灵思叫zynq

使用qsys搭建一个nios II系统

stm32有两种数据总线，APB-->外设总线，AHB-->数据总线



## avalon总线

有两种

qsys遵循avalon总线规范

- 第一种是avalon mm（memory map）
- 第二种是avalon st（数据 ） 总线

## 常见协议的缩写与全称

通用异步收发传协议（UART）

集成电路总线协议（IIC）（I方c）

串行外围总线协议（SPI）

通用串行总线协议（USB 2.0/3.0）

以太网协议（Ethernet）

## normal synchronous FIFO mode 与 show-ahead synchronous FIFO mode区别

- 选则第一种普通方式则 rdreq 信号作为实际意义上的读请求信号，当该信号有效时 FIFO 中的控制逻辑从存储器中读取一个数据输出到 q 端。 
- 如果选中 Show-ahead 方式，则 rdreq 实际作为了读应答信号，即 rdreq 还没有有效时， q 端口上已经输出了一个有效的数据， rdreq 信号有效的时候则相当于通知 FIFO 内部的控制逻辑 q 端口上的数据已经被读取，则 FIFO 内部的逻辑会从 RAM 中再取出一个新的数据，在下一个时钟周期输出到 q 端口上。该模式在实际中应用也非常的普遍，因为 q 端口上的数据 与 rdreq 同时有效，没有读潜伏期。 

## verilog中readmemb与readmemh的使用

1. 在verilog中有$readmemh(“filename”, mem_name)命令，在使用这个命令时，”filename”中的路径要用反斜杠’/’，而不是斜杠’\’。如

   - $readmemh("F:/mydesigen/re_input.txt",re_input);

   - 上面的语句是正确的，而如果用斜杠就有问题，如

   - $readmemh("F:\mydesigen\re_input.txt",re_input);

2. readmemb（“D：/file1/file2/ramh.dat”，a）；即可以调用到放置在任意处的存储文件。当采用$readmemb（“ramh.dat”，a）；这种方式时，ramh.dat文件必须放置在工程下的simulation文件夹下，亲测其他放置都无效。

3. 关于存储文件后缀，.dat .txt 甚至不加后缀都可以，只要保证程序里调用的与文件夹中实际的一致，可以索引到即可

4. 对于需要的txt文件，其格式为每行一个数据，存储顺序。文档中由上至下，对应数组由低到高。

   - 例如用matlab产生文件则可以这样写

     ```fid0 = fopen('F:\path\re_input.txt','w+');```

     ```fprintf(fid0,'%x \n',real(info));```

     其中的换行符是必须的。同时，在matlab中，路径语句的斜杠’\’或是反斜杠’/’都没有问题。

5. 不可综合。readmemb、readmemh、initial 都是不可综合语句（怎么可以这样呢！那大数组怎么赋值？）也就是说只能在仿真时调试用。

6. 对于$readmemh对应的16进制文件，不用写成4'hA，最简单的A即可。



## 名词解释

SPI --SPI是串行外设接口（Serial Peripheral Interface） 

SDIO --（Secure Digital Input and Output）安全数字输入输出卡定义了一种外设接口 

UART --通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART。 

USB --USB，是英文Universal Serial Bus（通用串行总线）的缩写，是一个外部总线标准，用于规范电脑与外部 设备的连接和通讯。 

IIC --I²C（Inter-Integrated Circuit）字面上的意思是集成电路之间，它其实是I²C Bus简称，所以中文应该叫集成电 路总线，它是一种串行通信总线，使用多主从架构。 

PWM --脉冲宽度调制（Pulse width modulation，PWM）技术。 

IIS --IIS 总线IIS(Integrate Interface of Sound)即集成音频接口。 

GPIO --GPIO（英语：General-purpose input/output），通用型之输入输出的简称。

RS232：逻辑“1”为-3到-15V;逻辑“0”为+3到+15V只需要三条接口线，即“发送数据TXD”、“接收数据 RXD”和“信号地GND”。

RS485:逻辑“1”以两线间的电压差为-(2~6)V表示;逻辑“0”以两线间的电压差为+(2~6)V表示。

TTL接口+5V等价于逻辑“1”，0V等价于逻辑“0”，这被称做TTL(晶体管-晶体管逻辑电平TransistorTransistor Logic)。

RS232 RS485是数据的传输方式；232是直接高低电平的传输方式；485是使用差分的传输方式，2种传输方式的不 同体现在电平的标准上。



## IIC接口

IIC串行总线我认为还是比较简单的，在今天的一个面试中，让我介绍了IIC，最后问我问题时，IIC是在什么时候把数据打入从机？

我当时的回答是：上升沿？这是错误的。是在高电平时期。

为了更加深入了解IIC，因此我又学习了一下。


总线信号 ： SDA ：串行数据线　SCL  ：串行时钟

总线空闲状态 ：SDA ：高电平　SCL ：高电平

起始位：SCL为高电平期间    SDA出现下降沿

![起始信号](E:\LearningNotes\FPGA_note\IIC起始信号.jpg)

起始信号

终止位：SCL为高电平期间 SDA出现上升沿

![终止信号](E:\LearningNotes\FPGA_note\IIC终止信号.jpg)

终止信号

数据传输 ：SDA的数据在SCL高电平期间被写入从机。所以SDA的数据变化要发生在SCL低电平期间。

![数据传输时期](E:\LearningNotes\FPGA_note\IIC数据传输时期.jpg)

数据传输时期

IIC时钟频率：不高于400K

应答：当IIC主机（不一定是发送端还是接受端）将8位数据或命令传出后，会将SDA信号设置为输入，等待从机应答（等待SDA由高电平拉为低电平）。若从机正确应答，表明数据或者命令传输成功，否则传输失败，注意，应答信号是数据接收方发送给数据发送方的。

IIC器件地址：每一个IIC器件都有一个器件地址，有的器件地址在出厂时地址就设定好了，用户不可以更改,比如OV7670的地址为0x42。有的器件例如EEPROM，前四个地址已经确定为1010，后三个地址是由硬件链接确定的，所以一个IIC总线最多能连8个EEPROM芯片。

![例子](E:\LearningNotes\FPGA_note\IIC单字节写时序.jpg)

例子

图上开始信号之后，七位地址代表器件地址，第八位代表读或者写，0为写，1代表读，然后跟着响应位。

IIC器件单字节写时序：

![单字节写时序](E:\LearningNotes\FPGA_note\IIC单字节器件写时序.jpg)

单字节写时序

IIC器件多字节地址写时序：多字节地址比单字节地址在时序上就多了一块写地址

![多字节地址写时序](E:\LearningNotes\FPGA_note\IIC多字节地址写时序.jpg)

多字节地址写时序

单字节器件读时序：注意最后产生无应答信号，另外多字节地址读时序跟单字节类似，只不过是多了几个地址字节而已。

![单字节器件读时序](E:\LearningNotes\FPGA_note\IIC单字节器件读时序.jpg)

单字节器件读时序

三大串行总线：uart、spi、iic

同步：spi　　异步：iic，uart

同步和异步区别：采集数据是否用的是时钟的沿，如果是时钟沿采数据，同步传输，如果电平采集数据是异步。串口接受数据其实就是一个串转并的过程。



## IIC接口与spi接口比较

作者：树懒说物联

链接：https://zhuanlan.zhihu.com/p/63879154

来源：知乎

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

**IIC vs SPI**
现今，在低端数字通信应用领域，我们随处可见IIC (Inter-Integrated Circuit) 和 SPI (Serial Peripheral Interface)的身影。原因是这两种通信协议非常适合近距离低速芯片间通信。Philips（for IIC）和Motorola（for SPI） 出于不同背景和市场需求制定了这两种标准通信协议。

IIC 开发于1982年，当时是为了给电视机内的CPU和外围芯片提供更简易的互联方式。电视机是最早的嵌入式系统之一，而最初的嵌入系统是使用内存映射（memory-mapped I/O）的方式来互联微控制器和外围设备的。要实现内存映射，设备必须并联入微控制器的数据线和地址线，这种方式在连接多个外设时需大量线路和额外地址解码芯片，很不方便并且成本高。

为了节省微控制器的引脚和和额外的逻辑芯片，使印刷电路板更简单，成本更低，位于荷兰的Philips实验室开发了 ‘Inter-Integrated Circuit’，IIC 或 IIC ，一种只使用二根线接连所有外围芯片的总线协议。最初的标准定义总线速度为100kbps。经历几次修订，主要是1995年的400kbps，1998的3.4Mbps。

SPI总线首次推出是在1979年，Motorola公司将SPI总线集成在他们第一支改自68000微处理器的微控制器芯片上。SPI总线是微控制器四线的外部总线（相对于内部总线）。与IIC不同，SPI没有明文标准，只是一种事实标准，对通信操作的实现只作一般的抽象描述，芯片厂商与驱动开发者通过data sheets和application notes沟通实现上的细节。

**SPI**





对于有经验的数字电子工程师来说，用SPI互联两支数字设备是相当直观的。SPI是种四根信号线协议（如图）：





![img](E:\LearningNotes\FPGA_note\spi接口示意图.jpg)





- SCLK: Serial Clock (output from master);
- MOSI; SIMO: Master Output, Slave Input(output from master);
- MISO; SOMI: Master Input, Slave Output(output from slave);
- SS: Slave Select (active low, outputfrom master).


SPI是［单主设备（ single-master ）］通信协议，这意味着总线中的只有一支中心设备能发起通信。当SPI主设备想读/写［从设备］时，它首先拉低［从设备］对应的SS线（SS是低电平有效），接着开始发送工作脉冲到时钟线上，在相应的脉冲时间上，［主设备］把信号发到MOSI实现“写”，同时可对MISO采样而实现“读”，如下图：



![img](E:\LearningNotes\FPGA_note\spi时序图.jpg)




SPI有四种操作模式——模式0、模式1、模式2和模式3，它们的区别是定义了在时钟脉冲的哪条边沿转换（toggles）输出信号，哪条边沿采样输入信号，还有时钟脉冲的稳定电平值（就是时钟信号无效时是高还是低）。每种模式由一对参数刻画，它们称为时钟极（clock polarity）CPOL与时钟期（clock phase）CPHA。





![img](E:\LearningNotes\FPGA_note\spi工作模式.jpg)



［主从设备］必须使用相同的工作参数——SCLK、CPOL 和 CPHA，才能正常工作。如果有多个［从设备］，并且它们使用了不同的工作参数，那么［主设备］必须在读写不同［从设备］间重新配置这些参数。以上SPI总线协议的主要内容。SPI不规定最大传输速率，没有地址方案；SPI也没规定通信应答机制，没有规定流控制规则。事实上，SPI［主设备］甚至并不知道指定的［从设备］是否存在。这些通信控制都得通过SPI协议以外自行实现。例如，要用SPI连接一支［命令-响应控制型］解码芯片，则必须在SPI的基础上实现更高级的通信协议。SPI并不关心物理接口的电气特性，例如信号的标准电压。在最初，大多数SPI应用都是使用间断性时钟脉冲和以字节为单位传输数据的，但现在有很多变种实现了连续性时间脉冲和任意长度的数据帧。

**IIC**

与SPI的单主设备不同，IIC 是多主设备的总线，IIC没有物理的芯片选择信号线，没有仲裁逻辑电路，只使用两条信号线—— ‘serial data’ (SDA) 和 ‘serial clock’ (SCL)。IIC协议规定：

- 第一，每一支IIC设备都有一个唯一的七位设备地址；
- 第二，数据帧大小为8位的字节；
- 第三，数据（帧）中的某些数据位用于控制通信的开始、停止、方向（读写）和应答机制。


IIC 数据传输速率有标准模式（100 kbps）、快速模式（400 kbps）和高速模式（3.4 Mbps），另外一些变种实现了低速模式（10 kbps）和快速+模式（1 Mbps）。

物理实现上，IIC 总线由两根信号线和一根地线组成。两根信号线都是双向传输的，参考下图。IIC协议标准规定发起通信的设备称为主设备，主设备发起一次通信后，其它设备均为从设备。



![img](E:\LearningNotes\FPGA_note\IIC电路示意图.jpg)



IIC 通信过程大概如下。首先，主设备发一个START信号，这个信号就像对所有其它设备喊：请大家注意！然后其它设备开始监听总线以准备接收数据。接着，主设备发送一个7位设备地址加一位的读写操作的数据帧。当所设备接收数据后，比对地址自己是否目标设备。如果比对不符，设备进入等待状态，等待STOP信号的来临；如果比对相符，设备会发送一个应答信号——ACKNOWLEDGE作回应。

当主设备收到应答后便开始传送或接收数据。数据帧大小为8位，尾随一位的应答信号。主设备发送数据，从设备应答；相反主设备接数据，主设备应答。当数据传送完毕，主设备发送一个STOP信号，向其它设备宣告释放总线，其它设备回到初始状态。



![img](E:\LearningNotes\FPGA_note\IIC数据位划分.jpg)



基于IIC总线的物理结构，总线上的START和STOP信号必定是唯一的。另外，IIC总线标准规定SDA线的数据转换必须在SCL线的低电平期，在SCL线的高电平期，SDA线的上数据是稳定的。



![img](E:\LearningNotes\FPGA_note\IIC时序图.jpg)



在物理实现上，SCL线和SDA线都是漏极开路（open-drain），通过上拉电阻外加一个电压源。当把线路接地时，线路为逻辑0，当释放线路，线路空闲时，线路为逻辑1。基于这些特性，IIC设备对总线的操作仅有“把线路接地”——输出逻辑0。

IIC总线设计只使用了两条线，但相当优雅地实现任意数目设备间无缝通信，堪称完美。我们设想一下，如果有两支设备同时向SCL线和SDA线发送信息会出现什么情况。

基于IIC总线的设计，线路上不可能出现电平冲突现象。如果一支设备发送逻辑0，其它发送逻辑1，那么线路看到的只有逻辑0。也就是说，如果出现电平冲突，发送逻辑0的始终是“赢家”。

总线的物理结构亦允许主设备在往总线写数据的同时读取数据。这样，任何设备都可以检测冲突的发生。当两支主设备竞争总线的时候，“赢家”并不知道竞争的发生，只有“输家”发现了冲突——当它写一个逻辑1，却读到0时——而退出竞争。

**10位设备地址**

任何IIC设备都有一个7位地址，理论上，现实中只能有127种不同的IIC设备。实际上，已有IIC的设备种类远远多于这个限制，在一条总线上出现相同的地址的IIC设备的概率相当高。为了突破这个限制，很多设备使用了双重地址——7位地址加引脚地址（external configuration pins）。IIC 标准也预知了这种限制，提出10位的地址方案。

**10位的地址方案对 IIC协议的影响有两点：**

- 第一，地址帧为两个字节长，原来的是一个字节；
- 第二，第一个字节前五位最高有效位用作10位地址标识，约定是“11110”。





![img](E:\LearningNotes\FPGA_note\IIC地址帧.jpg)



除了10位地址标识，标准还预留了一些地址码用作其它用途，如下表：



![img](E:\LearningNotes\FPGA_note\IIC扩展地址帧的其他作用.jpg)



**时钟拉伸**
在 IIC 通信中，主设备决定了时钟速度。因为时钟脉冲信号是由主设备显式发出的。但是，当从设备没办法跟上主设备的速度时，从设备需要一种机制来请求主设备慢一点。这种机制称为时钟拉伸，而基于I²C结构的特殊性，这种机制得到实现。当从设备需要降低传输的速度的时候，它可以按下时钟线，逼迫主设备进入等待状态，直到从设备释放时钟线，通信才继续。



**高速模式**
原理上讲，使用上拉电阻来设置逻辑1会限制总线的最大传输速度。而速度是限制总线应用的因素之一。这也说明为什么要引入高速模式（3.4 Mbps）。在发起一次高速模式传输前，主设备必须先在低速的模式下（例如快速模式）发出特定的“High Speed Master”信号。为缩短信号的周期和提高总线速度，高速模式必须使用额外的I/O缓冲区。另外，总线仲裁在高速模式下可屏蔽掉。更多的信息请参与总线标准文档。



**IIC vs SPI: 哪位是赢家？**

**我们来对比一下IIC 和 SPI的一些关键点：**
**第一，总线拓扑结构/信号路由/硬件资源耗费**
IIC 只需两根信号线，而标准SPI至少四根信号，如果有多个从设备，信号需要更多。一些SPI变种虽然只使用三根线——SCLK, SS和双向的MISO/MOSI，但SS线还是要和从设备一对一根。另外，如果SPI要实现多主设备结构，总线系统需额外的逻辑和线路。用IIC 构建系统总线唯一的问题是有限的7位地址空间，但这个问题新标准已经解决——使用10位地址。从第一点上看，IIC是明显的大赢家。

**第二，数据吞吐/传输速度**
如果应用中必须使用高速数据传输，那么SPI是必然的选择。因为SPI是全双工，IIC 的不是。SPI没有定义速度限制，一般的实现通常能达到甚至超过10 Mbps。IIC 最高的速度也就快速+模式（1 Mbps）和高速模式（3.4 Mbps），后面的模式还需要额外的I/O缓冲区，还并不是总是容易实现的。

**第三，优雅性**
IIC 常被称更优雅于SPI。公正的说，我们更倾向于认为两者同等优雅和健壮。IIC的优雅在于它的特色——用很轻盈的架构实现了多主设备仲裁和设备路由。但是对使用的工程师来讲，理解总线结构更费劲，而且总线的性能不高。

SPI的优点在于它的结构相当的直观简单，容易实现，并且有很好扩展性。SPI的简单性不足称其优雅，因为要用SPI搭建一个有用的通信平台，还需要在SPI之上构建特定的通信协议软件。也就是说要想获得SPI特有而IIC没有的特性——高速性能，工程师们需要付出更多的劳动。另外，这种自定的工作是完全自由的，这也说明为什么SPI没有官方标准。IIC和SPI都对低速设备通信提供了很好的支持，不过，SPI适合数据流应用，而IIC更适合“字节设备”的多主设备应用。

**小结**
在数字通信协议簇中，IIC和SPI常称为“小”协议，相对Ethernet, USB, SATA, PCI-Express等传输速度达数百上千兆字节每秒的总线。但是，我们不能忘记的是各种总线的用途是什么。“大”协议是用于系统外的整个系统之间通信的，“小”协议是用于系统内各芯片间的通信，没有迹象表明“大”协议有必要取代“小”协议。IIC和SPI的存在和流行体现了“够用就好”的哲学。回应文首，IIC和SPI如此的流行，它是任何一位嵌入式工程师必备的工具。