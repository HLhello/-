## 设计流程

1. 设计定义
2. 模块划分，接口定义
3. 设计输入（verilog vhdl，sv）
4. 分析和综合（quartus，vivado，ise）
5. 功能仿真（modelsim）
6. IO分配，布局布线
   7. 时序仿真
8. 配置文件的生成，配置（烧写）fpga
9. 在线调试（嵌入式逻辑分析仪）

## 学习要点

基本逻辑

接口逻辑：uart can spi lvds

状态机，线性序列机（计数器，按时间分片）

IP的使用，第三方厂家，包括计数器，io接口，fft，各种软核CPU

接口设计

时序分析，时序约束

## wire与reg的区别

wire

- wire型数据通常用来表示用以assign关键字指定的组合逻辑信号
- verilog程序模块中输入输出信号类型默认时自动定义为wire型
- wire型信号可以用作任何方程式的输入，也可以用作assign语句或实例原件的输出

reg

- reg型数据常用来表示always模块内的指定信号，常代表触发器
- 在时序逻辑always模块内被赋值的每一个信号都必须被定义为reg型
- reg型数据的默认初始值是不定值

触发器和锁存器的区别

- 锁存器靠控制信号的电平实现数据的保存
- 触发器靠控制信号的边沿变化实现数据的保存

## cpld与fpga的异同

- fpga是在cpld之后发展出的一种更复杂的pld
- fpga集成了更多且更复杂的资源，包括可配置的逻辑块，时钟资源，时钟管理模块，块存储资源，互联资源，专用dsp模块，输入/输出块，XADC模块等，在一些高性能的fpga内还提供了吉比特收发器和PCI-E模块等硬核资源
- cpld使用与或阵列，fpga使用查找表结构，这是fpga最基本的原理

## 查找表LUT（look-up table）原理

- 由布尔逻辑代数理论可知，对于一个n输入的逻辑运算，最多产生2的n次方个不同的组合，如果预先将每个逻辑输入对应的结果保存在一个存储单元中，就相当于实现了逻辑门电路的功能
- fpga内的组合逻辑电路均由查找表实现
- LUT实现组合逻辑电路的功能由输入决定，而不是由复杂度决定
- LUT实现组合逻辑有固定的传输延迟 

- 相较于传统的逻辑门电路，LUT实现组合逻辑电路的功能克服了以下缺点
  - 逻辑门电路的输入变量从输入经过逻辑门运算后送到逻辑输出变量，存在一定的延时，延迟大小与逻辑电路的复杂度相关，并且是不确定的，延迟时间的不确定，工作频率就不确定，工作频率与时序逻辑电路的工作速度密切相关，由于工作速度的不确定，从而影响到了整个电路的性能
  - 逻辑电路的复杂度与输入逻辑变量的个数和逻辑电路所使用的逻辑门的数量有关，很明显，逻辑电路输入变量越多，电路越复杂

## 约束文件

- xlinix vivado集成开发环境使用xlinix 设计约束（xlinix design constraints，XDC）
- XDC是基于标准的synopsys设计约束（synopsys design constraints，SDC）的
- XDC文件特点
  - 不是简单的字符串，遵循tcl语法命令
  - 通过vivado tcl 翻译器就可以像理解tcl命令那样理解他们
  - 可以读取tcl指令，然后按照顺序对命令进行分析
- 如何添加XDC
  - 在设计的不同阶段均可添加XDC，将约束保存在一个或者多个XDC文件中
  - 通过read_xdc命令
  - 将他添加到其中一个设计工程的约束集中
- 通过TCL脚本生成的约束，可以通过下面的方法运行TCL脚本
  - 运行source命令
  - 将TCL叫脚本添加到其中一个设计工程约束集中

## 模块端口定义

- 三种模块端口定义，input， output， inout

- 我是这么理解的，首先在模块命后的括号内定义端口，然后声明端口
  - 声明端口时同时声明端口的数据类型，没有声明端口类型的情况下默认为线网类型，端口类型有线网（net）型和寄存器（reg）型
  - 有符号（signed）型数据，无符号型数据，没有声明端口有无符号时，默认为无符号型的端口

## verilog的描述方式

- 行为级描述是verilog hdl最高抽象级别的描述方式，可以按照要求来实现一个设计算法，而不用关心具体的实现方式，但是行为级描述是不可以被综合的，行为级描述语句可以描述逻辑行为，包括initial语句和always语句，用于对设计进行仿真，不能转化为实际的电路结构。

- 寄存器传输级（rtl）级描述，数据流描述，可以理解为在一个复杂的数字系统中，应该包含有数据流和控制流，控制流用于控制数据的流向，寄存器传输，任何数据从输入到输出，都需要经过寄存器来对数据重定序，这样，保证数据从输入到输出满足书序收敛的条件，不会出现竞争冒险与亚稳定状态。完成后将转化为实际的电路

## 系统任务和函数，编译器指令

- 以" $ "开始的标识符表示系统任务或者系统函数
- 以" ` "开始的的某些表示符看做编译器指令

## verilog 中数字的使用

- 不太理解：" 在任何时候，负数应该使用二进制补码形式表示 "，这是啥意思？

- ```<+/-><size><'base_format><number>```
- 第一的尖括号里为正负，可正可负也可以不写，不写默认为正数或者无符号数
- 第二个尖括号为位宽，在使用数字时必须带位宽，位宽包括有符号数的符号位
  - 未指定位宽，默认位宽至少32位
  - size位宽小于number位宽，将高位截断，保留低位
  - size位宽大于number位宽，根据正负（符号位）补全，正数补0，负数补1；无符号数补0；number最高位为x/z则同样补x/z
- 第三个尖括号为数的格式，base_format = {b, o, d, h, sb, so, sd, sh}，s代表为有符号数，
  - 可有与第一个尖括号中的正负搭配使用，完全的定义，不会产生歧义
  - 也可以只有第一个尖括号中的正负不写s，有点问题哎，尽量避免这样的定义
  - 也可以没有第一个尖括号的正负值有后面的s，当然是默认为正的有符号数
- 第四个尖括号中可以出现的数字为 number = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, x, z, ?}(不区分大小写)以及作为连接符的下划线"_",
  - x不确定态，z高阻态，？作用同z
  - x,z,?，根据base_format的定义，所代表的位宽可以为1,2,4，当然十进制的话我也不知啦，不要那么用，没有意义

## 属性attribute

- 参见数字设计权威指南何宾

- 知道但不会用，感觉是指定一些特定的东西，在综合是加进去，比如之前用过的探针属性，属性有自己的名字，以及自己对应的值

## testbench文件中的时间定义

```1 s = 1,000 ms = 1,000,000 μs = 1,000,000,000 ns = 1,000,000,000,000 ps```

皮秒，符号ps（英语：picosecond ），1皮秒等于一万亿分之一秒（```10^(-12)s```）

``` 1,000 ps= 1ns```

```1,000,000 ps = 1μs ```

```1,000,000,000 ps = 1ms```

```1,000,000,000,000 ps = 1s```

纳秒，符号ns（英语：nanosecond ），1纳秒等于十亿分之一秒（```10^(-9)s```）

```1 ns= 1000ps```

```1,000 ns= 1μs ```

```1,000,000ns = 1ms```

```1,000,000,000 ns= 1s```

微秒，符号μs（英语：microsecond ），1微秒等于一百万分之一秒（```10^(-6)s```）

```0.000 001 μs= 1ps```

```0.001 μs= 1ns```

```1,000 μs= 1ms```

```1,000,000 μs= 1s```
毫秒，符号ms（英语：millisecond ），1毫秒等于一千分之一秒（10-3秒）

```0.000 000 001 ms= 1ps``` 

```0.000 001 ms= 1ns ```

```0.001 ms = 1μs ```

```1000 ms = 1s```

```verilog
`timescale 1ns/1ps //单位/精度
#100 //延时100ns
//-------------------------
`timescale 10ns/1ps
#100//延时100*10ns
#0.1//0.1ns = 1ps，仿真精确到小数点后一位
```

## 时钟管理单元（PLL，DLL）

​	PLL（Phase-Locked Loop）相位锁定的环路，也就是常说的锁相环，锁相环在模拟电路和数字电路系统中均有广泛的应用，很多mcu芯片如stm32，msp430，等都集成了片上的pll，用来通过片外较低频率的晶振产生的时钟倍频得到较高频率的时钟信号以供mcu内核和片上的外设使用，在很多的洗衣芯片中也用到得了pll来通过较低的晶振时钟得到符合协议要求的时钟信号，例如典型的usb协议芯片

- 锁相环 PLL
  - PLL （phase locked loop，锁相环），模拟电路
  - pll与dll的区别：pll是数字的，dll是模拟的，pll精度较高
  - 特性：能够将输入的周期信号就行分频和倍频，并最终输出一个或多个稳定的，与输入信号频率和相位相关的信号
  - 总结：能够通过对输入的时钟信号进行分频，倍频，相位控制，从而得到一路或者多路更高或者更低的时钟信号

## 参数传递

- define 与localparam和parameter最大的区别就是 define 可以跨文件传递参数；parameter只能在模块间传递参数；而localparam只能在其所在的module中起作用，不能参与参数传递。

  1. 新建参数模块文件（我命名为para.v）；

  2. 在para.v文件中使用'define宏定义参数（部分）

     ```verilog 
     //`define+name+参数 　
     `define 　　STATE_INIT	3'd0
     `define 　　STATE_IDLE	3'd1
     `define 　　STATE_WRIT	3'd2
     `define 　　STATE_READ	3'd3
     `define 　　STATE_WORK	3'd4
     `define 　　STATE_RETU	3'd5
     ```

  3. 在需要调用参数的文件init.v中使用`include "para.v"：

     ````include "para.v"```

4. 在init.v文件需要参数的地方使用`name 调用（部分）：`

    ````state_init <= `STATE_INIT;```

  5. localparam与parameter的区别与用法

- parameter可用作在顶层模块中例化底层模块时传递参数的接口；

- localparam的作用域仅仅限于当前module，不能作为参数传递的接口。

- ```Verilog
  //用法
  parameter       DATA_WIDTH = 16;
  parameter       ADDR_WIDTH =  5;
  localparam      DW = DATA_WIDTH - 1;
  localparam      AW = ADDR_WIDTH - 1;
  
  ```

## FPGA的资源

- 可编程逻辑功能块——类比电路板的各种元器件

- 可编程I/O口——类比电路板的输入输出

- 可编程内部互联资源——元器件之间的通信总线

## 电源设计

- cyclone IV E 需要三组供电
  - 内核供电   1.0V；非低电压版本为1.2V
  - pll模拟电路供电，数字电路供电1.2V，模拟电路供电固定的2.5V，使用LDO器件 
  - I/O单元供电，电压值从1.2V~3.3V（1.2；1.5；1.8；2.5；3.0；3.3），共6中可选值，IO Bank 每个bank的IO供电都可以不同

## 配置电路设计

- cyclone IV E 基于SRAM的结构的，SRAM掉电就会丢失，因此系统上电后，必须要有配置电路将正确的配置数据加载到SRAM中，然后FPGA才能正常运行
- 五种配置方式（AS，AP，PS，FPP，JTAG）
  - AS 主动串行方式，电路简单，成本低廉，常用语中小容量的FPGA
  - AP主动并行方式，消耗引脚比较多，常用于配置过程的时间要求较高
  - PS被动串行方式，使用一个外部的主机MCU或者CPLD，常用于通过网络方式对fpga的升级
  - JTAG配置方式，可以在器件正常工作过程中捕获运行数据，JTAG指令具有最高优先级
- 对FPGA进行配置
  - FPGA中没有flash，FPGA基于sram架构，掉电程序丢失，FPGA程序存储在外部的flash中，叫做epcs， 实际上是就是spf flash芯片（stm32 片上程序一般存储在flash中）
  - 使用jtag直接配置 .sof，FPGA 掉电，就会变成白片
  - 使用外部器件进行片配置，flash不会丢失，FPGA上电时主动加载程序
  - 使用外部的控制器进行配置

## 硬件乘法单元

- 18*18硬件乘法器，乘数和被乘数输入宽度最大为18位的乘法器
- 乘法器电路复杂，使用fpga内部资源能实现，但是性能会受限，也消耗更多的面积，不利于降低成本和功耗
- 硬件乘法单元在芯片设计时功能和布局都已经确定，即使不使用，他也在
- 每个硬件乘法电路也能拆分成两个位宽为9的存储器 

## 编码方式的区别

对于状态机

- 独热码，每一个状态均使用一个寄存器， 在于状态比较时仅仅需要比较一位， 相比其他译码电路简单；

- 格雷码，所需寄存器数与二进制码一样，译码复杂，但相邻位只跳动一位，一般用于异步多时钟域多 bit 位的转换，如异步 FIFO；

- 二进制码，最为常见的编码方式，所用寄存器少，译码较复杂。 

对于计算

- BCD 码中最常用的是 8421 码，其各个 bit 权值分别是 8d、 4d、 2d、 1d
- 同理 5421 码各位的权依次为 5d、 4d、 2d、 1d。 5421 码特点是最高位连续 5 个 0 后连续 5 个 1，故其当计数器采用这种编码时，最高位可产生对称方波输出
- 余 3 码是在 8421 码上加 0011b 的出来的；
- 格雷码的特点是任意两个相邻的代码只有一位二进制数不同，编码格式不唯一；
- 余 3 循环码具有格雷码的特点并且编码的首尾可以连接来进行循环，这样可用反馈移位寄存器来实现，硬件实现简单。 

- BCD码利于十进制的计算

  BCD 码的运算规则： BCD 码是十进制数，而运算器对数据做加减运算时，都是按二进制运算规则进行处理的。这样，当将 BCD 码传送给运算器进行运算时，其结果需要修正。修正的规则是：当两个 BCD 码相加，如果和等于或小于 1001b(即十进制数 9)，不需要修正；如果相加之和在 1010b 到 1111b(即十六进制数 0AH～0FH)之间，则需加 6d 也就是 0110 进行修正；如果相加时，本位产生了进位，也需加 6 进行修正。下面举例说明：计算 5+8，将 5和 8 转换为 8421 BCD 码后输入加法器，则运算如下： 0101 + 1000 = 1101 结果大于 9d，+0110b 即加 6d 修正得出 10011b，补充高位为 0001_0011b。 即 5+8=13，结论正确。

  BCD 码的主要应用之一就是数码管，假设要将十进制数 158 显示， 一般解决办法是把需要显示的十进制数的个、十、百、千位数等进行拆分，即把 158 拆分出 1、 5、 8，然后查出对应的数码管显示段码再送去给数码管连接的 IO 口。这个过程可以进行下面的运算：先进行除法运算 158/100 得出百位 1，再取余 158%100 = 58 后继续进行除法运算 58 / 10 得出十位 5，再进行一次取余 158%10 ，得到个位 8。以上过程可以看出需要除法，但是由于除法运算是比较消耗计算时间导致整体需要的指令周期太久。但是如果先将其转换为 BCD 码，则可大幅度减少运算时间。 具体应用将在数码管一讲中详细介绍。 

## 三种状态机写法的区别

- 同步状态机的原理结构和设计
  1. 下一状态 = F（当前状态，输入信号）
  2. 输出信号 = G（当前状态，输入信号）mealy状态机
  3. mealy状态机：时序逻辑的输出不但取决于状态还取决于输入，大部分都是mealy状态机
  4. moore状态机：时序逻辑电路的输出只取决于当前状态

- 时序逻辑电路与组合逻辑电路的区别
  - 时序电路输出状态不仅取决于当前输入，也取决与当前的电路状态
  - 组合逻辑电路输出只取决于当前输入

状态机描述方式，可分为一段式、两段式以及三段式。

- 一段式，整个状态机写到一个 always 模块里面。 在该模块中既描述状态转移，又描述状态的输入和输出。
- 两段式，用两个 always 模块来描述状态机。 其中一个 always 模块采用同步时序描述状态转移， 另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律及其输出。 
- 三段式，在两个 always 模块描述方法基础上，使用三个 always 模块。 一个 always 模块采用同步时序描述状态转移，一个 always 采用组合逻辑判断状态转移条件，描述状态转移规律，另一个 always 模块描述状态输出(可以用组合电路输出，也可以时序电路输出)。 

三种状态机的问题

- 可以看出两段式有限状态机与一段式有限状态机的区别是将时序部分（状态转移）和组合部分（判断状态转移条件和产生输出）分开，写为两个 always 语句，即为两段式有限状态机。将组合部分中的判断状态转移条件和产生输出再分开写，则为三段式有限状态机。
- 二段式在组合逻辑特别复杂时，注意需在后面加一个触发器以消除组合逻辑对输出产生的毛刺的影响。三段式则没有这个问题， 这是由于第三个 always 会生成触发器。其实现在的器件根本不在乎这一点资源消耗，推荐使用二段式或者三段式以及输出寄存的状态机输出来描述有限状态机。
- 编写状态机还应主要注意的事项是，为了避免不必要的锁存器生成，需要穷举所有状态对应的输出动作，或者使用 default 来定义未定义状态动作；
- 在定义状态时， 推荐使用本地化参数定义 localparam，这样可以在编写时状态更清晰且不容易出错，也方便修改；在复位或者跑飞能回到初始态或者预定态；要有异步或者同步复位来确保状态机上电有个初始态。



第六课

1. 状态机
   1. 对具有逻辑顺序和时序规律的时间的一种描述方法，不仅是方法，更是问题的思想
2. 应用思路
   1. 从状态变量入手
   2. 明确电路的输出的关系，相当于状态的输出
3. 基本要素
   1. 状态
   2. 输出
   3. 输入
4. 描述方式  
   1. 状态转移图
   2. 状态转移列表
   3. HDL语言描述
5. 安全、稳定、健壮、不会死循环、受到扰动能复位



## 两种fifo设置的区别

- normal synchronous FIFO mode 与 show-ahead synchronous FIFO mode区别

- 选则第一种普通方式则 rdreq 信号作为实际意义上的读请求信号，当该信号有效时 FIFO 中的控制逻辑从存储器中读取一个数据输出到 q 端。 
- 如果选中 Show-ahead 方式，则 rdreq 实际作为了读应答信号，即 rdreq 还没有有效时， q 端口上已经输出了一个有效的数据， rdreq 信号有效的时候则相当于通知 FIFO 内部的控制逻辑 q 端口上的数据已经被读取，则 FIFO 内部的逻辑会从 RAM 中再取出一个新的数据，在下一个时钟周期输出到 q 端口上。该模式在实际中应用也非常的普遍，因为 q 端口上的数据 与 rdreq 同时有效，没有读潜伏期。 

## readmemb与readmemh的使用

1. 在verilog中有$readmemh(“filename”, mem_name)命令，在使用这个命令时，”filename”中的路径要用反斜杠’/’，而不是斜杠’\’。如

   - $readmemh("F:/mydesigen/re_input.txt",re_input);

   - 上面的语句是正确的，而如果用斜杠就有问题，如

   - $readmemh("F:\mydesigen\re_input.txt",re_input);

2. readmemb（“D：/file1/file2/ramh.dat”，a）；即可以调用到放置在任意处的存储文件。当采用$readmemb（“ramh.dat”，a）；这种方式时，ramh.dat文件必须放置在工程下的simulation文件夹下，亲测其他放置都无效。

3. 关于存储文件后缀，.dat .txt 甚至不加后缀都可以，只要保证程序里调用的与文件夹中实际的一致，可以索引到即可

4. 对于需要的txt文件，其格式为每行一个数据，存储顺序。文档中由上至下，对应数组由低到高。

   - 例如用matlab产生文件则可以这样写

     ```fid0 = fopen('F:\path\re_input.txt','w+');```

     ```fprintf(fid0,'%x \n',real(info));```

     其中的换行符是必须的。同时，在matlab中，路径语句的斜杠’\’或是反斜杠’/’都没有问题。

5. 不可综合。readmemb、readmemh、initial 都是不可综合语句（怎么可以这样呢！那大数组怎么赋值？）也就是说只能在仿真时调试用。

6. 对于$readmemh对应的16进制文件，不用写成4'hA，最简单的A即可。

## verilog 中计算的化简

- 可以将其拆分为2的幂级数，比如10 = 2+8，尽量不要使用乘法器
- 如果相除之后产生大量小数位，可以先将被除数扩大到商没有小数，将计算结果进行其他计算，最终在将结果缩小相应的倍数，因为在FPGA终没有浮点数这一说，所有产生小数的结果，只能精确到1，采用上述方法后，可以将结果进一步的精确
- 如果结果太大可以将结果扩大的倍数放小一点，这样造成的为是结果精度的减小
- 考虑溢出问题

## 阻塞赋值与非阻塞赋值的六个原则

- 时序电路建模时，用非阻塞赋值；
- 锁存器电路建模时，用非阻塞赋值；
- 用 always 块建立组合逻辑模型时，用阻塞赋值；
- 在同一个 always 块中建立时序和组合逻辑电路时，用非阻塞赋值；
- 在同一个 always 块中不要既用非阻塞赋值又用阻塞赋值；
- 不要在一个以上的 always 块中为同一个变量赋值。  

## 原语，primitive

不同的厂商，原语不同；同一家的FPGA，不同型号的芯片，可以也不一样；原语类似最底层的描述方法。使用原语的好处，可以直接例化使用，不用定制IP；即可通过复制原语的语句，然后例化IP，就可使用；Xilinx是通过直接修改原语中的参数再例化IP来使用；Xilinx公司的原语分为10类，包括：计算组件，IO端口组件，寄存器/锁存器，时钟组件，处理器组件，移位寄存器，配置和检测组件，RAM/ROM组件，Slice/CLB组件，G-tranceiver。

硬件原语比较底层，可以针对一个逻辑单元来操作，是软件中集成好的，不需要向调用IP核那样复杂的过程，可以直接在代码中调用，当然功能相对比较简单。而IP核功能比较多，调用时需要设置很多参数。

## 扇入/扇出

扇入（fan-in）是定义单个逻辑门能够接受的数字信号输入最大量的术语。大多数TTL逻辑门有一个或两个输入端，也有一些有两个以上的输入端。一个典型的逻辑门有1、2个扇入信号。

在 软件工程中，模块的扇入是指有多少个上级模块调用它。扇入越大，表示该模块被更多的上级模块共享。这当然是我们所希望的。但是不能为了获得高扇入而不惜代价，例如把彼此无关的功能凑在一起构成一个模块，虽然扇入数高了，但这样的模块内聚程度必然低。这是我们应避免的。

扇出（fan-out）是一个定义单个逻辑门能够驱动的数字信号输入最大量的专业术语。大多数的TTL逻辑门能够为10个其他数字门或驱动器提供信号。因而，一个典型的TTL逻辑门有10个扇出信号。
　　在一些数字系统中，必须有一个单一的TTL逻辑门来驱动10个以上的其他门或驱动器。这种情况下，被称为缓冲器的驱动器可以用在TTL逻辑门与它必须驱动的多重驱动器之间。这种类型的缓冲器有25至30个扇出信号。逻辑反向器（也被称为非门）在大多数数字电路中能够辅助这一功能。

![扇出扇入](fpga笔记.assets/扇出扇入.png)

一个模块的扇出数过大或过小都不理想，过大比过小更严重。一般认为扇出的上限不超过7。扇出过大意味着管理模块过于复杂，需要控制和协调过多的下级。解决的办法是适当增加中间层次。

一个模块的扇入是指有多少个上级模块调用它。扇人越大，表示该模块被更多的上级模块共享。这当然是我们所希望的。但是不能为了获得高扇人而不惜代价，例如把彼此无关的功能凑在一起构成一个模块，虽然扇人数高了，但这样的模块内聚程度必然低。这是我们应避免的。

设计得好的系统，上层模块有较高的扇出，下层模块有较高的扇人。其结构图像清真寺的塔，上面尖，中间宽，下面小。

## 详细的设计流程

1、系统总体规划（system global plan）

　　项目策划完成，领导开始让工人们干活。首先就是高级工人，系统算法工程师，根据要求，搞一堆算法来，看看哪一个比较符合老大的项目策划书要求。系统架构工程师根据系统算法工程师提出的算法，想想怎么用详细的特定功能硬件实现，发现算法的硬件实现比较坑爹，就去找系统算法工程师理论。然后这两类系统工程师通过对系统的方案、设计、仿真跟各种撕逼之后（他们撕逼的内容听说有这些：浮点数算法，软硬件划分，IC设计中数据的定点表示，定点算法表示，结构的并行性跟流水线，存储器分配，还有其他等...），达到平衡点（就是算法能够较好地使用良好架构跟电路的实现），一份**系统设计规格书**就出来了。至于系统设计规格书里面具体有什么，我们就不展开说明了。

2、模块设计（module design）

　　高级的系统工程师完毕，就到我们这些螺丝钉，进行模块设计了。模块设计也还是分等级，人家有高级数字IC设计工程师。而真正专门写模块的呢，就是螺丝钉级的一般数字IC工程师，别称”硅农”...透露一下，系统设计规格书里面就有进行模块划分的内容，这里就是进行设计模块了。一般，模块设计使用HDL语言进行输入，输入工具使用GVIM。写完一个模块了，（进行代码设计规则检查，这个靠检查工具来工作了，检查工具可以检测几百个设计规则，检查的内容主要有：标准规则检查、可重用性检查、竞争条件检查、可综合性、可测试性、时钟域、结构性、加速策略、用户自定义的规则等），然后进行功能验证，就是验证你写的这个电路是不是符合模块的功能要求，使用的工具是synopsys的VCS。仿真通过之后，就可以把模块提交上去了给上层负责管理顶层模块的高级数字IC工程师了。有兴趣的话，可以自己综合一下自己负责维护的模块。

3、顶层模块集成（top level integration）

　　底层的的模块写完之后，开始进行模块集成，新模块跟复用的旧模块集成，I/O，时钟等模块的基础，把系统集成起来，构成整个系统后，就完成了系统模块的集成。

4、顶层功能模块验证（top level verification）

　　顶层模块集成完毕后，检测集成之后模块是否还能正常工作，验证功能是否正确，各项指标是否完好等等。这里，数字IC验证工程师就可以放大招了。验证使用VCS进行。验证是一门杂活哇，各种方法学UVM之类的，还是我们硅农的小模块验证比较好。

5、逻辑综合（logic synthesis）

　　逻辑综合就是通过EDA工具把顶层的HDL模块，在一定的约束情况下，映射到制造厂家标准单元库元件的门级电路的过程。通过这个步骤，从HDL代码，得到了门级网表，也就是得到了电路。具体的有关综合的知识将在后文联合synopsys的综合工具design compiler进行记载。

6、形式验证（formal verification）

　　形式验证，就是对设计过程中不同阶段的输出结果进行逻辑功能一致性的对比，根据电路的结构，判断两个设计在逻辑功能上是否对等。有关形式验证的知识将在后文中记载。

7、静态时序分析（static time analysis,STA）

　　静态时序分析，就是通过EDA工具，提取电路中所以路径的延迟信息进行分析，计算出信号在路径上的延时，检查时序是否满足设定的时序约束要求。静态时序分析将在后文中结合synopsys的PT工具进行记载。

8、可测性设计插入（design for test,DFT）

　　可测性设计是指：在进行电路的前端设计时，就预先规划、设计出如何在样片中进行电路的测试方案和办法，并通过逻辑综合过程完成芯片内部专用测试结构的插入，一遍在芯片形成后能按照预先制定的方案进行相应的电路功能测试的一种设计方法。也就是进行可测性设计，就是在原有的电路中插入专门测试的电路（插入电路）。

 ====================================================================================================================================================================

上面的部分基本前端设计的部分，是我后面内容主要涉及的内容，后面的主要是后端设计的部分，这后端设计就是专业名词特别多，而且还中英互联，很少让人讨厌。所以后端的部分知识按照常规来介绍了

 ====================================================================================================================================================================

9、版图物理规划（floor-plan）

　　这一步骤主要是通过对EDA工具进行输入标准单元库、标准I/O库、综合后的网表、各种约束文件等，规划好让EDA工具完成各模块的位置摆放、电源网络的设定、I/O信号出口位置、同时确定面积、封装、工艺、噪声、负载能力等参数。

10、功耗分析（power analysis）

　　在完成版图物理规划后，需要进行功耗分析。功耗分析可以确定电源引脚的位置和电源线的宽度是否满足要求。对整个版图进功耗分析，即要进行动态功耗分析跟静态功耗分析，找出主要的功耗单元或者模块，以供优化。

11、单元布局与优化（placement & optimistic）

　　根据floor-plan中的布局规划，摆放网表中调用的所以标准单元，EDA工具自动对时序约束、布线面积、布线拥堵等综合考虑标准单元的摆放，从而依靠EDA工具完成电路的布局设计跟优化。

　　EDA主要进行自动对floor-plan的具体工作的标准单元实现：确定各功能模块的位置和整个芯片的尺寸；确定I/O buffer 的位置，定义电源和地PAD的位置；定义各种物理的组、区域或模块，对大的宏单元进行放置；设计整个供电网络，基于电势降和电迁移进行拓扑优化；通过布局调整、约束修改、属性添加、密度、高速信号分析等手段达到优化的目的。

12、时钟树综合（clock tree synthesis，CTS）

　　要了解时钟树综合，那么就得中断什么是时钟树。时钟树就是分布在芯片内部的的寄存器跟数字的驱动电流构成的一种树状结构的电路。时钟树综合就是EDA工具按照约束，插入buffer，使时钟的源头（时钟根节点）到达各个需要时钟驱动的器件（各叶子节点，如触发器）的时间基本一致的过程。时钟树综合通常使用EDA工具自动进行。

13、布线（routing）

　　布线就是完成模块、节点的相互连线。EDA工具可以分成全局布线和详细布线。一般情况下先使用EDA工具布线，然后在人工干预的情况下局部自动或者手工进行连接一些比较关键地连线，进行修复连接上的问题和时序约束上的问题。注意，关键路劲跟时钟上的连接线要尽量最先连接，以免绕线，导致时序问题。

14、信号完整性分析（signal competition analysis）

　　信号完整性分析是通常是进行分析噪声。随着器件尺寸的下降，器件的供电电压、噪声容限均下降。也就是说，也许由于某一根导线可能电阻过大，带来的压降过大，导致器件的供电电压达不到而不能正常工作等等的一系列问题。对这些问题进行分析，是信号完整分析的一部分。

15、寄生参数提取（parasitic extraction）

　　根据布线完成得版图提前RC（电阻电容）参数文件。对EDA工具输入相应的工艺参数（厂家提供）后，EDA工具根据这些参数和版图实际几何形体的面积计算出RC值，然后通过存储从而提取出RC参数。提取出来的RC参数，可以直接用于静态时序分析，也可以在计算出相应的路径延时时，用于反标功能后仿真。

16、后仿真（post-layout simulation）

　　后仿真也叫门级仿真、时序仿真、带反标的仿真。它是通过采用外部激励和布局布线后产生的标准延时文件（*.sdf），对布局布线后的门级电路网表进行功能和时序验证，来检验门级电路是否符合功能要求。

17、工程更改命令（engineering change order,ECO）

在设计的最后阶段发现个别路劲有时序问题或者逻辑错误时，通过芯片内部专门留下的寄存器跟组合逻辑，对设计部分进行必要的小范围的修改和重新连线。

ECO在是在网表上做文章，在非必须的情况下（如时间充足，人员充足），不要进行ECO。

18、物理验证（physical verification）

　　物理验证主要是一个对版图的设计结果是否预定要求而进行的验证过程。

　　首先是通过DRC（design rule check，设计规则检查）对版图设计中的约束违规情况进行检查，以保证各层版图都符合设计的要求。然后是进行LVS（layout vs. Schematic，版图网表与电路原理图比较），进行版图网表跟原始电路图的一致性对比检查，即通过版图寄生参数提取工具得到一个有版图寄生参数的电路图，将它跟原理电路图进行比较，以确保版图设计与原要求的电路图的逻辑功能一致性。

　　此外还有一些需要进行ERC，即电气规则检查。这里不详述了。

我所知道流程大概就是这样了，参考文献：

　　　　　　　　《Soc设计方法与实现（第二版）》

　　　　　　　　《EDA与集成电路工程实践》

　　　　　　　　《数字IC系统设计》

　　　　　　　　《数字集成电路设计与技术》

## AXI

- AXI（Advanced eXtensible Interface）是一种总线协议，该协议是ARM公司提出的AMBA（Advanced Microcontroller Bus Architecture）3.0协议中最重要的部分，
- AXI 是一种面向高性能、高带宽、低延迟的片内总线。它的地址/控制和数据相位是分离的，支持不对齐的数据传输，同时在突发传输中，只需要首地址，同时分离的读写数据通道、并支持Outstanding传输访问和乱序访问，并更加容易进行时序收敛。
- AXI 是AMBA 中一个新的高性能协议。AXI 技术丰富了现有的AMBA 标准内容，满足超高性能和复杂的片上（SoC）设计的需求。

## qsys？nios II？sopc？

qsys是一个工具，这个工具是用来帮助搭建系统的

nios II是一款cpu，是一个处理器

sopc是一种技术，可编程偏上系统，是一种解决方案

## sopc

sopc：使用FPGA通用逻辑搭建CPU和外围设备电路

Altera：nios II软核CPU，能跑到接近100兆32个通用寄存器，类似于arm7，性能也较为接近

xlinix：microblaze 软核cpu

arm cortex-A9 cortex-A53能够跑到900多兆，powerPC硬核，mc8051提供相应软核

片上嵌入双核arm A9，处理器和FPGA融合，异构计算

2013之前altera sopc 基于nios II 软核处理器

软核处理器-->没有硬核处理器的电路，使用FPGA通用逻辑阵列搭建起来的

硬核处理器-->电脑处理器，之类的

软核CPU的应用场景：网络传输，lcd显示界面，频谱分析仪，必须以FPGA为主，又需要一些显示

如果使用stm32以及FPGA比较难做，功耗难以降下来

soc片上系统

赛灵思叫zynq

使用qsys搭建一个nios II系统

stm32有两种数据总线，APB-->外设总线，AHB-->数据总线



## avalon总线

有两种

qsys遵循avalon总线规范

- 第一种是avalon mm（memory map）
- 第二种是avalon st（数据 ） 总线

## 以太网

以太网Mac层原理

以太网帧

一帧数据分为

以太网帧头，数据部分，FCS/CRC校验

前导码 7个字节 0x55

帧开始符 1个字节，0xd5

接收方mac地址 6个字节

发送方mac地址 6个字节

长度/字段类型  2个字节

数据 46~1500个字节

FCS校验字段 4个字节

怎么发送数据，怎么发？通过什么发？与物理层使用什么协议沟通

MII接口，RGMII接口，GMII接口，SGMII接口

MII介质无关接口

## 以太网图传项目

1. 图像产生（cmos）
2. 图像缓存（图像传感器产生的数据较快，百兆以太网发送图像数据较慢，因此需要一个中间缓存来将图像存储起来，然后在发送）
3. 图像发送（使用UDP系诶一发送） 
4. 每个图像传感器都包括配置接口和图像数据接口
5. sccb--> I2c
6. DVP（MIPI）
7. 图像数据的格式转换（RGB/YVUE/Bayer 。。。）

以太网图像数据发出去

​	1280图像数据

​	内部有一个至少1280个字节的FIFO或ram，16位*1024

需要在图像一帧存完之后再来读取并发送，在一台网发送图像数据的过程中，应该暂停图像数据的写入

从sdram里面读取所需要的的数据，存入以太网发送模块的FIFO或者ram中去

使能以太网发送模块开始一帧数据的发送

以太网发送模块发送完一帧图像之后，才能够再使能新一帧图像的存储

以太网FPGA设计

服务器数据交换

led数据交换

以太网mac简述

以太网分层，七层协议，四层协议

什么叫物理层-->网线+网卡

网口--》网线  物理介质层、

网线--》双绞线

数据链路层--》以太网mac层

 udp协议FPGA实现

提供面向失误的简单不可靠信息传送服务
