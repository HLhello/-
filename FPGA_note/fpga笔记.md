## 学习要点

基本逻辑

接口逻辑：uart can spi lvds

状态机，线性序列机（计数器，按时间分片）

IP的使用，第三方厂家，包括计数器，io接口，fft，各种软核CPU

接口设计

时序分析，时序约束

## wire与reg的区别

wire

- wire型数据通常用来表示用以assign关键字指定的组合逻辑信号
- verilog程序模块中输入输出信号类型默认时自动定义为wire型
- wire型信号可以用作任何方程式的输入，也可以用作assign语句或实例原件的输出

reg

- reg型数据常用来表示always模块内的指定信号，常代表触发器
- 在时序逻辑always模块内被赋值的每一个信号都必须被定义为reg型
- reg型数据的默认初始值是不定值

触发器和锁存器的区别

- 锁存器靠控制信号的电平实现数据的保存
- 触发器靠控制信号的边沿变化实现数据的保存

## cpld与fpga的异同

- fpga是在cpld之后发展出的一种更复杂的pld
- fpga集成了更多且更复杂的资源，包括可配置的逻辑块，时钟资源，时钟管理模块，块存储资源，互联资源，专用dsp模块，输入/输出块，XADC模块等，在一些高性能的fpga内还提供了吉比特收发器和PCI-E模块等硬核资源
- cpld使用与或阵列，fpga使用查找表结构，这是fpga最基本的原理

## 查找表LUT（look-up table）原理

- 由布尔逻辑代数理论可知，对于一个n输入的逻辑运算，最多产生2的n次方个不同的组合，如果预先将每个逻辑输入对应的结果保存在一个存储单元中，就相当于实现了逻辑门电路的功能
- fpga内的组合逻辑电路均由查找表实现
- LUT实现组合逻辑电路的功能由输入决定，而不是由复杂度决定
- LUT实现组合逻辑有固定的传输延迟 

- 相较于传统的逻辑门电路，LUT实现组合逻辑电路的功能克服了以下缺点
  - 逻辑门电路的输入变量从输入经过逻辑门运算后送到逻辑输出变量，存在一定的延时，延迟大小与逻辑电路的复杂度相关，并且是不确定的，延迟时间的不确定，工作频率就不确定，工作频率与时序逻辑电路的工作速度密切相关，由于工作速度的不确定，从而影响到了整个电路的性能
  - 逻辑电路的复杂度与输入逻辑变量的个数和逻辑电路所使用的逻辑门的数量有关，很明显，逻辑电路输入变量越多，电路越复杂

## 约束文件

- xlinix vivado集成开发环境使用xlinix 设计约束（xlinix design constraints，XDC）
- XDC是基于标准的synopsys设计约束（synopsys design constraints，SDC）的
- XDC文件特点
  - 不是简单的字符串，遵循tcl语法命令
  - 通过vivado tcl 翻译器就可以像理解tcl命令那样理解他们
  - 可以读取tcl指令，然后按照顺序对命令进行分析
- 如何添加XDC
  - 在设计的不同阶段均可添加XDC，将约束保存在一个或者多个XDC文件中
  - 通过read_xdc命令
  - 将他添加到其中一个设计工程的约束集中
- 通过TCL脚本生成的约束，可以通过下面的方法运行TCL脚本
  - 运行source命令
  - 将TCL叫脚本添加到其中一个设计工程约束集中

## 模块端口定义

- 三种模块端口定义，input， output， inout

- 我是这么理解的，首先在模块命后的括号内定义端口，然后声明端口
  - 声明端口时同时声明端口的数据类型，没有声明端口类型的情况下默认为线网类型，端口类型有线网（net）型和寄存器（reg）型
  - 有符号（signed）型数据，无符号型数据，没有声明端口有无符号时，默认为无符号型的端口

## verilog的描述方式

- 行为级描述是verilog hdl最高抽象级别的描述方式，可以按照要求来实现一个设计算法，而不用关心具体的实现方式，但是行为级描述是不可以被综合的，行为级描述语句可以描述逻辑行为，包括initial语句和always语句，用于对设计进行仿真，不能转化为实际的电路结构。

- 寄存器传输级（rtl）级描述，数据流描述，可以理解为在一个复杂的数字系统中，应该包含有数据流和控制流，控制流用于控制数据的流向，寄存器传输，任何数据从输入到输出，都需要经过寄存器来对数据重定序，这样，保证数据从输入到输出满足书序收敛的条件，不会出现竞争冒险与亚稳定状态。完成后将转化为实际的电路

## 系统任务和函数，编译器指令

- 以" $ "开始的标识符表示系统任务或者系统函数
- 以" ` "开始的的某些表示符看做编译器指令

## verilog 中数字的使用

- 不太理解：" 在任何时候，负数应该使用二进制补码形式表示 "，这是啥意思？

- ```<+/-><size><'base_format><number>```
- 第一的尖括号里为正负，可正可负也可以不写，不写默认为正数或者无符号数
- 第二个尖括号为位宽，在使用数字时必须带位宽，位宽包括有符号数的符号位
  - 未指定位宽，默认位宽至少32位
  - size位宽小于number位宽，将高位截断，保留低位
  - size位宽大于number位宽，根据正负（符号位）补全，正数补0，负数补1；无符号数补0；number最高位为x/z则同样补x/z
- 第三个尖括号为数的格式，base_format = {b, o, d, h, sb, so, sd, sh}，s代表为有符号数，
  - 可有与第一个尖括号中的正负搭配使用，完全的定义，不会产生歧义
  - 也可以只有第一个尖括号中的正负不写s，有点问题哎，尽量避免这样的定义
  - 也可以没有第一个尖括号的正负值有后面的s，当然是默认为正的有符号数
- 第四个尖括号中可以出现的数字为 number = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, x, z, ?}(不区分大小写)以及作为连接符的下划线"_",
  - x不确定态，z高阻态，？作用同z
  - x,z,?，根据base_format的定义，所代表的位宽可以为1,2,4，当然十进制的话我也不知啦，不要那么用，没有意义

## 属性attribute

- 参见数字设计权威指南何宾

- 知道但不会用，感觉是指定一些特定的东西，在综合是加进去，比如之前用过的探针属性，属性有自己的名字，以及自己对应的值

## testbench文件中的时间定义

```1 s = 1,000 ms = 1,000,000 μs = 1,000,000,000 ns = 1,000,000,000,000 ps```

皮秒，符号ps（英语：picosecond ），1皮秒等于一万亿分之一秒（```10^(-12)s```）

``` 1,000 ps= 1ns```

```1,000,000 ps = 1μs ```

```1,000,000,000 ps = 1ms```

```1,000,000,000,000 ps = 1s```

纳秒，符号ns（英语：nanosecond ），1纳秒等于十亿分之一秒（```10^(-9)s```）

```1 ns= 1000ps```

```1,000 ns= 1μs ```

```1,000,000ns = 1ms```

```1,000,000,000 ns= 1s```

微秒，符号μs（英语：microsecond ），1微秒等于一百万分之一秒（```10^(-6)s```）

```0.000 001 μs= 1ps```

```0.001 μs= 1ns```

```1,000 μs= 1ms```

```1,000,000 μs= 1s```
毫秒，符号ms（英语：millisecond ），1毫秒等于一千分之一秒（10-3秒）

```0.000 000 001 ms= 1ps``` 

```0.000 001 ms= 1ns ```

```0.001 ms = 1μs ```

```1000 ms = 1s```

```verilog
`timescale 1ns/1ps //单位/精度
#100 //延时100ns
//-------------------------
`timescale 10ns/1ps
#100//延时100*10ns
#0.1//0.1ns = 1ps，仿真精确到小数点后一位
```

## 时钟管理单元（PLL，DLL）

​	PLL（Phase-Locked Loop）相位锁定的环路，也就是常说的锁相环，锁相环在模拟电路和数字电路系统中均有广泛的应用，很多mcu芯片如stm32，msp430，等都集成了片上的pll，用来通过片外较低频率的晶振产生的时钟倍频得到较高频率的时钟信号以供mcu内核和片上的外设使用，在很多的洗衣芯片中也用到得了pll来通过较低的晶振时钟得到符合协议要求的时钟信号，例如典型的usb协议芯片

- 锁相环 PLL
  - PLL （phase locked loop，锁相环），模拟电路
  - pll与dll的区别：pll是数字的，dll是模拟的，pll精度较高
  - 特性：能够将输入的周期信号就行分频和倍频，并最终输出一个或多个稳定的，与输入信号频率和相位相关的信号
  - 总结：能够通过对输入的时钟信号进行分频，倍频，相位控制，从而得到一路或者多路更高或者更低的时钟信号

## 参数传递

- define 与localparam和parameter最大的区别就是 define 可以跨文件传递参数；parameter只能在模块间传递参数；而localparam只能在其所在的module中起作用，不能参与参数传递。

  1. 新建参数模块文件（我命名为para.v）；

  2. 在para.v文件中使用'define宏定义参数（部分）

     ```verilog 
     //`define+name+参数 　
     `define 　　STATE_INIT	3'd0
     `define 　　STATE_IDLE	3'd1
     `define 　　STATE_WRIT	3'd2
     `define 　　STATE_READ	3'd3
     `define 　　STATE_WORK	3'd4
     `define 　　STATE_RETU	3'd5
     ```

  3. 在需要调用参数的文件init.v中使用`include "para.v"：

     ````include "para.v"```

4. 在init.v文件需要参数的地方使用`name 调用（部分）：`

    ````state_init <= `STATE_INIT;```

  5. localparam与parameter的区别与用法

- parameter可用作在顶层模块中例化底层模块时传递参数的接口；

- localparam的作用域仅仅限于当前module，不能作为参数传递的接口。

- ```Verilog
  //用法
  parameter       DATA_WIDTH = 16;
  parameter       ADDR_WIDTH =  5;
  localparam      DW = DATA_WIDTH - 1;
  localparam      AW = ADDR_WIDTH - 1;
  
  ```

## 电源设计

- cyclone IV E 需要三组供电
  - 内核供电   1.0V；非低电压版本为1.2V
  - pll模拟电路供电，数字电路供电1.2V，模拟电路供电固定的2.5V，使用LDO器件 
  - I/O单元供电，电压值从1.2V~3.3V（1.2；1.5；1.8；2.5；3.0；3.3），共6中可选值，IO Bank 每个bank的IO供电都可以不同

## 配置电路设计

- cyclone IV E 基于SRAM的结构的，SRAM掉电就会丢失，因此系统上电后，必须要有配置电路将正确的配置数据加载到SRAM中，然后FPGA才能正常运行
- 五种配置方式（AS，AP，PS，FPP，JTAG）
  - AS 主动串行方式，电路简单，成本低廉，常用语中小容量的FPGA
  - AP主动并行方式，消耗引脚比较多，常用于配置过程的时间要求较高
  - PS被动串行方式，使用一个外部的主机MCU或者CPLD，常用于通过网络方式对fpga的升级
  - JTAG配置方式，可以在器件正常工作过程中捕获运行数据，JTAG指令具有最高优先级
- 对FPGA进行配置
  - FPGA中没有flash，FPGA基于sram架构，掉电程序丢失，FPGA程序存储在外部的flash中，叫做epcs， 实际上是就是spf flash芯片（stm32 片上程序一般存储在flash中）
  - 使用jtag直接配置 .sof，FPGA 掉电，就会变成白片
  - 使用外部器件进行片配置，flash不会丢失，FPGA上电时主动加载程序
  - 使用外部的控制器进行配置

## 硬件乘法单元

- 18*18硬件乘法器，乘数和被乘数输入宽度最大为18位的乘法器
- 乘法器电路复杂，使用fpga内部资源能实现，但是性能会受限，也消耗更多的面积，不利于降低成本和功耗
- 硬件乘法单元在芯片设计时功能和布局都已经确定，即使不使用，他也在
- 每个硬件乘法电路也能拆分成两个位宽为9的存储器 

## 编码方式的区别

对于状态机

- 独热码，每一个状态均使用一个寄存器， 在于状态比较时仅仅需要比较一位， 相比其他译码电路简单；

- 格雷码，所需寄存器数与二进制码一样，译码复杂，但相邻位只跳动一位，一般用于异步多时钟域多 bit 位的转换，如异步 FIFO；

- 二进制码，最为常见的编码方式，所用寄存器少，译码较复杂。 

对于计算

- BCD 码中最常用的是 8421 码，其各个 bit 权值分别是 8d、 4d、 2d、 1d
- 同理 5421 码各位的权依次为 5d、 4d、 2d、 1d。 5421 码特点是最高位连续 5 个 0 后连续 5 个 1，故其当计数器采用这种编码时，最高位可产生对称方波输出
- 余 3 码是在 8421 码上加 0011b 的出来的；
- 格雷码的特点是任意两个相邻的代码只有一位二进制数不同，编码格式不唯一；
- 余 3 循环码具有格雷码的特点并且编码的首尾可以连接来进行循环，这样可用反馈移位寄存器来实现，硬件实现简单。 

- BCD码利于十进制的计算

  BCD 码的运算规则： BCD 码是十进制数，而运算器对数据做加减运算时，都是按二进制运算规则进行处理的。这样，当将 BCD 码传送给运算器进行运算时，其结果需要修正。修正的规则是：当两个 BCD 码相加，如果和等于或小于 1001b(即十进制数 9)，不需要修正；如果相加之和在 1010b 到 1111b(即十六进制数 0AH～0FH)之间，则需加 6d 也就是 0110 进行修正；如果相加时，本位产生了进位，也需加 6 进行修正。下面举例说明：计算 5+8，将 5和 8 转换为 8421 BCD 码后输入加法器，则运算如下： 0101 + 1000 = 1101 结果大于 9d，+0110b 即加 6d 修正得出 10011b，补充高位为 0001_0011b。 即 5+8=13，结论正确。

  BCD 码的主要应用之一就是数码管，假设要将十进制数 158 显示， 一般解决办法是把需要显示的十进制数的个、十、百、千位数等进行拆分，即把 158 拆分出 1、 5、 8，然后查出对应的数码管显示段码再送去给数码管连接的 IO 口。这个过程可以进行下面的运算：先进行除法运算 158/100 得出百位 1，再取余 158%100 = 58 后继续进行除法运算 58 / 10 得出十位 5，再进行一次取余 158%10 ，得到个位 8。以上过程可以看出需要除法，但是由于除法运算是比较消耗计算时间导致整体需要的指令周期太久。但是如果先将其转换为 BCD 码，则可大幅度减少运算时间。 具体应用将在数码管一讲中详细介绍。 

## readmemb与readmemh的使用

1. 在verilog中有$readmemh(“filename”, mem_name)命令，在使用这个命令时，”filename”中的路径要用反斜杠’/’，而不是斜杠’\’。如

   - $readmemh("F:/mydesigen/re_input.txt",re_input);

   - 上面的语句是正确的，而如果用斜杠就有问题，如

   - $readmemh("F:\mydesigen\re_input.txt",re_input);

2. readmemb（“D：/file1/file2/ramh.dat”，a）；即可以调用到放置在任意处的存储文件。当采用$readmemb（“ramh.dat”，a）；这种方式时，ramh.dat文件必须放置在工程下的simulation文件夹下，亲测其他放置都无效。

3. 关于存储文件后缀，.dat .txt 甚至不加后缀都可以，只要保证程序里调用的与文件夹中实际的一致，可以索引到即可

4. 对于需要的txt文件，其格式为每行一个数据，存储顺序。文档中由上至下，对应数组由低到高。

   - 例如用matlab产生文件则可以这样写

     ```fid0 = fopen('F:\path\re_input.txt','w+');```

     ```fprintf(fid0,'%x \n',real(info));```

     其中的换行符是必须的。同时，在matlab中，路径语句的斜杠’\’或是反斜杠’/’都没有问题。

5. 不可综合。readmemb、readmemh、initial 都是不可综合语句（怎么可以这样呢！那大数组怎么赋值？）也就是说只能在仿真时调试用。

6. 对于$readmemh对应的16进制文件，不用写成4'hA，最简单的A即可。

## verilog 中计算的化简

- 可以将其拆分为2的幂级数，比如10 = 2+8，尽量不要使用乘法器
- 如果相除之后产生大量小数位，可以先将被除数扩大到商没有小数，将计算结果进行其他计算，最终在将结果缩小相应的倍数，因为在FPGA终没有浮点数这一说，所有产生小数的结果，只能精确到1，采用上述方法后，可以将结果进一步的精确
- 如果结果太大可以将结果扩大的倍数放小一点，这样造成的为是结果精度的减小
- 考虑溢出问题

## 阻塞赋值与非阻塞赋值的六个原则

- 时序电路建模时，用非阻塞赋值；
- 锁存器电路建模时，用非阻塞赋值；
- 用 always 块建立组合逻辑模型时，用阻塞赋值；
- 在同一个 always 块中建立时序和组合逻辑电路时，用非阻塞赋值；
- 在同一个 always 块中不要既用非阻塞赋值又用阻塞赋值；
- 不要在一个以上的 always 块中为同一个变量赋值。  

## 原语，primitive

不同的厂商，原语不同；同一家的FPGA，不同型号的芯片，可以也不一样；原语类似最底层的描述方法。使用原语的好处，可以直接例化使用，不用定制IP；即可通过复制原语的语句，然后例化IP，就可使用；Xilinx是通过直接修改原语中的参数再例化IP来使用；Xilinx公司的原语分为10类，包括：计算组件，IO端口组件，寄存器/锁存器，时钟组件，处理器组件，移位寄存器，配置和检测组件，RAM/ROM组件，Slice/CLB组件，G-tranceiver。

硬件原语比较底层，可以针对一个逻辑单元来操作，是软件中集成好的，不需要向调用IP核那样复杂的过程，可以直接在代码中调用，当然功能相对比较简单。而IP核功能比较多，调用时需要设置很多参数。

## 扇入/扇出

扇入（fan-in）是定义单个逻辑门能够接受的数字信号输入最大量的术语。大多数TTL逻辑门有一个或两个输入端，也有一些有两个以上的输入端。一个典型的逻辑门有1、2个扇入信号。

在 软件工程中，模块的扇入是指有多少个上级模块调用它。扇入越大，表示该模块被更多的上级模块共享。这当然是我们所希望的。但是不能为了获得高扇入而不惜代价，例如把彼此无关的功能凑在一起构成一个模块，虽然扇入数高了，但这样的模块内聚程度必然低。这是我们应避免的。

扇出（fan-out）是一个定义单个逻辑门能够驱动的数字信号输入最大量的专业术语。大多数的TTL逻辑门能够为10个其他数字门或驱动器提供信号。因而，一个典型的TTL逻辑门有10个扇出信号。
　　在一些数字系统中，必须有一个单一的TTL逻辑门来驱动10个以上的其他门或驱动器。这种情况下，被称为缓冲器的驱动器可以用在TTL逻辑门与它必须驱动的多重驱动器之间。这种类型的缓冲器有25至30个扇出信号。逻辑反向器（也被称为非门）在大多数数字电路中能够辅助这一功能。

![扇出扇入](fpga笔记.assets/扇出扇入.png)

一个模块的扇出数过大或过小都不理想，过大比过小更严重。一般认为扇出的上限不超过7。扇出过大意味着管理模块过于复杂，需要控制和协调过多的下级。解决的办法是适当增加中间层次。

一个模块的扇入是指有多少个上级模块调用它。扇人越大，表示该模块被更多的上级模块共享。这当然是我们所希望的。但是不能为了获得高扇人而不惜代价，例如把彼此无关的功能凑在一起构成一个模块，虽然扇人数高了，但这样的模块内聚程度必然低。这是我们应避免的。

设计得好的系统，上层模块有较高的扇出，下层模块有较高的扇人。其结构图像清真寺的塔，上面尖，中间宽，下面小。



## AXI

- AXI（Advanced eXtensible Interface）是一种总线协议，该协议是ARM公司提出的AMBA（Advanced Microcontroller Bus Architecture）3.0协议中最重要的部分，
- AXI 是一种面向高性能、高带宽、低延迟的片内总线。它的地址/控制和数据相位是分离的，支持不对齐的数据传输，同时在突发传输中，只需要首地址，同时分离的读写数据通道、并支持Outstanding传输访问和乱序访问，并更加容易进行时序收敛。
- AXI 是AMBA 中一个新的高性能协议。AXI 技术丰富了现有的AMBA 标准内容，满足超高性能和复杂的片上（SoC）设计的需求。

## AMBA概述

SoC的总线有很多标准，例如Silicore的Wishbone总线、IBM的CoreConnect总线（包括PLB、OPB、DCR）、Altera的Avalon总线、OCP-IP的OCP总线等等。ARM公司的AMBA总线也是其中一种

- AMBA（Advanced Microcontroller Bus Architecture）高级微处理器总线架构，AMBA总线标准定义了高性能嵌入式微控制器的通信标准	
- AMBA是有效连接IP核的“**数字胶**”，并且是ARM复用策略的重要组件
- AMBA不是芯片与外设之间的接口，而是ARM内核与芯片上其他元件进行通信的接口。
- AMBA可以将**RISC处理器（精简指令集处理器）**集成在其他IP芯核和外设中

AMBA总线构成下面几个总线，这些内容加起来就定义出一套为了**高性能SoC**而设计的**片上通信的标准**  （包括AHB、APB、AXI、ASB）

- **AHB** (Advanced High-performance Bus) **高级高性能总线**
  - AHB主要是针对**高效率、高频宽及快速系统模块**所设计的总线，它可以连接如微处理器、芯片上或芯片外的内存模块和DMA等高效率模块；
- **APB** (Advanced Peripheral Bus) **高级外围总线**
  - APB主要用在**低速且低功率的外围**，可针对外围设备作功率消耗及复杂接口的最佳化；APB在AHB和低带宽的外围设备之间提供了通信的桥梁，所以APB是AHB或ASB的二级拓展总线 ；
- **AXI** (Advanced eXtensible Interface) **高级可拓展接口**
  - AXI：高速度、高带宽，管道化互联，单向通道，**只需要首地址，读写并行**，支持乱序，支持非对齐操作，有效支持初始延迟较高的外设，连线非常多；
- **ASB** (Advanced System Bus) **高级系统总线**
  - 用的很少



### AHB与AXI、APB的区别与联系

![AMBA总线性能对比](fpga笔记.assets/AMBA总线性能对比.png)

- AHB是先进的高性能总线，AXI是先进的可扩展接口，APB是高级外围总线；
- AHB和APB都是单通道总线，不支持读写并行；而AXI是多通道总线，总共分为五个通道，能够实现读写并行；
- AHB和AXI都是多主/从设备，且通过仲裁机制实现总线控制权的分配；而APB是单主设备多从设备，其主设备就是APB桥，不具有仲裁机制；
- 在数据操作方面，AHB和AXI支持突发传输，APB不支持；此外，AXI支持数据的非对齐操作，AHB不支持；

## qsys？nios II？sopc？

qsys是一个工具，这个工具是用来帮助搭建系统的

nios II是一款cpu，是一个处理器

sopc是一种技术，可编程偏上系统，是一种解决方案

## sopc

sopc：使用FPGA通用逻辑搭建CPU和外围设备电路

Altera：nios II软核CPU，能跑到接近100兆32个通用寄存器，类似于arm7，性能也较为接近

xlinix：microblaze 软核cpu

arm cortex-A9 cortex-A53能够跑到900多兆，powerPC硬核，mc8051提供相应软核

片上嵌入双核arm A9，处理器和FPGA融合，异构计算

2013之前altera sopc 基于nios II 软核处理器

软核处理器-->没有硬核处理器的电路，使用FPGA通用逻辑阵列搭建起来的

硬核处理器-->电脑处理器，之类的

软核CPU的应用场景：网络传输，lcd显示界面，频谱分析仪，必须以FPGA为主，又需要一些显示

如果使用stm32以及FPGA比较难做，功耗难以降下来

soc片上系统

赛灵思叫zynq

使用qsys搭建一个nios II系统

stm32有两种数据总线，APB-->外设总线，AHB-->数据总线



## avalon总线

有两种

qsys遵循avalon总线规范

- 第一种是avalon mm（memory map）
- 第二种是avalon st（数据 ） 总线

## 以太网

以太网Mac层原理

以太网帧

一帧数据分为

以太网帧头，数据部分，FCS/CRC校验

前导码 7个字节 0x55

帧开始符 1个字节，0xd5

接收方mac地址 6个字节

发送方mac地址 6个字节

长度/字段类型  2个字节

数据 46~1500个字节

FCS校验字段 4个字节

怎么发送数据，怎么发？通过什么发？与物理层使用什么协议沟通

MII接口，RGMII接口，GMII接口，SGMII接口

MII介质无关接口

## 以太网图传项目

1. 图像产生（cmos）
2. 图像缓存（图像传感器产生的数据较快，百兆以太网发送图像数据较慢，因此需要一个中间缓存来将图像存储起来，然后在发送）
3. 图像发送（使用UDP系诶一发送） 
4. 每个图像传感器都包括配置接口和图像数据接口
5. sccb--> I2c
6. DVP（MIPI）
7. 图像数据的格式转换（RGB/YVUE/Bayer 。。。）

以太网图像数据发出去

​	1280图像数据

​	内部有一个至少1280个字节的FIFO或ram，16位*1024

需要在图像一帧存完之后再来读取并发送，在一台网发送图像数据的过程中，应该暂停图像数据的写入

从sdram里面读取所需要的的数据，存入以太网发送模块的FIFO或者ram中去

使能以太网发送模块开始一帧数据的发送

以太网发送模块发送完一帧图像之后，才能够再使能新一帧图像的存储

以太网FPGA设计

服务器数据交换

led数据交换

以太网mac简述

以太网分层，七层协议，四层协议

什么叫物理层-->网线+网卡

网口--》网线  物理介质层、

网线--》双绞线

数据链路层--》以太网mac层

 udp协议FPGA实现

提供面向失误的简单不可靠信息传送服务

独热码适合写条件复杂但是状态少的状态机；
格雷码适合写条件不复杂但是状态多的状态机。