# 数据结构与算法基础

## 概述

### 数据结构概述

- 什么是数据结构
  - 数据与数据的关系

- 数据的存储结构
  - 顺序存储结构
    - 比如数组
  - 链式存储结构
    - 比如C语言中的链表 
  - 两种存储结构的区别

- 数据的逻辑结构
  - 集合结构
    - 有点类似于结构体，没有顺序
  - 线性结构
    - 元素与元素之间有一一对应的关系
  - 树形结构
    - 一对多的关系，文件文件夹的关系
  - 图形结构
    - 多对多的关系

### 算法概述

- 算法的定义
  - 解决问题的步骤
- 算法的特性
  - 输入，输出，有穷性，确定性，可行性
- 算法的基本要求
  - 正确性，可读性，健壮性，时间复杂度，空间复杂度
  - 比如1到100 的累加，可以一个一个加，也可以使用等差求和的公式
  - 算法没有最好，只有最合适的

## 线性结构

### 数组

- 数组的基本使用
  - 数组长度一旦定义就不能变了，可以创建一个新数组将数组边长
- 面向对象的数组
  - 封装对数组处理的各种方法，比如对一个数组删除，添加，插入，检索某个数等等方法 
- 数组的有序性
  - 线性查找
    - 直接遍历数组
  - 二分法查找
    - 先将无序的数组进行排序，然后找出中间的数，对比想要查找的数，如果小于目标数，向前找，循环上一次的操作 
- 二分查找法

### 栈stack

- 类似于一个箱子往箱子里放东西，取书的取的是最上面的，先入后出，后入先出，弹夹，最后进入弹夹的子弹最先被射出

### 队列

- 先进的先出，类似于日常排队

### 链表

- 链表，存储节点内容以及下一节点的地址

- 循环链表  
  - 一个接一个，到最后一个指向第一个VB
- 双链表
  - 每一个节点都会记录他的上一个节点和下一个节点
  - 循环双链表
  - 非循环双链表

### 递归

- - 在一个函数的内部使用该函数本身的编程方法
  - 斐波那契数列
  - 汉诺塔

## 排序算法

### 衡量算法的优劣

- 事后统计方法事前分析估算的方法，这两种方法不太合适
- 时间复杂度和空间复杂度
  - 时间复杂度，算法在计算时占用多少时间
    - 并不能直接估算出时间，因为每台计算机不同，虽然不能计算出时间，但是我们可以观察执行的操作次数
    - 使用句频来考虑记为：T(n)，在算法执行次数较大时，我们通常可以忽略常数项，在涉及到函数的指数时，通常可以忽略指数小的项
    - 问题规模，解决一件事程序执行的次数
    - 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，使用T(n)表示，若某个辅助函数f(n)，使得当n趋近于无穷大是T(n) / f(n) 的极限值为不等于零的常数，洛必达？则称f(n)是T(n)的同数量及函数，记作T(n) = O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度
    - 也就是说，T(n)是每个函数的精确的执行次数，O(f(n))是大约略的执行次数，如果两个函数的O(f(n))相等，可以认为这两个函数一样复杂，在计算机上执行的时间大致相同 ‘
    - 平均时间复杂度，最坏时间复杂度，一般说最坏的时间复杂度
  - 空间复杂度，算法在运行时占用多少空间，这个重要性弱于时间复杂度 

### 八种常用的排序算法

#### 交换排序

- 冒泡排序
  - 两个比较，大的向后挪，一次类推，最大的沉底，就是说从数组中找出最大的沉底，然后从剩下的数中找到最小的，再沉底，以此类推 
- 快速排序
  - 随机选一个数a，比a大的放在一边比a小的放一边，做完一次，接着继续在分好的两个序列中每个序列随机选一个数，接着比，直到排成一列
  - 选取基准数，一般选择第一个，并且设置两个游标，确保两个游标能够遍历所有的数，一般一个设置在头，一个设置在尾，使用递归的思想进行解决                                

#### 插入排序

- 直接插入排序

  - 将序列先看成只有第一个数，按照序列的顺序向序列中插值
  - 插入的值先和前面的序列进行比较，将插入值放在正确的位置
  - 放好后继续向前面的序列插值
- 希尔排序
  - 选择一个步长，步长就是1/2序列长，如果序列长是奇数，按照类型转换来说省略掉0.5
  - 计算出步长之后先比较步长上的数，按照直接插入法进行比较
  - 完成之后将上一步的步长/2，接着在比较按照步长取出的数在进行直接插入比较
  - 一直进行下去直到步长为1的时候在进行直接插入法排序得到结果
  - 相当于按照步长分组，分组后直接插入排序，一轮完成之后将步长除2在进行下一轮分组后插入排序
- 插入排序的问题是如果来了一个比较小的数，需要进行比较次数就比较多，希尔排序就是解决这个问题的

#### 选择排序

- 简单选择排序
  - 选择排序，找最小的数，将最小的放在最前面，类似于冒泡？冒泡是找最大的沉底，选择排序是将最小的放在最前面
- 堆排序 
  - 堆分为大顶堆和小顶堆，大顶堆就是父节点大与子节点，小顶堆相反，大顶堆和小顶堆都不分左右，升序排列使用大顶堆，降序排列用小顶堆，
  - 将一个数组看成一个二叉树，将最后一个叶子节点处理成大顶堆的样子，注意要使用递归思想，从最下面的一层开始调整，如果子节点的父节点变化，也要讲子节点与父节点进行比较

#### 归并排序

- 首先设想要合并两个有序数组，首先我们要创建一个能容纳两个数组长度之和的数组，然后比较两个有序数组的第一位，将较小的放到创建好的数组，较大的不动，以此比较每一数，我们就能得到一个有序的数组
- 将一个数组不断的拆分，拆到不能拆，也就是拆成数组长度为1，然后将每个拆好的序列不断进行上面的操作，知道数组合并完

#### 基数排序

- 基数排序适合数据的上限较大，下限较小的数组，数组比较离散
- 基本基数排序
  - 设置十个桶，分别代表0~9十个数
  - 首先根据每个数据个位上的数放进十个桶里，将个位相同的数放在一个桶里
  - 先放进去的数先取出来，在合并成一个序列
  - 然后根据每个数据十位上的数放进十个桶里，十位数相同的数放在一个桶里
  - 在桶里取出来，合并成一个数组
  - 以此类推，当最大的数据的最高位排好之后我们就得到了有序数据
- 基数排序的队列实现
  - 从桶中取数的时候是先进去的先出，后进去的后出，这也就是说是一个队列的形式

- 八种排序算法的对比

## 树结构

### 树结构概述

- 什么是树结构
  -  自己想象一下，如果这个都想不出来那就别学数据结构了
- 为什么要使用树结构
  - 前面的线性存储查找性能以及插入性能不太好，数组倒是好查找，但是不好插入，队列插入容易，但是不好查找，所以我们使用树结构
- 树结构的基本概念
  - 根节点
    - 所有节点由这个节点引申
  - 双亲节点
    - 想象家里的族谱，或者传销的上限
  - 子节点
    - 与双亲节点相对
  - 路径
    - 一个节点到另一个节点的所要经过的路
  - 节点的度
    -  一个节点有多少个子节点
  - 节点的权
    - 节点上的数字
  - 叶子节点
    - 没有子节点的节点
  - 子树
    - 一个节点本身也能当一个树的节点
  - 层
    - 最靠近根节点的为第一层，接着是第二层 。。。
  - 树的高度
    - 最大的层数
  - 森林
    - 多个数共同组成

### 二叉树

#### 什么是二叉树

- 任何一个节点的子节点的数量不超过二
- 二叉树的几种形态
  - 空树
  - 左斜树，右斜树
  - 还有其他形态
- 二叉树的子节点分为左节点和右节点，顺序不能颠倒，即使一个二叉树的两个子节点的权一样，但是左右不一样那也是不一样上的二叉树
- 满二叉树：所有叶子节点都在最后一层，而且节点的总数为二的n次方-1，n是树的高度
- 完全二叉树：所有叶子节点都在最后一层或着倒数第二层，并且最后一层的叶子节点在左边连续，倒数第二节的叶子节点在右 边连续 

#### 链式存储的二叉树

-  创建二叉树
  - 创建的链式结构的一个节点包含左节点，数据，右节点
- 添加节点
  - 把左右节点赋上值，就创建好了
- 查找节点
  - 前序查找TODO
  - 中序查找TODO
  - 后序查找TODO
- 树的遍历，如果有一棵树，按照从根节点到最后一层的叶子节点，从左到右为每个节点排序，我们可以想象有一棵树，1234567
  - 前中后是相对于根节点的，使用递归思想
  - 前序遍历
    -  根左右，1 245 367
  - 中序遍历
    - 左根右，425 1 637
  - 后序遍历
    - 左右根，452 673 1
- 删除节点
  - 对于一个普通的二叉树，删除节点就是让父节点指向该节点的数据指向NULL就好了

#### 顺序存储的二叉树

- 什么是顺序存储的二叉树
  - 可以把任何一个数组转化成二叉树，也可以把任何二叉树转化成数组
  - 顺序存储的二叉树通常只考虑完全二叉树， 第n个元素的左子节点是二乘n加1，第n个元素的右子节点是二乘n加2，第n个元素的父节点是 (int)(（n-1） / 2 )，这是在数组中的位置计算
- 如何遍历
  - 以二叉树的方式遍历，前中后序遍历，只要将数组当成二叉树就行

#### 线索二叉树

- 什么是线索二叉树
  - 为什么要用线索二叉树
    - 对于一颗二叉树来说，如果我们想要查找一个数就要把它遍历一遍，而且并不是所有的二叉树节点都有左右子节点，所以会造成一些浪费
  - 线索二叉树就是说将二叉树节点的空的右子节点的地址，指向遍历方法的上一节点，将空的左子节点指向下一节点，按照这种方法，我们可以得到三种遍历方法的链表结构
  - 线索化二叉树时，一个节点的前一个节点叫做前驱节点，一个节点的后一个节点，叫做后继节点，要选择节点进行处理
- 遍历线索二叉树
  -  TODO

#### 赫夫曼树

- 赫夫曼树概述
  - 最优二叉树
    - 他是n个带权叶子节点构成的所有二叉树中，带权路径长度最小得到二叉树
  - 叶节点的带权路径
    -  从根节点出发经过多少节点的数量乘叶子节点的权值解释带权路径
  - 数的带权路径长度WPL
    -  weighted path length，树中所有叶子节点的带权路径长度之和
    - 权值越大的节点离根节点越近的二叉树才时最优二叉树
- 如何构建最优赫夫曼二叉树
  - 首先将数组进行排序，排序完成后取出最小的两个数作为一个二叉树的左右子节点，最小的两数之和为左右字节点的根节点，也是父节点，将根节点进行排序，继续按照上述方法构建二叉树，一次类推，最终所有的数都是最优赫夫曼二叉树的子节点，通过这种方法我们也得到了最优赫夫曼二叉树
- 赫夫曼树编码的概述
  - 应用于通信与数据压缩领域应用广泛
  - 定长编码
    - 比如：can you can a can as a can canner can a can
    - 转化为ASCII码--->在转换为0/1比特
  - 非定长编码
    - 首先结算每一个字符出现多少次，然后让出现的信息按照频率由高到低进行排序，将序号转换成二进制的值，这样做以后传输的数据就会短很多，为啥？因为高频出现的信息被编码成最短的二进制，二进制位数乘以信息频次在累加就知道要传输多少二进制比特了
    - 这样做以后在解码时并不知道怎么转换成信息，没有直接解码的方法
    - 理解一个概念：字符的编码都不能是其他字符编码的前缀，如果一个字符编码是其他字符编码的前缀，这种编码叫做前缀编码
    - 使用霍夫曼编码的思想我们可以将转换的二进制数转换为最优赫夫曼二叉树，字符出现的次数作为叶节点的权值，将左子节点路径标注为0，将右子节点路径标注为1，这样经过编码后的找到字符的路径就可以唯一的编码一个信息
    - what amazing happen！！！使用这种编码后就可以大大压缩信息比特，而且是无损压缩
- 赫夫曼编码实现
  - 统计字符数并排序
  - 创建赫夫曼树
  - 创建赫夫曼编码表
  - 编码信息
  - 使用赫夫曼解码
  - 文件的压缩与解压

#### 二叉排序树

- 为什么需要二叉排序树
  - 存储一段数据的方式
    - 线性存储 
      - 存储时排序：按顺序存储后进行查找时就比较方便，但是我们在插入或者删除时就比较麻烦
      - 存储时不排序：进行查找操作时需要进行从头到尾的遍历，所以查找比较困难
    - 链表存储
      - 无论排序还是不排序，在进行查找操作都比较麻烦，链式存储并不能直接找到某个数字
  - 由于上面所说的原因，所以二叉排序树就非常有用了
- 什么是二叉排序树BST
  - 对于二叉树中的任何一个非叶子节点，要求左子节点比当前节点值小，右子节点比当前节点值大，空树也可以认为他是二叉排序树
  - 插入删除方便，查找是无论查找哪一个元素效率都差不多
-  创建二叉排序树
  - 添加节点TODO
  - 查找节点TODO
  - 删除节点TODO（情况比较多）
    - 删除叶子节点，直接删除就行
    - 删除只有一个子节点的元素，删除后让字节点继承父节点
    - 删除拥有两个字节的元素吗，找到后继节点和前驱节点，两种情况：1，让后继节点代替删除元素；2，删除元素后继节点有子节点，先操作1，然后让后继节点的自节点继承后继节点

#### 平衡二叉树（AVL树）

- 为啥要二叉平衡树
  - 如果将有一个顺序的数组装换成二叉排序树，就会是一颗右斜树，这样查找某一个节点时就比较复杂，比单链表还要复杂一些，这时候就需要平衡二叉树
- 什么是平衡二叉树
  - 左子树和有姿势的高度差的绝对值不超过1，这样改善了二叉排序树的查找时的缺点
  - 左子树和右子树也时平衡二叉树
- 建立一个平衡二叉树所要考虑的各种情况
  - 旋转1次，左旋转
  - 旋转2次，左右旋转，先左后右 

#### 多路查找树

- 计算机的存储
  - 内存是电信号存储，速度快，掉电丢失
  - 磁盘是存在扇区中，机械读取
  - 并不是按需读取，每次都是预读，一般多预读也的整数倍，以页的单位进行读取和存储操作
  - 说这个是因为文件系统及数据库系统的设计者利用了磁盘于都原理，将一个节点的大小设为等于一页，选择这个节点每次只需要一次I/O就可以完全读入
  - 二叉树的问题是：当数据量非常大的时候，树的高度会非常高，并不能把一个数据全部放在内存中，会把一部分数据放在硬盘中，每一次读取一个节点的值，这样会造成读次I/O操作，非常耗时，所以我们使用B树解决这个问题
- 什么是B树
  - 二三树
    - 有两个子节点的节点叫二节点，也就是普通的节点，即一个数据，两个地址，二节点要么有两个子节点，要么没有子节点
    - 有三个子节点的节点叫三节点，两个数据，三个地址，三节点要么有三个子节点，要么没有子节点
    - 所有叶子节点必须在同一层
  - 二三四树
    - 类比于二三树
  - B树
    - B树的阶：节点中最大的节点，就是B树的阶
    - 比如，二三树是三阶的B树，二三四树是四阶的B树
    - 实际应用中B树的阶可能非常大，比如1024阶，等 
  - B+树
    - 非叶节点只存储索引信息，不存储数据
    - 叶子节点最右边的指针指向的是下一个相邻的叶节点
  - 有啥优势？
    - mysql数据库中，两种引擎分别就是B树和B+树
    - B+树在内存中通过索引可以快速查找到数据，各有优缺点

## 哈希表 

#### 哈希表概述