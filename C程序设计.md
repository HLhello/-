## Cha1 程序设计和C语言

1. 机器语言，汇编语言，低级语言，高级语言

2. 非结构化语言，结构化语言，面向对象的语言，面向过程的语言

3. 编译器，编译过程，源程序，目标程序，可执行程序

4. C语言特点，优点劣势

5. 三个程序

   ```c
   #include<stdio.h>
   int main()
   {
       printf("This is a c program");
       return 0;
   }
   ```

   ```c
   #include<stdio.h>
   int main()
   {
   	int a,b,sum;
   	a = 123;
   	b = 456;
   	sum = a+b;
   	printf("sum is %d\n",sum);
   	return 0;
   }
   ```

   ```c
   #include<stdio.h>
   int main()
   {
   	int max(int x,int y);
   	int a,b,c;
   	scanf("%d,%d",&a,&b);
   	c = max(a,b);
   	printf("max = %d\n",c);
   	return 0;
   }
   int max(int x,int y)
   {
       int z;
       if(x>y) z = x;
       else z = y;
       return z;
   }
   //行注释方法
   /*
   	段落注释方法
   */
   ```

6. 程序分析

- main是表示主函数，并且是主函数的名字，在3中的max也是函数名，一个程序中只能有一个主函数，并且在主程序中必须有一个主函数

- C语言程序的语句必须使用“;”结尾，某些语句比较特殊，如循环语句ifelse语句，switch语句

- main前面的int是函数返回值的类型，

- “\n”是换行符
- “%d”指定输出格式，d表示十进制，x表示十六进制，o表示八进制p表示地址格式

- stdio.h----> standard input & output 的缩写，.h的意思是头文件(header file)

- 函数首部

  | int      | max    | (    | int      | x      | ,      | int      | y      | ）   |
  | -------- | ------ | ---- | -------- | ------ | ------ | -------- | ------ | ---- |
  | 函数类型 | 函数名 |      | 形参类型 | 形参名 | 分隔符 | 形参类型 | 形参名 |      |

- 函数体：用“{}”花括号包起来的就是函数体，包括声明部分和执行部分
- 预处理指令，前面带“#”的都是预处理指令，常见的有include加载头文件，define宏定义
- include<系统文件>，include"自定义文件"
- 全局声明，将变量在函数之外的数据声明，例如将2的程序中的 "int a,b,sum;"放在main函数之前；在函数外面声明的变量称为全局变量，由于C语言的编译是从上向下的，所以讲全局声明放在函数开始之前才可以使用，否则不能使用
- 程序总是从main开始执行的，执行到return程序停止

7. 运行c程序的方法和步骤

- 源程序.c ---> 编译 ---> 目标程序.obj ---> 链接库函数和其他目标程序 ---> 可执行文件.exe

## Cha2 算法——程序的灵魂

1. 数据结构：对数据的描述，在程序中要指定用到哪些数据以及这些数据的空类型和数据的组织形式
2. 算法：对操作的描述，要求计算机进行操作的步骤
3. 算法 + 数据结构 = 程序
4. 例子

- 等差数列求和
- 闰年计算
- 找出求和规律，利用循环求和
- 判断一个数是不是素数（prime）

5. 算法的特性，不一定有输入，却一定有输出

- 有穷性
- 确定性
- 有零个或多个输入
- 有一个或多个输出
- 有效性

6. 表示算法——流程图（起止框 = 圆角，输入输出框 = 平行四边形，判断框 = 菱形，处理框 = 矩形）
7. 三种基本结构

- 顺序结构，选择结构，循环结构（当型while，直到型until）

- 当型结构先判断再执行，直到型结构先执行在判断

  注：略过N-s图与流程图功能一样，伪代码没没有

8. 结构化程序设计方法

- 自顶向下，逐步细化，模块化设计，结构化编码
- 划分模块时，注意模块的独立性，尽量使模块之间的耦合度降低

## Cha3 顺序程序设计

1. #### 转化温度

```c
#include<stdio.h>
void main()
{
    float F,c;
    scanf("F = %f", &F);//scanf中只能有%f，如下面所示
    c = 5/9*(F-32);//   5/9不行，类型不同，5是整数，9是整数，做除法会出问题，如下所示
    printf("c = %f", c);
}// 若程序没有返回值，函数类型可以是void，不写return语句；也可以是int返回值为0

#include<stdio.h>
int main()
{
    float F,c;
    scanf("%f", &F);
    c = (5.0/9)*(F-32);
    printf("F = %f, c = %f", F, c);
	return 0;
}

#include<stdio.h>
int main()
{
    float F;
	int c;
    scanf("%f", &F);
    c = (F/9);
    printf("F = %f, c = %d", F, c);
	return 0;
}
```

2. #### 计算存款利息

```c
#include<stdio.h>
int main()
{	
	float r1 = 0.0036;
	float r2 = 0.0225;
	float r3 = 0.0198;
	
	float p0,p1,p2,p3;
	
    scanf("%f", &p0);
    
    p1 = p0*(1+r1);
    p2 = p0*(1+r2);
    p3 = p0*(1+r3/2)*(1+r3/2);
    
    printf("p1 = %f\n, p1 = %f\n, p1 = %f\n", p1, p2, p3);
    
    return 0;
}
```

3. #### 数据的表现形式及其运算

- ![常量](https://github.com/HLhello/LearningNotes/blob/master/picture/常量.jpeg)

- **常量**，在程序的运行过程中，其值不能被改变的量称为常量。
  - 常量包括整型常量，实型常量，字符常量，字符串常量，符号常量
  - 实型常量有两种。
    - 十进制小数形式，如123.456；
    - 指数形式，如12.34e3 = 12.34*10^3 = 12340,e之前必须有数字
  - 字符常量有两种。
    - 普通字符，用单引号括起来的一个字符，如 ' A '，' a ',  ' # ',  ' 3 ' ' ? ' ;注意一对单引号只能包括一个字符
    - 转义字符,一种特殊的字符常量，以 " \ " 开头的字符序列，将 “ \ ” 后面的字符转换成另外的意义
  - 字符串常量：用双撇号将若干字符括起来，字符串常量是双撇号中的全部字符但不包括双撇号本身；如”china“，”12345“。
    - 注：双撇号可以包括单个字符，但是单撇号之能包含一个字符
  - 符号常量：用#define指令指定一个符号名称代表一个常量，如   #define PI 3.1415926
    - #与define，define与符号名称，符号名称与常量，可以有任意个空格
    - 符号名称不与关键字重名，常量可以是任何想要替换的常量，注意结尾没有“；”
    - 定义符号常量可以在函数体内，也可以在函数体外，只要在调用之前就行
    - 定义符号名称要做到见名知意，在多处使用到符号变量时，使用该定义可以做到一改全改，所以要放在函数开始的地方
- **变量**：在程序运行期间，**<u>变量的值</u>**可以改变。
  - 变量名，存储单元，存储单元地址，变量值
    - 注：在计算机中最小的存储单元是字节byte，一个字节8个bit，为每个字节顺序编码，编码称为地址
  - 变量代表一个有名字的，具有特定属性的一个存储单元。这个存储单元用来存放数据，也就是变量的值
  - <u>变量必须先定义后使用</u>！
  - 在定义时指定该变量的类型，名字 ，对内存空间可以初始化，也可以不初始化，也就是给不给最初的变量值
  - 变量名，存储单元地址都是标记存储单元在内存中的位置
- **常变量** 变量存在期间其值不能改变
  - 例子： const int a = 3;//定义了一个常变量
  - 常变量的属性：有类型，占存储单元，只是不允许改变其值
  - 常变量与常量辨析
    - 常变量是有名字的不变量，常量是没有名字的不变量，有名字便于在程序中被引用
    - 常量是不能当做左值（不能放在等号的左边）
  - #define PI 3.14159  与  const float PI = 3.14159  的区别
    - 前者是预编译指令，不分配内存空间，在编译是进行字符替换，在编译后不存在PI（全部被替换成3.14159）
    - 后者占用存储单元，有变量值，只是该值不改变
    - 后者具有前者的优点，可以不多用前者，在内存空间上前者有一定优势，但是以现在的硬件来看，优势不大
- **标识符** ：标识符就是一个对象的名字，标识符的命名规则，字母数字下划线，数字不开头

4. #### 数据类型

- ![数据类型](https://github.com/HLhello/LearningNotes/blob/master/picture/数据类型.jpeg)

- 不同类型的存储内存及方式

| 类型（字节） | 16位平台 | 32位平台 | 64位平台 |
| :----------: | :------: | :------: | :------: |
|     char     |    1     |    1     |    1     |
|  short int   |    2     |    2     |    2     |
|     int      |    2     |    4     |    4     |
|    float     |    4     |    4     |    4     |
|    double    |    4     |    8     |    8     |
|     long     |    4     |    4     |    8     |
|  long long   |    \     |    8     |    8     |
|     指针     |    2     |    4     |    8     |



- 在存储单元中的存储方式是使用整数的补码方式进行存储

  - 注：理解 <u>原码，反码，补码</u>，数电知识

- **整形变量**的符号属性  注：不包含double 和float

  - 只有整形数据（包括字符型）可以加signed和unsigned修饰，实型数据不能加
  - 定义时类型前面有【unsigned】 就是无符号类型，类型前面有【signed】就是有符号的类型
  - 若没有指定signed或者unsigned，则默认是有符号类型
  - 无符号整形十进制数据用“%u”格式输出，有符号十进制数据用“%d”输出
  - 定义时根据编译器所分配的字节数以及有无符号就可以计算出整形类型所能存储的最大值和最小值
  - unsigned 类型：只有正数没有负数；signed 类型：有正数也有负数
  - 若定义为无符号类型，则不能对其赋负值

- **字符型数据** 注：整数类型的一种

  - 字符变量就是用类型符char定义字符变量，使用“%c”输出字符变量

  - 在内存中是按照代码（整数）的形式存储的

  - 定义带符号的char类型是，最好带上signed

  - ```c
    signed char num = -6;
    char c = '?';
    printf("%c,%d",c,c); -->输出 ？，63
    ```

- **浮点型数据**

  - 浮点型数据是用来表示具有小数点的实数的，在C语言中，实数以指数形式存储在内存中

  - 注：为什么叫做浮点数？

    - 一个实数表示为指数可以有不止一种形式，如3.14159，可以表示为
      $$
      3.14159 * 10^0，0.314159 * 10^1，0.0314159 * 10^2 ...
      $$

    - 代表同一个值，却可以有不同的表现形式，只要小数点浮动的同时改变指数上的值，就可以保证表示的数字不变，由于小数点位置可以浮动，所以实数的指数形式称为浮点数

    - 规范化的指数形式，一个实数只有一个规范化的指数形式
      $$
      实数：3.14159 ==>规范化存储： 0.314159 * 10^1 ==>指数形式输出：0.314159e001
      $$

  - 在存储时，系统实型数据分成小数部分和指数部分，分别存放。小数部分小数点前面的数是0

  - 计算机中，使用二进制数表示小数部分，使用2的幂次表示整数部分

  - 可以表示的实数范围：最大的负实数到最小的负实数，零，最小的正实数到最大的正实数

  - float以及double的字节大反映了程序的精度

- 没有小数点的数值就是整形常量，以小数形式或指数形式出现的实数是浮点型数据

4. #### 运算符和表达式

- 基本算数运算符
  - 单目正号运算+，单目负号运算-
  - 加减乘除取余，分别表示为+，-，*，/，%

- 自增（+ + i）自减（- - i）运算

  - 注：只能用于变量，不能用于常量或者表达式，例如：5++或者（a+b）++都是不合法的

  - ```c
    //++i；--i；在使用之前先自增（减）
    //i++；i--；在使用之后再自增（减）
    int i = 3;
    j = ++i;
    printf("j = %d",j);//输出 j = 4
    j = i++;
    printf("j = %d",j);//输出 j = 4
    printf("i = %d",--i);//输出 i = 4
    printf("i = %d",i--);//输出 j = 4
    ```

- 算数表达式与运算符的优先级与结合性

  - 优先级：（）括号的优先级最高，若不清楚，使用括号来表示优先级
  - 结合性：C语言中算数表达式普遍是由左到右结合

- **不同类型数据间的混合运算**

  - 在程序中，经常会遇到不同类型的数据进行运算，如果一个运算符两侧操作数（运算对象）的数据类型不同，自动进行类型转换，使而知具有同一种类型，然后运算

  - **因此**，整型，实型，字符型数据可以进行混合运算

  - 混合运算时，类型转换的原则知道就行，自动转换，用户无需过问

  - ```
    #include<stdio.h>
    void main()
    {
    	char c1,c2;
        scanf("%c",&c1);
        c2 = c1+32;
        printf("\n%c",c2);
        printf("\n%d",c2);
    }
    ```

- 强制类型转换：（类型名）（表达式）

  - （double）a；（将a转换成double类型）
  - （int）(x+y)；（将（x+y）转换为int类型）

  - ```c
    int a;
    float x = 10.5;
    a = (int)x;
    printf("%d,%f",a,x);//输出结果为 10,10.5
    //证明使用强制类型转换时产生中间变量，将中间变量赋值给a，x的值并不会发生改变
    ```

- C运算符

5. #### C语句

- ![c语句](https://github.com/HLhello/LearningNotes/blob/master/picture/C语句.jpeg)
- 赋值语句
  - 赋值运算符，=
  - 复合赋值运算符，+=，-=，*=，/=，%=
    - 注：x%=（y+3）==> x = x %（y+3）
  - 赋值表达式
    - 变量（左值） 赋值运算符 表达式
    - 左值是一个可以修改的变量，不能是常量或者表达式
    - 可以连等，但不建议使用，C语言一行语句只干一件事
  - 赋值过程中的类型转化
    - 在赋值运算符的两侧类型不一致，在赋值是时动进行类型转换
    - 占字节多的整形数据给占字节少的整形数据或者字符变量赋值时，只将其低字节原封不动的送到被赋值的变量
    - 浮点型数据赋值给整型变量时，舍弃小数位，只赋整数
    - double型赋值给float时，进行精度转换，若超出了界限，就会出现错误
    - 注：C语言使用灵活，赋值时不同类型转换会出现失真，在进行赋值时要多加注意，否则输出结果可能有问题
  - 变量赋初值
    - 在赋值时初始化变量，也可以不初始化，单不允许使用连等来初始化变量

6. #### 数据输入与输出——详解printf与scanf

- 相关概念
  - 输入出处是以计算机为主体而言的
  - C语言本身不提供输入输出语句，输入输出操作是有C标准函数库中的函数来实现的
  - C语句中不包含输入输出函数，目的是使编译系统简化且通用性强
- printf函数——printf（参数1，参数2，参数3，...，参数n）
  - 参数1位格式控制，参数2~参数n是要输出的参数列表
  - printf（“a=%d，b=%f”，a，b）
  - printf（格式控制，输出列表）
    - 格式控制是使用双撇号包起来的一个字符串，包含两个信息，格式声明，普通字符
      - 格式声明总是以“%”字符开始的，后面跟格式字符，例如：d（十进制），x（十六进制）等等
      - 普通字符即需要在输出是按照原样输出的字符
    - 输出列表是程序需要输出的一些数据
  - 格式字符：d，c，s，f，e，x，. . . 
  - 域宽（所占的列数），“%-5d”，“%5.2f”— “-” 表示向左对其，整数就是输出所占的列数（5），浮点数就是小数位数（2）+整数位数（3）=所占列数（5）
  - 注：printf函数输出时，务必注意输出对象的类型与上述格式说明匹配，否则出现错误
  - 注：格式控制中可以包含转义字符
  - 注：格式字符表，附加字符表，转义字符表自行百度用法
- scanf函数——scanf（参数1，参数2，参数3，...，参数n）
  - 参数1是格式控制，参数2~参数n是变量的地址，不是变量名
  - 格式控制与printf含义相似，地址列表是有若干个地址组成的列表，可以使变量的地址，也可以是字符串数组的首地址
  - 在格式控制字符串中除了格式声明以外还有其他字符（对应printf中的普通字符），则在输入数据时在对应得位置上应输入相同的字符，
- 字符数据的输入输出putchar()，getchar()，...

## Cha4 选择结构程序设计

## Cha5 循环结构程序设计

老生常谈的问题，在此就不说了，这两章主要还是讲的分支循环，任何一门语言的必修课，只是写法不一样，其他大同小异，主要是分支循环的思想，以及如何利用

## Cha6 利用数组处理批量数据

- 数组是一组有序数据的集合，用一个数组名和下标可以唯一的确定数组中的元素，数组中每一个元素都属于同一个数据类型

- 定义一维数组：

  - <u>**类型符 数组名[常量表达式]**</u>；

    - 常量表达式表示数组的长度，只有在定义时是这样，常量表达式可以是常量和符号变量，也可以包含常量的运算，却不能是变量

    - ```c
      int n;
      scanf("%d",&n);
      //int a[n]//这种方法是错误的
      可以使用malloc或者calloc以及realloc来定义一个动态数组
      int *p = (int *)malloc(sizeof(int)*n);
      int *px = (int *)calloc(n,sizeof(n));
      ```

    - 注：如果在被调用函数中定义数组，其长度可以是变量或非变量

      - ```c
        void func(int n)
        {
            int a[2*n];//合法
            . . . 
        }
        ```

- 引用数组时，只能引用数组元素而不能一次整体调用整个数组全部元素的值

- 一维数组初始化

  - ```c
    1.
    int a[5] = {1,2,3,4,5};
    2.
    int a[5] = {1,2.3}; ==>a[5] = {1,2,3,0,0};
    3.
    int a[] = {1,2,3};==>int a[3] = {1,2,3};
    4.
    for(int i=0;i<5;i++)
    {
        a[i] = i+1;    
    }
    //初始化时数据的长度确定，没有指定每个数据的初值，则在后面的补零，如2
    //初始化时数据的个数确定，可以不指定数据的长度，如3
    //初始化时长度和个数必须有一个被指定，否则出错
    
    ```

- **冒泡排序法**，每次将相邻的两个数比较，将较小的数放在前面，如此循环，当比较过n-1次之后，最大的数沉底，将剩下的n-1个数进行第二次比较，经过n-2次循环，第二大的数沉底，如此循环，直到剩下两数，比较之后就可以得到从小到大的排序

- **二位数组**，二维数组也就是矩阵

  - 类型说明符 数组名[常量表达式)(常量表达式]

- C语言对二维数组的定义时排列在一起的几行一维数组

  - ```c
    int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
    a[0] 代表二维数组的第一行，也就是一个一维数组的名字
    ```

  - 用矩阵形式定义二维数组，是逻辑上的概念，能形象的表示出行列关系，而在内存中，各元素是连续存放的，不是二维的，是线性的，最左边的下标变换最慢，右边的下标变化快

- 二维数组引用比较复杂，与指针在一起说

- 二维数组的初始化

- ```c
  int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
  int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
  int a[3][4] = {{1,2},{0,6}}; ==>int a[3][4] = {{1,2,0,0},{0,6,0,0},{0,0,0,0}};
  int a[][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12};
  int a[][4] = {{1,2},{0,6},{}};==>int a[3][4] = {{1,2,0,0},{0,6,0,0},{0,0,0,0}};
  for(int i=0;i<3;i++)
  {
      for(int j=0;j<4;j++)
      {
      	a[i][j] = i+j+1;       
      }
  }
  ```

- **字符数组** 

  - char 字符数组名[常量表达式]

  - 初始化字符数组

    - 

    ```c
    char c[10] = {'I',' ','a','m',' ','h','a','p','p','y'};
    char daimond[5][5] = {{'I'},{'a','m'},{'h','a'},{'p','p'},{'y'}};
    //或者使用下面的方法
    ```

    - 

    ```c
    #include<stdio.h>
    #include<stdlib.h>
    
    void main()
    {
    	char c[] = "I am a boy";
    	int i = 0;
    	while (c[i] != '\0')
    	{
    		printf("%c", c[i]);
    		i++;
    	}
    	system("pause");
    }
    ```

- 字符串和字符串结束的标志

  - '\0'代表ASCII码为0的字符，从ASCII码表中可以查到，ASCII码为0的字符不是一个可以显示的字符，而是一个空操作符，也就是他什么也不做，用它来作为字符串结束标志不会产生附加的操作或增加有效字符，只起到一个辨识的作用

  - 在C语言中，是将字符串作为字符数组来处理的，在实际工作中人们往往关心的是字符串的有效长度，而不是字符数组的长度，为了测定字符串的实际长度，C语言规定了了一个字符串结束标志，以'\0'作为结束的标志，也就是说在遇到字符'\0'时，表示字符串结束，把前面的字符组成一个字符串

  - C系统在用字符数组存储字符串常量时会自动加上一个'\0'作为结束符

  - 在程序中往往依靠检测'\0'来判断字符串是否结束，而不是根据数组的长度来决定字符串的长度，在定义字符数组时，应该估计字符串的长度，保证数组长度始终大与字符串的长度

  - ```c
    1.char c[] = {'I',' ','a','m',' ','h','a','p','p','y'};
    2.char c[] = {"I am happy"};
    3.char c[] = "I am happy";
    4.char c[] = {'I',' ','a','m',' ','h','a','p','p','y','\0'};
    注：2,3,4等价，1,4不等价，1的长度为10,4的长度为11
    ```

  - 对于'\0'，如果定义时规定了字符数组长度，并且初始化时全部被赋值，也就是没有'\0'的位置，系统在存储时会自动加上'\0',长度不变，如果没有规定字符数组的长度，初始化时也没有在最后加上'\0'，那么字符的长度是1的情况，存储时还是会加上'\0'，不改变字符数组的长度，还有就是4的情况，会把字符数组长度加1

- 注：在使用scanf为字符串赋值时，不用'&'

  - ```c
    scanf("%s",str);
    ```

- 字符串处理函数

  - gets（字符数组）——接受一个str字符数组

  - puts（字符数组）——输出str字符数组

  - strcat（字符数组1，字符数组2）——字符串连接数组

    - 把字符串数组2接在字符数组1后面，结果放在字符数组1里面

  - strcpy（字符数组1，字符串2）——字符串赋值函数

    - 将字符串2复制到字符数组1中去，字符数组1的长度至少要大与字符串2

    - 将字符串全部复制，并且包含最后的'\0'，从在字符数组1的头开始，复制完成后，字符数组1后面几位不变

    - 不能使用赋值语句将一个字符串常量或者字符数组直接给一个字符数组

      - ```c
        str1 = "China"；//不合法
        str1 = str2;//不合法
        ```

    - strncpy（str1，str2，2）——将str2中的前两个字符复制到字符数组1中去

  - strcmp（字符串1，字符串2）——字符串比较数据

    - 将两个字符串自左至右逐个字符比较，直到出现不同的字符或者遇到'\0'为止，比较的是ASCII码的大小
    - 两个字符串相等，返回值为1，str1>str2 返回值为正整数，str2>str1 返回值为负整数

  - strupr（字符串）——转换为大写的函数

## Cha7 用函数实现模块化设计

- 函数简明

  - 函数就是功能，每一个函数用来实现一个特定的功能，函数的名字应反映其代表的功能
  - 

  ```c
  #include<stdio.h>
  int main()
  {
  	void print_star();
  	void print_message();
  	print_star();
  	print_message();
  	print_star();
  	return 0;
  }
  void print_star()
  {
      printf("**************\n");
  }
  void print_message()
  {
      printf("How do you do!\n");
  }
  
  //定义print_star()函数以及print_message()函数在main函数后面，在这种情况下，应当在main函数之前或main函数开头的位置对两个子函数进行函数声明
  ```

  - 函数声明的作用是把有关函数的信息（函数名，函数类型，函数参数的个数以及类型）通知编译系统，以便在编译系统对程序进行编译是，在进行到main函数调用子函数时知道他们是函数而不是变量或其他对象
  - 函数不能嵌套定义，函数可以互相调用，一个程序只能有一个main函数，可以有多个子函数，子函数与主函数可以在一个文件里也可以不在一个文件里

- 定义一个函数，无参函数，有参函数

  - 定义函数包括四个内容，指定函数的名字，指定函数的类型，指定函数的参数的名字和类型，指定函数完成的功能

  - ```c
    类型名 函数名（）
    {
        声明部分...
        语句部分...
    }
    类型名 函数名（形式参数列表）
    {
        声明部分...
        语句部分...
    }
    ```

- 调用函数

  - 形式参数：在定义函数时，函数名后面括号中的变量名称为形式参数
  - 实际参数：在主函数中调用一个函数时，函数名后面括号中的参数称为实际参数
    - 实参可以是常量，变量，表达式
  - 在定义函数中指定的形参，在未出现函数调用时，并不占内存，在发生函数调用时，函数的形参被临时分配内存单元
  - 将实参的值传递给形参，这是单向的值传递，利用形参进行有关的计算
  - 利用return语句将函数值带回主调函数
  - 调用结束，形参单元被释放，实参单元仍然保留原值

- 函数的返回值

  - 函数的返回值是通过函数中的return语句获得的
  - 一个函数可以有一个以上的return语句，执行到哪一句，将那一句的值返回
  - return后面的值可以是一个表达式
  - **函数类型决定返回值的类型**，在定义函数时，指定的函数类型一般应该和return语句中的表达式类型一致
  - 对于不带返回值的函数，应当定义为void类型

- 在一个函数中调用另一个函数的条件

  - 首先被调用的函数必须是已经定义的函数，是库函数或者用户自己定义的函数
    - 库函数应当在文件开头使用#include指令将有关库函数包含进来
    - 对于自己定义的函数，被调用函数在主调函数后面，则应该在主调函数中对被调用的函数做声明；
    - 如果在函数的开头对函数进行了声明，则在主调函数中不用声明——这种做法称为外部声明。写在所有函数前面的函数声明对整个函数有效
    - 在a函数中调用b函数，在b函数中调用c函数，c函数的证明放在b函数中，b函数的声明放在a函数中，可以，不用换在a中重复声明

- 函数首部，函数原型，声明，函数首行

  - 注：函数定义与函数声明不是一回事，函数声明就是把函数的基本信息传递到主调函数中，函数的基本信息包含在函数首行中；函数定义是对函数功能的确立，是一个完整的函数单位

- 函数的执行顺序——函数不能嵌套定义，能嵌套执行

- TODO：插图

- **递归调用**——在调用一个函数的过程中，有出现直接或间接的调用该函数本身，称为函数的递归调用

  - 程序中不应该出现无终止的递归调用，需要控制递归调用的次数

  - 包括两个阶段，回溯和递推

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    
    void main()
    {
    	int jiecheng(int n);
    	int n, x;
    	scanf("%d", &n);
    	x = jiecheng(n);
    	printf("\n%d! = %d",n, x);
    	system("pause");
    }
    int jiecheng(int n)
    {
    	if (n == 1|| n==0)
    	{
    		printf("\n%d", n);
    		return 1;
    	}
    	else
    	{
    		printf("\n%d", n);
    		return n*jiecheng(n - 1);
    	}
    	
    }
    ```

  - **汉诺塔**

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    
    void main()
    {
    	void heshang(int n, char one, char two, char three);
    	int m;
    	scanf("%d", &m);
    	heshang(m,'A', 'B', 'C');
    	system("pause");
    }
    void heshang(int n, char one, char two, char three)
    {
    	void move(char x, char y);
    	if (n == 1)
    	{
    		move(one, three);
    	}
    	else
    	{
    		heshang(n - 1, one, three, two);
    		move(one, three);
    		heshang(n - 1, two, one, three);
    	}
    }
    void move(char x, char y)
    {
    	printf("%c-->%c\n", x, y);
    }
    ```

- 数组作为函数参数

  - 数组名可以做实参和形参，传递的是数组第一个元素的地址

  - 数组元素可以用作函数实参，不能用作形参

    - 应为形参是函数被调用时临时分配的存储单元，不能作为一个数组元素单独分配存储单元

    - 数组是一个整体，在内存中连续的占一段存储单元

    - ```c
      #define _CRT_SECURE_NO_WARNINGS
      #include<stdio.h>
      #include<stdlib.h>
      
      void main()
      {
      	int a[10];
      	for (int i = 0; i < 10; i++)
      	{
      		scanf("%d", &a[i]);
      		//printf("\n");
      	}
      	for (int i = 0; i < 10; i++)
      	{
      		printf("%d\n",a[i]);
      	}
      	system("pause");
      
      }
      
      ```

  - 用数组元素做实参时，向形参变量传递的是数组元素的值，而用数组名做函数实参，向形参传递的是数组首元素的地址

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    
    void main()
    {
    	float aver(float score[10]);
    	float a[10];
    	for (int i = 0; i < 10; i++)
    	{
    		scanf("%f", &a[i]);
    	}
    	for (int i = 0; i < 10; i++)
    	{
    		printf("%f  ", a[i]);
    	}
    
    	printf("\n%f", aver(a));
    	system("pause");
    }
    float aver(float score[10])
    {
    	float avers = 0;
    	for (int i = 0; i<10; i++)
    	{
    		avers = avers + score[i];
    	}
    
    	return avers / 10;
    }
    ```

  - 用数组名作为参数，应该在主调函数和被调函数分别定义数组，分别在其中一方定义，不能只在一方定义

  - 实参数组与性参数组类型一致，如果不一致，将会出错

  - 在定义被调用函数是，形参列表里的数组定义其大小不起任何作用，在被调用时，只是将只是将实参数组的首元素地址传给形参数组名，形参数组首元素与实参数组首元素地址相同，指向同一内存单元，所以形参数组可以不指定大小，

  - 编译时将形参数组名处理为一个指针变量，用来接收一个地址

  - 注意，由于没有副本机制（在形参不是数组的情况下，会直接拷贝变量），是直接对内存进行操作，形参和实参的数组在内存中是同一个，所以在执行被调函数时对数组的改变会直接将内存的数组也一同改变，执行完被调函数后，在主调函数中的数组也会改变

- 关于二维数组在学习完指针后做详细分析

- 局部变量和全局变量（从变量的作用域分析）

  - **局部变量**：在一个函数内部定义的变量只在该函数内有效，即只有在本函数内才能引用他们，在函数外部不能引用。在函数复合语句内定义的变量只有在复合语句内有效，在复合语句外无效

  - 在函数中定义的局部变量可以在该函数的复合语句内引用

  - **全局变量**：在函数之外定义的变量称为外部变量，外部变量是全局变量，其**有效范围**为从定义变量的位置开始到本源文件结束，全局变量可以为本文件中其他函数所共有

    - 设置全局变量增加了数据间通信的渠道，同一文件中所有函数都能引用全局变量的值
    - 全局变量在程序执行过程中都占用存储单元，他使函数的通用性降低了，函数之间的耦合度上升

  - ```c
    int p = 1,q = 5;//全局变量
    int main()
    {
    	float func(float f)；函数声明
    	int a；
    	float b;//a,b可以在复合语句块中使用
    	a = p+q;//全局变量
         .
    	 .
    	 .
        {
          int c;//c只在此复合语句块内有效
          a = p+q;
          c = a+b;
           .
           .
           .
        }
        
        func（b）
        
        return 0
    }
    
    float func(float f)
    {
    	float x； 
    	x = （float）p+q；//全局变量
        return x；
    }
    ```

  - 注意辨析下面程序

    - ```c
      #include<stdio.h>
      #include<stdlib.h>
      int a = 3, b = 5;//定义全局变量
      void main()
      {
      	int funcmax(int a, int b);//声明函数
      	int a = 8;//定义局部变量
      	printf("%d", max(a, b));
      	system("pause");
      }
      int funcmax(int a, int b)//定义形参
      {
      	int c; //定义max函数内的局部变量
      	c = a>b ? a : b;
      	return c;
      }
      ```

- 动态存储方式和静态存储方式（从变量的生存期来分析）

  - 静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式

  - 动态存储方式是指在程序的运行期间根据需要进行动态的分配存储空间的方式

  - 内存中用户区分为三块：程序区，静态存储区，动态存储区
    - 全局变量放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就就释放
    - 在动态存储区中存放函数形式参数，函数中定义的没有用关键字static声明的变量，即自动变量，函数调用时的现场保护和返回地址

  - 在C语言中，每一个变量和函数都有两个属性，数据类型和存储类型。存储类型已经讲过，存储类别值得是数据在内存中的存储方式（如动态存储和静态存储）

  - ###### TODO插图

  - 在定义和声明变量和函数时 ，一般应同时制定数据类型和存储类别，也可以采用默认方式指定（系统隐含的指定为某一种存储类别）

  - C语言的存储类别包括四种：分别是——**自动的（auto），静态的（statis），寄存器的（register），外部的（external）**

    - **自动变量**存储于动态存储区中，一般不用专门声明，静态局部变量存储于静态存储区，一般不用，会使程序变得难懂，寄存器变量存储在CPU的寄存器中，一般不用专门声明

    - 自动变量：函数中的局部变量，如果不专门声明为static静态存储类别，都是动态的分配存储空间，数据存储在动态存储区中，形参，函数中定义的局部变量，复合语句定义的局部变量，都是自动变量，一般不用进行声明，可以省略，不写auto，隐含指定为自动存储类别

    - **静态局部变量**（static局部变量）：局部变量的值在函数掉用完成后不消失而继续保留原值，也就是说这个变量占用的存储单元不释放，但依旧是局部变量，不能再其他函数中使用

    - ```c
      #include<stdio.h>
      int main()
      {
      	int func(int a);//函数声明
      	int a = 2, i;
      	for (i = 0; i<3; i++)
      	{
      		printf("%d\n", func(a));//输出（a+b+c）
      	}
      	system("pause");
      
      	return 0;
      	
      }
      int func(int a)
      {
      	auto int b = 0;//自动局部变量，自动变量在动态存储区
          //动态变量赋初值，不是在编译时进行的，是在函数调用时进行的，调用结束后，释放掉，每调用一次函数重新给一次初值，相当于执行一次赋值语句
          //若没有赋初值，他就是一个不确定的值
      	static c = 3;//静态局部变量静态局部变量属于今天存储类别，在静态存储区内分配存储单元
          //静态局部变量是在编译时赋初值的，即只赋初值一次，
          //若没有赋初值，编译时自动赋初值0，或者空字符
          //调用结束后变量仍然存在，但是不能被其他函数引用
      	c = c + 1;
      	return (a + b + c);
      
      
      }
      ```

    - **寄存器变量**：有一些变量使用非常频繁，为了增加程序运行的速度，执行效率，允许将局部变量的值放在cpu的寄存器中，不用再放到内存中，寄存器的存取速度远高于内存的存取速度，优化的编译系统能够自动识别，不需要指定

    - **全局变量**：作用的有效范围只限于定义处到文件结束，在定义点之前的函数不能使用该外部变量，如果要在定义点之前使用外部变量使用关键字**extern**

    - ```c
      文件1
      #include<stdio.h>
      int num；
      static int errornum;//称为静态外部变量，static将errornum限制在本文件中，该全部变量不能再其他文件中使用extern关键字声明
      //全局变量和静态全局变量都在静态存储区内存储
      int main()
      {
          int max();//函数声明
          extern int power(int n);//函数声明
          //由于power函数是在文件2中定义的，在文件1中引用时要加上extern声明
          //在对power函数进行声明时，要加关键字extern表示该函数是在其他文件中定义的外部函数
          int m,n;//定义局部变量
          extern A,B,C;//将在main函数后面定义的A,B,C的作用域扩展到从此处开始
          printf("please enter three integer numbers:")
          scanf("%d,%d,%d",&A,&B,&C);
          m = max();
          n = power(m);
          printf("max is %d",m);
          return 0;
      }
      static min()//static关键字说明这个函数是内部函数，静态函数，该函数只能被本文件引用，
      {
          ....
      }
      
      int A,B,C;//定义全局变量
      extern int max()//extern关键字说明该函数是以个外部函数，可以被其他文件调用，extern一般省略不写，C语言默认所有未进行静态声明的函数都是外部函数
      {
          int m;
          m = A>B? A:B;
          if(C>m) m=c;
          return(m)
      }
      //如果一个程序包含5个源文件，在其中一个文件中定义了全局变量，在其他四个文件中都能使用，但是在每一个文件都要加上extern声明一下
      //编译时遇到extern现在本文件中找该变量的定义，找不到，就在连接时从其他文件中找
      
      文件2
      extern num;//把文件1中已经定义的全局变量的作用域扩展到本文件
      //可以不指定类型
      int power(int n)//没有使用extern关键字，默认该函数为外部函数
      {
          int i,y = 1;
          for(i=1;i<=n;i++)
          {
              y*=num;
          }
          return(y);
      }
      
      ```

- 关于定义与声明

  - 函数包括两部分，声明部分和执行语句，被调用时先进行声明，在调用
  - 变量的定义与声明
    - 定义型声明（定义）：建立存储空间
    - 引用型声明（声明）：不分配存储空间

- 内部函数与外部函数

  - 内部函数，使用static特别声明
  - 外部函数，C语言默认函数都是外部函数，不用特别声明，当然也可以用extern声明

## Cha8 善于利用指针

- 指针的基本知识

  - 我们基本的要知道计算机的内存按照字节来进行编码，这个编码就是地址，也就是每个字节都有地址，而C语言中由于变量类型不同，不止一个字节，变量存储的地址是指这个变量的起始地址，而定义指针时给指针变量所赋的值就是变量在内存中的起始地址，如何解析这个地址是由指针类型所决定的，指针存储的地址和指针的类型共同决定指向变量的指针能否找到正确的变量

  - 直接访问：直接按照变量名进行的访问

  - 间接访问：把变量a的**地址**存放在另一个变量b中，然后通过变量b找到找到变量a的地址，从而访问变量a

  - 一个变量的地址称为该变量的**指针**，一个变量专门用来存放另一变量的地址则称他为**指针变量**

  - 指针是一个地址，指针变量是存放地址的变量

  - &取地址运算符，&a是a的地址

  - *指针运算符， *p是指针变量p指向的对象的值

  - 定义指针变量：  **类型名    * 指针变量名** 或者 **类型名  *指针变量名 = &变量**   在使用指针时一般要初始化

  - ```c
    #include<stdio.h>
    #include<stdlib.h>
    int main()
    {
    	char ch = 'A';
    	int num = 10;
    	float f = 8.888888;
    	double db = 8.88888888;
    	char *p_ch;
    	p_ch = &ch;
    	int *p_num = &num;
    	float *p_f = &f;
    	double *p_db = &db;
    	//一个变量的指针的含义包括两个方面，一是以存储单元编号表示的地址，二是他指向的存储单元的数据类型
        printf("ch=%c,num=%d,f=%f,db=%f\t\n", ch, num, f, db);
    	printf("ch=%c,num=%d,f=%f,db=%f\t\n", *p_ch, *p_num, *p_f, *p_db);
    	printf("%d,%d,%d,%d\t\n", sizeof(ch), sizeof(num), sizeof(f), sizeof(db));
    	printf("p_ch=%p,p_num=%p,p_f=%p,p_db=%p\t\n", p_ch, p_num, p_f, p_db);
    	system("pause");
    	return 0;
    }
    ```

- 指针变量作为函数参数
  - 函数的参数不仅可以是整型，浮点数，字符型等数据，还可以是指针类型，他的作用是将一个变量的地址送到函数中
  - 





































