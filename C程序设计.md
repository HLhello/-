## Cha1 程序设计和C语言

1. 机器语言，汇编语言，低级语言，高级语言

2. 非结构化语言，结构化语言，面向对象的语言，面向过程的语言

3. 编译器，编译过程，源程序，目标程序，可执行程序

4. C语言特点，优点劣势

5. 三个程序

   ```c
   #include<stdio.h>
   int main()
   {
       printf("This is a c program");
       return 0;
   }
   ```

   ```c
   #include<stdio.h>
   int main()
   {
   	int a,b,sum;
   	a = 123;
   	b = 456;
   	sum = a+b;
   	printf("sum is %d\n",sum);
   	return 0;
   }
   ```

   ```c
   #include<stdio.h>
   int main()
   {
   	int max(int x,int y);
   	int a,b,c;
   	scanf("%d,%d",&a,&b);
   	c = max(a,b);
   	printf("max = %d\n",c);
   	return 0;
   }
   int max(int x,int y)
   {
       int z;
       if(x>y) z = x;
       else z = y;
       return z;
   }
   //行注释方法
   /*
   	段落注释方法
   */
   ```

6. 程序分析

- main是表示主函数，并且是主函数的名字，在3中的max也是函数名，一个程序中只能有一个主函数，并且在主程序中必须有一个主函数

- C语言程序的语句必须使用“;”结尾，某些语句比较特殊，如循环语句ifelse语句，switch语句

- main前面的int是函数返回值的类型，

- “\n”是换行符
- “%d”指定输出格式，d表示十进制，x表示十六进制，o表示八进制p表示地址格式

- stdio.h----> standard input & output 的缩写，.h的意思是头文件(header file)

- 函数首部

  | int      | max    | (    | int      | x      | ,      | int      | y      | ）   |
  | -------- | ------ | ---- | -------- | ------ | ------ | -------- | ------ | ---- |
  | 函数类型 | 函数名 |      | 形参类型 | 形参名 | 分隔符 | 形参类型 | 形参名 |      |

- 函数体：用“{}”花括号包起来的就是函数体，包括声明部分和执行部分
- 预处理指令，前面带“#”的都是预处理指令，常见的有include加载头文件，define宏定义
- include<系统文件>，include"自定义文件"
- 全局声明，将变量在函数之外的数据声明，例如将2的程序中的 "int a,b,sum;"放在main函数之前；在函数外面声明的变量称为全局变量，由于C语言的编译是从上向下的，所以讲全局声明放在函数开始之前才可以使用，否则不能使用
- 程序总是从main开始执行的，执行到return程序停止

7. 运行c程序的方法和步骤

- 源程序.c ---> 编译 ---> 目标程序.obj ---> 链接库函数和其他目标程序 ---> 可执行文件.exe

## Cha2 算法——程序的灵魂

1. 数据结构：对数据的描述，在程序中要指定用到哪些数据以及这些数据的空类型和数据的组织形式
2. 算法：对操作的描述，要求计算机进行操作的步骤
3. 算法 + 数据结构 = 程序
4. 例子

- 等差数列求和
- 闰年计算
- 找出求和规律，利用循环求和
- 判断一个数是不是素数（prime）

5. 算法的特性，不一定有输入，却一定有输出

- 有穷性
- 确定性
- 有零个或多个输入
- 有一个或多个输出
- 有效性

6. 表示算法——流程图（起止框 = 圆角，输入输出框 = 平行四边形，判断框 = 菱形，处理框 = 矩形）
7. 三种基本结构

- 顺序结构，选择结构，循环结构（当型while，直到型until）

- 当型结构先判断再执行，直到型结构先执行在判断

  注：略过N-s图与流程图功能一样，伪代码没没有

8. 结构化程序设计方法

- 自顶向下，逐步细化，模块化设计，结构化编码
- 划分模块时，注意模块的独立性，尽量使模块之间的耦合度降低

## Cha3 顺序程序设计

1. #### 转化温度

```c
#include<stdio.h>
void main()
{
    float F,c;
    scanf("F = %f", &F);//scanf中只能有%f，如下面所示
    c = 5/9*(F-32);//   5/9不行，类型不同，5是整数，9是整数，做除法会出问题，如下所示
    printf("c = %f", c);
}// 若程序没有返回值，函数类型可以是void，不写return语句；也可以是int返回值为0

#include<stdio.h>
int main()
{
    float F,c;
    scanf("%f", &F);
    c = (5.0/9)*(F-32);
    printf("F = %f, c = %f", F, c);
	return 0;
}

#include<stdio.h>
int main()
{
    float F;
	int c;
    scanf("%f", &F);
    c = (F/9);
    printf("F = %f, c = %d", F, c);
	return 0;
}
```

2. #### 计算存款利息

```c
#include<stdio.h>
int main()
{	
	float r1 = 0.0036;
	float r2 = 0.0225;
	float r3 = 0.0198;
	
	float p0,p1,p2,p3;
	
    scanf("%f", &p0);
    
    p1 = p0*(1+r1);
    p2 = p0*(1+r2);
    p3 = p0*(1+r3/2)*(1+r3/2);
    
    printf("p1 = %f\n, p1 = %f\n, p1 = %f\n", p1, p2, p3);
    
    return 0;
}
```

3. #### 数据的表现形式及其运算

- ![常量](https://github.com/HLhello/LearningNotes/blob/master/picture/常量.jpeg)

- **常量**，在程序的运行过程中，其值不能被改变的量称为常量。
  - 常量包括整型常量，实型常量，字符常量，字符串常量，符号常量
  - 实型常量有两种。
    - 十进制小数形式，如123.456；
    - 指数形式，如12.34e3 = 12.34*10^3 = 12340,e之前必须有数字
  - 字符常量有两种。
    - 普通字符，用单引号括起来的一个字符，如 ' A '，' a ',  ' # ',  ' 3 ' ' ? ' ;注意一对单引号只能包括一个字符
    - 转义字符,一种特殊的字符常量，以 " \ " 开头的字符序列，将 “ \ ” 后面的字符转换成另外的意义
  - 字符串常量：用双撇号将若干字符括起来，字符串常量是双撇号中的全部字符但不包括双撇号本身；如”china“，”12345“。
    - 注：双撇号可以包括单个字符，但是单撇号之能包含一个字符
  - 符号常量：用#define指令指定一个符号名称代表一个常量，如   #define PI 3.1415926
    - #与define，define与符号名称，符号名称与常量，可以有任意个空格
    - 符号名称不与关键字重名，常量可以是任何想要替换的常量，注意结尾没有“；”
    - 定义符号常量可以在函数体内，也可以在函数体外，只要在调用之前就行
    - 定义符号名称要做到见名知意，在多处使用到符号变量时，使用该定义可以做到一改全改，所以要放在函数开始的地方
- **变量**：在程序运行期间，**<u>变量的值</u>**可以改变。
  - 变量名，存储单元，存储单元地址，变量值
    - 注：在计算机中最小的存储单元是字节byte，一个字节8个bit，为每个字节顺序编码，编码称为地址
  - 变量代表一个有名字的，具有特定属性的一个存储单元。这个存储单元用来存放数据，也就是变量的值
  - <u>变量必须先定义后使用</u>！
  - 在定义时指定该变量的类型，名字 ，对内存空间可以初始化，也可以不初始化，也就是给不给最初的变量值
  - 变量名，存储单元地址都是标记存储单元在内存中的位置
- **常变量** 变量存在期间其值不能改变
  - 例子： const int a = 3;//定义了一个常变量
  - 常变量的属性：有类型，占存储单元，只是不允许改变其值
  - 常变量与常量辨析
    - 常变量是有名字的不变量，常量是没有名字的不变量，有名字便于在程序中被引用
    - 常量是不能当做左值（不能放在等号的左边）
  - #define PI 3.14159  与  const float PI = 3.14159  的区别
    - 前者是预编译指令，不分配内存空间，在编译是进行字符替换，在编译后不存在PI（全部被替换成3.14159）
    - 后者占用存储单元，有变量值，只是该值不改变
    - 后者具有前者的优点，可以不多用前者，在内存空间上前者有一定优势，但是以现在的硬件来看，优势不大
- **标识符** ：标识符就是一个对象的名字，标识符的命名规则，字母数字下划线，数字不开头

4. #### 数据类型

- ![数据类型](https://github.com/HLhello/LearningNotes/blob/master/picture/数据类型.jpeg)

- 不同类型的存储内存及方式

| 类型（字节） | 16位平台 | 32位平台 | 64位平台 |
| :----------: | :------: | :------: | :------: |
|     char     |    1     |    1     |    1     |
|  short int   |    2     |    2     |    2     |
|     int      |    2     |    4     |    4     |
|    float     |    4     |    4     |    4     |
|    double    |    4     |    8     |    8     |
|     long     |    4     |    4     |    8     |
|  long long   |    \     |    8     |    8     |
|     指针     |    2     |    4     |    8     |



- 在存储单元中的存储方式是使用整数的补码方式进行存储

  - 注：理解 <u>原码，反码，补码</u>，数电知识

- **整形变量**的符号属性  注：不包含double 和float

  - 只有整形数据（包括字符型）可以加signed和unsigned修饰，实型数据不能加
  - 定义时类型前面有【unsigned】 就是无符号类型，类型前面有【signed】就是有符号的类型
  - 若没有指定signed或者unsigned，则默认是有符号类型
  - 无符号整形十进制数据用“%u”格式输出，有符号十进制数据用“%d”输出
  - 定义时根据编译器所分配的字节数以及有无符号就可以计算出整形类型所能存储的最大值和最小值
  - unsigned 类型：只有正数没有负数；signed 类型：有正数也有负数
  - 若定义为无符号类型，则不能对其赋负值

- **字符型数据** 注：整数类型的一种

  - 字符变量就是用类型符char定义字符变量，使用“%c”输出字符变量

  - 在内存中是按照代码（整数）的形式存储的

  - 定义带符号的char类型是，最好带上signed

  - ```c
    signed char num = -6;
    char c = '?';
    printf("%c,%d",c,c); -->输出 ？，63
    ```

- **浮点型数据**

  - 浮点型数据是用来表示具有小数点的实数的，在C语言中，实数以指数形式存储在内存中

  - 注：为什么叫做浮点数？

    - 一个实数表示为指数可以有不止一种形式，如3.14159，可以表示为
      $$
      3.14159 * 10^0，0.314159 * 10^1，0.0314159 * 10^2 ...
      $$

    - 代表同一个值，却可以有不同的表现形式，只要小数点浮动的同时改变指数上的值，就可以保证表示的数字不变，由于小数点位置可以浮动，所以实数的指数形式称为浮点数

    - 规范化的指数形式，一个实数只有一个规范化的指数形式
      $$
      实数：3.14159 ==>规范化存储： 0.314159 * 10^1 ==>指数形式输出：0.314159e001
      $$

  - 在存储时，系统实型数据分成小数部分和指数部分，分别存放。小数部分小数点前面的数是0

  - 计算机中，使用二进制数表示小数部分，使用2的幂次表示整数部分

  - 可以表示的实数范围：最大的负实数到最小的负实数，零，最小的正实数到最大的正实数

  - float以及double的字节大反映了程序的精度

- 没有小数点的数值就是整形常量，以小数形式或指数形式出现的实数是浮点型数据

4. #### 运算符和表达式

- 基本算数运算符
  - 单目正号运算+，单目负号运算-
  - 加减乘除取余，分别表示为+，-，*，/，%

- 自增（+ + i）自减（- - i）运算

  - 注：只能用于变量，不能用于常量或者表达式，例如：5++或者（a+b）++都是不合法的

  - ```c
    //++i；--i；在使用之前先自增（减）
    //i++；i--；在使用之后再自增（减）
    int i = 3;
    j = ++i;
    printf("j = %d",j);//输出 j = 4
    j = i++;
    printf("j = %d",j);//输出 j = 4
    printf("i = %d",--i);//输出 i = 4
    printf("i = %d",i--);//输出 j = 4
    ```

- 算数表达式与运算符的优先级与结合性

  - 优先级：（）括号的优先级最高，若不清楚，使用括号来表示优先级
  - 结合性：C语言中算数表达式普遍是由左到右结合

- **不同类型数据间的混合运算**

  - 在程序中，经常会遇到不同类型的数据进行运算，如果一个运算符两侧操作数（运算对象）的数据类型不同，自动进行类型转换，使而知具有同一种类型，然后运算

  - **因此**，整型，实型，字符型数据可以进行混合运算

  - 混合运算时，类型转换的原则知道就行，自动转换，用户无需过问

  - ```
    #include<stdio.h>
    void main()
    {
    	char c1,c2;
        scanf("%c",&c1);
        c2 = c1+32;
        printf("\n%c",c2);
        printf("\n%d",c2);
    }
    ```

- 强制类型转换：（类型名）（表达式）

  - （double）a；（将a转换成double类型）
  - （int）(x+y)；（将（x+y）转换为int类型）

  - ```c
    int a;
    float x = 10.5;
    a = (int)x;
    printf("%d,%f",a,x);//输出结果为 10,10.5
    //证明使用强制类型转换时产生中间变量，将中间变量赋值给a，x的值并不会发生改变
    ```

- C运算符

5. #### C语句

- ![c语句](https://github.com/HLhello/LearningNotes/blob/master/picture/C语句.jpeg)
- 赋值语句
  - 赋值运算符，=
  - 复合赋值运算符，+=，-=，*=，/=，%=
    - 注：x%=（y+3）==> x = x %（y+3）
  - 赋值表达式
    - 变量（左值） 赋值运算符 表达式
    - 左值是一个可以修改的变量，不能是常量或者表达式
    - 可以连等，但不建议使用，C语言一行语句只干一件事
  - 赋值过程中的类型转化
    - 在赋值运算符的两侧类型不一致，在赋值是时动进行类型转换
    - 占字节多的整形数据给占字节少的整形数据或者字符变量赋值时，只将其低字节原封不动的送到被赋值的变量
    - 浮点型数据赋值给整型变量时，舍弃小数位，只赋整数
    - double型赋值给float时，进行精度转换，若超出了界限，就会出现错误
    - 注：C语言使用灵活，赋值时不同类型转换会出现失真，在进行赋值时要多加注意，否则输出结果可能有问题
  - 变量赋初值
    - 在赋值时初始化变量，也可以不初始化，单不允许使用连等来初始化变量

6. #### 数据输入与输出——详解printf与scanf

- 相关概念
  - 输入出处是以计算机为主体而言的
  - C语言本身不提供输入输出语句，输入输出操作是有C标准函数库中的函数来实现的
  - C语句中不包含输入输出函数，目的是使编译系统简化且通用性强
- printf函数——printf（参数1，参数2，参数3，...，参数n）
  - 参数1位格式控制，参数2~参数n是要输出的参数列表
  - printf（“a=%d，b=%f”，a，b）
  - printf（格式控制，输出列表）
    - 格式控制是使用双撇号包起来的一个字符串，包含两个信息，格式声明，普通字符
      - 格式声明总是以“%”字符开始的，后面跟格式字符，例如：d（十进制），x（十六进制）等等
      - 普通字符即需要在输出是按照原样输出的字符
    - 输出列表是程序需要输出的一些数据
  - 格式字符：d，c，s，f，e，x，. . . 
  - 域宽（所占的列数），“%-5d”，“%5.2f”— “-” 表示向左对其，整数就是输出所占的列数（5），浮点数就是小数位数（2）+整数位数（3）=所占列数（5）
  - 注：printf函数输出时，务必注意输出对象的类型与上述格式说明匹配，否则出现错误
  - 注：格式控制中可以包含转义字符
  - 注：格式字符表，附加字符表，转义字符表自行百度用法
- scanf函数——scanf（参数1，参数2，参数3，...，参数n）
  - 参数1是格式控制，参数2~参数n是变量的地址，不是变量名
  - 格式控制与printf含义相似，地址列表是有若干个地址组成的列表，可以使变量的地址，也可以是字符串数组的首地址
  - 在格式控制字符串中除了格式声明以外还有其他字符（对应printf中的普通字符），则在输入数据时在对应得位置上应输入相同的字符，
- 字符数据的输入输出putchar()，getchar()，...

## Cha4 选择结构程序设计

## Cha5 循环结构程序设计

老生常谈的问题，在此就不说了，这两章主要还是讲的分支循环，任何一门语言的必修课，只是写法不一样，其他大同小异，主要是分支循环的思想，以及如何利用

## Cha6 利用数组处理批量数据

- 数组是一组有序数据的集合，用一个数组名和下标可以唯一的确定数组中的元素，数组中每一个元素都属于同一个数据类型

- 定义一维数组：

  - <u>**类型符 数组名[常量表达式]**</u>；

    - 常量表达式表示数组的长度，只有在定义时是这样，常量表达式可以是常量和符号变量，也可以包含常量的运算，却不能是变量

    - ```c
      int n;
      scanf("%d",&n);
      //int a[n]//这种方法是错误的
      可以使用malloc或者calloc以及realloc来定义一个动态数组
      int *p = (int *)malloc(sizeof(int)*n);
      int *px = (int *)calloc(n,sizeof(n));
      ```

    - 注：如果在被调用函数中定义数组，其长度可以是变量或非变量

      - ```c
        void func(int n)
        {
            int a[2*n];//合法
            . . . 
        }
        ```

- 引用数组时，只能引用数组元素而不能一次整体调用整个数组全部元素的值

- 一维数组初始化

  - ```c
    1.
    int a[5] = {1,2,3,4,5};
    2.
    int a[5] = {1,2.3}; ==>a[5] = {1,2,3,0,0};
    3.
    int a[] = {1,2,3};==>int a[3] = {1,2,3};
    4.
    for(int i=0;i<5;i++)
    {
        a[i] = i+1;    
    }
    //初始化时数据的长度确定，没有指定每个数据的初值，则在后面的补零，如2
    //初始化时数据的个数确定，可以不指定数据的长度，如3
    //初始化时长度和个数必须有一个被指定，否则出错
    
    ```

- **冒泡排序法**，每次将相邻的两个数比较，将较小的数放在前面，如此循环，当比较过n-1次之后，最大的数沉底，将剩下的n-1个数进行第二次比较，经过n-2次循环，第二大的数沉底，如此循环，直到剩下两数，比较之后就可以得到从小到大的排序

- **二位数组**，二维数组也就是矩阵

  - 类型说明符 数组名[常量表达式)(常量表达式]

- C语言对二维数组的定义时排列在一起的几行一维数组

  - ```c
    int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
    a[0] 代表二维数组的第一行，也就是一个一维数组的名字
    ```

  - 用矩阵形式定义二维数组，是逻辑上的概念，能形象的表示出行列关系，而在内存中，各元素是连续存放的，不是二维的，是线性的，最左边的下标变换最慢，右边的下标变化快

- 二维数组引用比较复杂，与指针在一起说

- 二维数组的初始化

- ```c
  int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
  int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
  int a[3][4] = {{1,2},{0,6}}; ==>int a[3][4] = {{1,2,0,0},{0,6,0,0},{0,0,0,0}};
  int a[][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12};
  int a[][4] = {{1,2},{0,6},{}};==>int a[3][4] = {{1,2,0,0},{0,6,0,0},{0,0,0,0}};
  for(int i=0;i<3;i++)
  {
      for(int j=0;j<4;j++)
      {
      	a[i][j] = i+j+1;       
      }
  }
  ```

- **字符数组** 

  - char 字符数组名[常量表达式]

  - 初始化字符数组

    - 

    ```c
    char c[10] = {'I',' ','a','m',' ','h','a','p','p','y'};
    char daimond[5][5] = {{'I'},{'a','m'},{'h','a'},{'p','p'},{'y'}};
    //或者使用下面的方法
    ```

    - 

    ```c
    #include<stdio.h>
    #include<stdlib.h>
    
    void main()
    {
    	char c[] = "I am a boy";
    	int i = 0;
    	while (c[i] != '\0')
    	{
    		printf("%c", c[i]);
    		i++;
    	}
    	system("pause");
    }
    ```

- 字符串和字符串结束的标志

  - '\0'代表ASCII码为0的字符，从ASCII码表中可以查到，ASCII码为0的字符不是一个可以显示的字符，而是一个空操作符，也就是他什么也不做，用它来作为字符串结束标志不会产生附加的操作或增加有效字符，只起到一个辨识的作用

  - 在C语言中，是将字符串作为字符数组来处理的，在实际工作中人们往往关心的是字符串的有效长度，而不是字符数组的长度，为了测定字符串的实际长度，C语言规定了了一个字符串结束标志，以'\0'作为结束的标志，也就是说在遇到字符'\0'时，表示字符串结束，把前面的字符组成一个字符串

  - C系统在用字符数组存储字符串常量时会自动加上一个'\0'作为结束符

  - 在程序中往往依靠检测'\0'来判断字符串是否结束，而不是根据数组的长度来决定字符串的长度，在定义字符数组时，应该估计字符串的长度，保证数组长度始终大与字符串的长度

  - ```c
    1.char c[] = {'I',' ','a','m',' ','h','a','p','p','y'};
    2.char c[] = {"I am happy"};
    3.char c[] = "I am happy";
    4.char c[] = {'I',' ','a','m',' ','h','a','p','p','y','\0'};
    注：2,3,4等价，1,4不等价，1的长度为10,4的长度为11
    ```

  - 对于'\0'，如果定义时规定了字符数组长度，并且初始化时全部被赋值，也就是没有'\0'的位置，系统在存储时会自动加上'\0',长度不变，如果没有规定字符数组的长度，初始化时也没有在最后加上'\0'，那么字符的长度是1的情况，存储时还是会加上'\0'，不改变字符数组的长度，还有就是4的情况，会把字符数组长度加1

- 注：在使用scanf为字符串赋值时，不用'&'

  - ```c
    scanf("%s",str);
    ```

- 字符串处理函数

  - gets（字符数组）——接受一个str字符数组

  - puts（字符数组）——输出str字符数组

  - strcat（字符数组1，字符数组2）——字符串连接数组

    - 把字符串数组2接在字符数组1后面，结果放在字符数组1里面

  - strcpy（字符数组1，字符串2）——字符串赋值函数

    - 将字符串2复制到字符数组1中去，字符数组1的长度至少要大与字符串2

    - 将字符串全部复制，并且包含最后的'\0'，从在字符数组1的头开始，复制完成后，字符数组1后面几位不变

    - 不能使用赋值语句将一个字符串常量或者字符数组直接给一个字符数组

      - ```c
        str1 = "China"；//不合法
        str1 = str2;//不合法
        ```

    - strncpy（str1，str2，2）——将str2中的前两个字符复制到字符数组1中去

  - strcmp（字符串1，字符串2）——字符串比较数据

    - 将两个字符串自左至右逐个字符比较，直到出现不同的字符或者遇到'\0'为止，比较的是ASCII码的大小
    - 两个字符串相等，返回值为1，str1>str2 返回值为正整数，str2>str1 返回值为负整数

  - strupr（字符串）——转换为大写的函数

## Cha7 用函数实现模块化设计

- 函数简明

  - 函数就是功能，每一个函数用来实现一个特定的功能，函数的名字应反映其代表的功能
  - 

  ```c
  #include<stdio.h>
  int main()
  {
  	void print_star();
  	void print_message();
  	print_star();
  	print_message();
  	print_star();
  	return 0;
  }
  void print_star()
  {
      printf("**************\n");
  }
  void print_message()
  {
      printf("How do you do!\n");
  }
  
  //定义print_star()函数以及print_message()函数在main函数后面，在这种情况下，应当在main函数之前或main函数开头的位置对两个子函数进行函数声明
  ```

  - 函数声明的作用是把有关函数的信息（函数名，函数类型，函数参数的个数以及类型）通知编译系统，以便在编译系统对程序进行编译是，在进行到main函数调用子函数时知道他们是函数而不是变量或其他对象
  - 函数不能嵌套定义，函数可以互相调用，一个程序只能有一个main函数，可以有多个子函数，子函数与主函数可以在一个文件里也可以不在一个文件里

- 定义一个函数，无参函数，有参函数

  - 定义函数包括四个内容，指定函数的名字，指定函数的类型，指定函数的参数的名字和类型，指定函数完成的功能

  - ```c
    类型名 函数名（）
    {
        声明部分...
        语句部分...
    }
    类型名 函数名（形式参数列表）
    {
        声明部分...
        语句部分...
    }
    ```

- 调用函数

  - 形式参数：在定义函数时，函数名后面括号中的变量名称为形式参数
  - 实际参数：在主函数中调用一个函数时，函数名后面括号中的参数称为实际参数
    - 实参可以是常量，变量，表达式
  - 在定义函数中指定的形参，在未出现函数调用时，并不占内存，在发生函数调用时，函数的形参被临时分配内存单元
  - 将实参的值传递给形参，这是单向的值传递，利用形参进行有关的计算
  - 利用return语句将函数值带回主调函数
  - 调用结束，形参单元被释放，实参单元仍然保留原值

- 函数的返回值

  - 函数的返回值是通过函数中的return语句获得的
  - 一个函数可以有一个以上的return语句，执行到哪一句，将那一句的值返回
  - return后面的值可以是一个表达式
  - **函数类型决定返回值的类型**，在定义函数时，指定的函数类型一般应该和return语句中的表达式类型一致
  - 对于不带返回值的函数，应当定义为void类型

- 在一个函数中调用另一个函数的条件

  - 首先被调用的函数必须是已经定义的函数，是库函数或者用户自己定义的函数
    - 库函数应当在文件开头使用#include指令将有关库函数包含进来
    - 对于自己定义的函数，被调用函数在主调函数后面，则应该在主调函数中对被调用的函数做声明；
    - 如果在函数的开头对函数进行了声明，则在主调函数中不用声明——这种做法称为外部声明。写在所有函数前面的函数声明对整个函数有效
    - 在a函数中调用b函数，在b函数中调用c函数，c函数的证明放在b函数中，b函数的声明放在a函数中，可以，不用换在a中重复声明

- 函数首部，函数原型，声明，函数首行

  - 注：函数定义与函数声明不是一回事，函数声明就是把函数的基本信息传递到主调函数中，函数的基本信息包含在函数首行中；函数定义是对函数功能的确立，是一个完整的函数单位

- 函数的执行顺序——函数不能嵌套定义，能嵌套执行

- TODO：插图

- ![函数调用](http://github.com/HLhello/LearningNotes/blob/master/picture/函数调用.jpeg)

- **递归调用**——在调用一个函数的过程中，有出现直接或间接的调用该函数本身，称为函数的递归调用

  - 程序中不应该出现无终止的递归调用，需要控制递归调用的次数

  - 包括两个阶段，回溯和递推

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    
    void main()
    {
    	int jiecheng(int n);
    	int n, x;
    	scanf("%d", &n);
    	x = jiecheng(n);
    	printf("\n%d! = %d",n, x);
    	system("pause");
    }
    int jiecheng(int n)
    {
    	if (n == 1|| n==0)
    	{
    		printf("\n%d", n);
    		return 1;
    	}
    	else
    	{
    		printf("\n%d", n);
    		return n*jiecheng(n - 1);
    	}
    	
    }
    ```

  - **汉诺塔**

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    
    void main()
    {
    	void heshang(int n, char one, char two, char three);
    	int m;
    	scanf("%d", &m);
    	heshang(m,'A', 'B', 'C');
    	system("pause");
    }
    void heshang(int n, char one, char two, char three)
    {
    	void move(char x, char y);
    	if (n == 1)
    	{
    		move(one, three);
    	}
    	else
    	{
    		heshang(n - 1, one, three, two);
    		move(one, three);
    		heshang(n - 1, two, one, three);
    	}
    }
    void move(char x, char y)
    {
    	printf("%c-->%c\n", x, y);
    }
    ```

- 数组作为函数参数

  - 数组名可以做实参和形参，传递的是数组第一个元素的地址

  - 数组元素可以用作函数实参，不能用作形参

    - 应为形参是函数被调用时临时分配的存储单元，不能作为一个数组元素单独分配存储单元

    - 数组是一个整体，在内存中连续的占一段存储单元

    - ```c
      #define _CRT_SECURE_NO_WARNINGS
      #include<stdio.h>
      #include<stdlib.h>
      
      void main()
      {
      	int a[10];
      	for (int i = 0; i < 10; i++)
      	{
      		scanf("%d", &a[i]);
      		//printf("\n");
      	}
      	for (int i = 0; i < 10; i++)
      	{
      		printf("%d\n",a[i]);
      	}
      	system("pause");
      
      }
      
      ```

  - 用数组元素做实参时，向形参变量传递的是数组元素的值，而用数组名做函数实参，向形参传递的是数组首元素的地址

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    
    void main()
    {
    	float aver(float score[10]);
    	float a[10];
    	for (int i = 0; i < 10; i++)
    	{
    		scanf("%f", &a[i]);
    	}
    	for (int i = 0; i < 10; i++)
    	{
    		printf("%f  ", a[i]);
    	}
    
    	printf("\n%f", aver(a));
    	system("pause");
    }
    float aver(float score[10])
    {
    	float avers = 0;
    	for (int i = 0; i<10; i++)
    	{
    		avers = avers + score[i];
    	}
    
    	return avers / 10;
    }
    ```

  - 用数组名作为参数，应该在主调函数和被调函数分别定义数组，分别在其中一方定义，不能只在一方定义

  - 实参数组与性参数组类型一致，如果不一致，将会出错

  - 在定义被调用函数是，形参列表里的数组定义其大小不起任何作用，在被调用时，只是将只是将实参数组的首元素地址传给形参数组名，形参数组首元素与实参数组首元素地址相同，指向同一内存单元，所以形参数组可以不指定大小，

  - 编译时将形参数组名处理为一个指针变量，用来接收一个地址

  - 注意，由于没有副本机制（在形参不是数组的情况下，会直接拷贝变量），是直接对内存进行操作，形参和实参的数组在内存中是同一个，所以在执行被调函数时对数组的改变会直接将内存的数组也一同改变，执行完被调函数后，在主调函数中的数组也会改变

- 关于二维数组在学习完指针后做详细分析

- 局部变量和全局变量（从变量的作用域分析）

  - **局部变量**：在一个函数内部定义的变量只在该函数内有效，即只有在本函数内才能引用他们，在函数外部不能引用。在函数复合语句内定义的变量只有在复合语句内有效，在复合语句外无效

  - 在函数中定义的局部变量可以在该函数的复合语句内引用

  - **全局变量**：在函数之外定义的变量称为外部变量，外部变量是全局变量，其**有效范围**为从定义变量的位置开始到本源文件结束，全局变量可以为本文件中其他函数所共有

    - 设置全局变量增加了数据间通信的渠道，同一文件中所有函数都能引用全局变量的值
    - 全局变量在程序执行过程中都占用存储单元，他使函数的通用性降低了，函数之间的耦合度上升

  - ```c
    int p = 1,q = 5;//全局变量
    int main()
    {
    	float func(float f)；函数声明
    	int a；
    	float b;//a,b可以在复合语句块中使用
    	a = p+q;//全局变量
         .
    	 .
    	 .
        {
          int c;//c只在此复合语句块内有效
          a = p+q;
          c = a+b;
           .
           .
           .
        }
        
        func（b）
        
        return 0
    }
    
    float func(float f)
    {
    	float x； 
    	x = （float）p+q；//全局变量
        return x；
    }
    ```

  - 注意辨析下面程序

    - ```c
      #include<stdio.h>
      #include<stdlib.h>
      int a = 3, b = 5;//定义全局变量
      void main()
      {
      	int funcmax(int a, int b);//声明函数
      	int a = 8;//定义局部变量
      	printf("%d", max(a, b));
      	system("pause");
      }
      int funcmax(int a, int b)//定义形参
      {
      	int c; //定义max函数内的局部变量
      	c = a>b ? a : b;
      	return c;
      }
      ```

- 动态存储方式和静态存储方式（从变量的生存期来分析）

  - 静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式

  - 动态存储方式是指在程序的运行期间根据需要进行动态的分配存储空间的方式

  - 内存中用户区分为三块：程序区，静态存储区，动态存储区
    - 全局变量放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就就释放
    - 在动态存储区中存放函数形式参数，函数中定义的没有用关键字static声明的变量，即自动变量，函数调用时的现场保护和返回地址

  - 在C语言中，每一个变量和函数都有两个属性，数据类型和存储类型。存储类型已经讲过，存储类别值得是数据在内存中的存储方式（如动态存储和静态存储）

  - ###### TODO插图

  - ![存储类别](https://github.com/HLello/Learningnotes/blob/master/picture/存储类别.jpeg)

  - 在定义和声明变量和函数时 ，一般应同时制定数据类型和存储类别，也可以采用默认方式指定（系统隐含的指定为某一种存储类别）

  - C语言的存储类别包括四种：分别是——**自动的（auto），静态的（statis），寄存器的（register），外部的（external）**

    - **自动变量**存储于动态存储区中，一般不用专门声明，静态局部变量存储于静态存储区，一般不用，会使程序变得难懂，寄存器变量存储在CPU的寄存器中，一般不用专门声明

    - 自动变量：函数中的局部变量，如果不专门声明为static静态存储类别，都是动态的分配存储空间，数据存储在动态存储区中，形参，函数中定义的局部变量，复合语句定义的局部变量，都是自动变量，一般不用进行声明，可以省略，不写auto，隐含指定为自动存储类别

    - **静态局部变量**（static局部变量）：局部变量的值在函数掉用完成后不消失而继续保留原值，也就是说这个变量占用的存储单元不释放，但依旧是局部变量，不能再其他函数中使用

    - ```c
      #include<stdio.h>
      int main()
      {
      	int func(int a);//函数声明
      	int a = 2, i;
      	for (i = 0; i<3; i++)
      	{
      		printf("%d\n", func(a));//输出（a+b+c）
      	}
      	system("pause");
      
      	return 0;
      	
      }
      int func(int a)
      {
      	auto int b = 0;//自动局部变量，自动变量在动态存储区
          //动态变量赋初值，不是在编译时进行的，是在函数调用时进行的，调用结束后，释放掉，每调用一次函数重新给一次初值，相当于执行一次赋值语句
          //若没有赋初值，他就是一个不确定的值
      	static c = 3;//静态局部变量静态局部变量属于今天存储类别，在静态存储区内分配存储单元
          //静态局部变量是在编译时赋初值的，即只赋初值一次，
          //若没有赋初值，编译时自动赋初值0，或者空字符
          //调用结束后变量仍然存在，但是不能被其他函数引用
      	c = c + 1;
      	return (a + b + c);
      
      
      }
      ```

    - **寄存器变量**：有一些变量使用非常频繁，为了增加程序运行的速度，执行效率，允许将局部变量的值放在cpu的寄存器中，不用再放到内存中，寄存器的存取速度远高于内存的存取速度，优化的编译系统能够自动识别，不需要指定

    - **全局变量**：作用的有效范围只限于定义处到文件结束，在定义点之前的函数不能使用该外部变量，如果要在定义点之前使用外部变量使用关键字**extern**

    - ```c
      文件1
      #include<stdio.h>
      int num；
      static int errornum;//称为静态外部变量，static将errornum限制在本文件中，该全部变量不能再其他文件中使用extern关键字声明
      //全局变量和静态全局变量都在静态存储区内存储
      int main()
      {
          int max();//函数声明
          extern int power(int n);//函数声明
          //由于power函数是在文件2中定义的，在文件1中引用时要加上extern声明
          //在对power函数进行声明时，要加关键字extern表示该函数是在其他文件中定义的外部函数
          int m,n;//定义局部变量
          extern A,B,C;//将在main函数后面定义的A,B,C的作用域扩展到从此处开始
          printf("please enter three integer numbers:")
          scanf("%d,%d,%d",&A,&B,&C);
          m = max();
          n = power(m);
          printf("max is %d",m);
          return 0;
      }
      static min()//static关键字说明这个函数是内部函数，静态函数，该函数只能被本文件引用，
      {
          ....
      }
      
      int A,B,C;//定义全局变量
      extern int max()//extern关键字说明该函数是以个外部函数，可以被其他文件调用，extern一般省略不写，C语言默认所有未进行静态声明的函数都是外部函数
      {
          int m;
          m = A>B? A:B;
          if(C>m) m=c;
          return(m)
      }
      //如果一个程序包含5个源文件，在其中一个文件中定义了全局变量，在其他四个文件中都能使用，但是在每一个文件都要加上extern声明一下
      //编译时遇到extern现在本文件中找该变量的定义，找不到，就在连接时从其他文件中找
      
      文件2
      extern num;//把文件1中已经定义的全局变量的作用域扩展到本文件
      //可以不指定类型
      int power(int n)//没有使用extern关键字，默认该函数为外部函数
      {
          int i,y = 1;
          for(i=1;i<=n;i++)
          {
              y*=num;
          }
          return(y);
      }
      
      ```

- 关于定义与声明

  - 函数包括两部分，声明部分和执行语句，被调用时先进行声明，在调用
  - 变量的定义与声明
    - 定义型声明（定义）：建立存储空间
    - 引用型声明（声明）：不分配存储空间

- 内部函数与外部函数

  - 内部函数，使用static特别声明
  - 外部函数，C语言默认函数都是外部函数，不用特别声明，当然也可以用extern声明

## Cha8 善于利用指针  -_-! 数组和指针实在是太燃了

- 指针的基本知识

  - 我们基本的要知道计算机的内存按照字节来进行编码，这个编码就是地址，也就是每个字节都有地址，而C语言中由于变量类型不同，不止一个字节，变量存储的地址是指这个变量的起始地址，而定义指针时给指针变量所赋的值就是变量在内存中的起始地址，如何解析这个地址是由指针类型所决定的，指针存储的地址和指针的类型共同决定指向变量的指针能否找到正确的变量

  - 直接访问：直接按照变量名进行的访问

  - 间接访问：把变量a的**地址**存放在另一个变量b中，然后通过变量b找到找到变量a的地址，从而访问变量a

  - 一个变量的地址称为该变量的**指针**，一个变量专门用来存放另一变量的地址则称他为**指针变量**

  - 指针是一个地址，指针变量是存放地址的变量

  - &取地址运算符，&a是a的地址

  - *指针运算符， *p是指针变量p指向的对象的值

  - 定义指针变量：  **类型名    * 指针变量名** 或者 **类型名  *指针变量名 = &变量**   在使用指针时一般要初始化

  - ```c
    #include<stdio.h>
    #include<stdlib.h>
    int main()
    {
    	char ch = 'A';
    	int num = 10;
    	float f = 8.888888;
    	double db = 8.88888888;
    	char *p_ch;
    	p_ch = &ch;
    	int *p_num = &num;
    	float *p_f = &f;
    	double *p_db = &db;
    	//一个变量的指针的含义包括两个方面，一是以存储单元编号表示的地址，二是他指向的存储单元的数据类型
        printf("ch=%c,num=%d,f=%f,db=%f\t\n", ch, num, f, db);
    	printf("ch=%c,num=%d,f=%f,db=%f\t\n", *p_ch, *p_num, *p_f, *p_db);
    	printf("%d,%d,%d,%d\t\n", sizeof(ch), sizeof(num), sizeof(f), sizeof(db));
    	printf("p_ch=%p,p_num=%p,p_f=%p,p_db=%p\t\n", p_ch, p_num, p_f, p_db);
    	system("pause");
    	return 0;
    }
    ```

- 指针变量作为函数参数
  - 函数的参数不仅可以是整型，浮点数，字符型等数据，还可以是指针类型，他的作用是将一个变量的地址送到函数中

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	void swap_1(int *p1, int *p2);
    	void swap_2(int *p1, int *p2);
    	void swap_3(int e, int f);
    	int a, b, c, d, e, f;
    	int *pointer_1, *pointer_2, *pointer_3, *pointer_4;
    	printf("Please enter two numbers:a,b\n");
    	scanf("%d,%d", &a, &b);
    	printf("Please enter two numbersc,d\n");
    	scanf("%d,%d", &c, &d);
    	printf("Please enter two numberse,f\n");
    	scanf("%d,%d", &e, &f);
    	pointer_1 = &a;
    	pointer_2 = &b;
    	pointer_3 = &c;
    	pointer_4 = &d;
    
    	if (a<b)
    	{
    		swap_1(pointer_1, pointer_2);
    	}
    	printf("a = %d b = %d\n", a, b);
    	printf("main:max = %d,min = %d\n", *pointer_1, *pointer_2);
    	if (c<d)
    	{
    		swap_2(pointer_3, pointer_4);
    	}
    	printf("c = %d d = %d\n", c, d);
    	printf("main:max = %d,min = %d\n", *pointer_3, *pointer_4);
    
    	if (e<f)
    	{
    		swap_3(e, f);
    	}
    	printf("main:e = %d f = %d\n", e, f);
    	system("pause");
    }
    
    void swap_1(int *p1, int *p2)//将地址里的数换了
    {
    	int temp = *p1;
    	*p1 = *p2;
    	*p2 = temp;
    	printf("swap_1:max = %d,min = %d\n", *p1, *p2);
    }
    
    void swap_2(int *p1, int *p2)//将指针换掉，会新创建一个指针，指针做参数是一个值传递的过程
    {
    	int *temp = p1;
    	p1 = p2;
    	p2 = temp;
    	printf("swap_2:max = %d,min = %d\n", *p1, *p2);
    }
    
    void swap_3(int e1, int f1)//将子函数中的数换了
    {
    	int temp = e1;
    	e1 = f1;
    	f1 = temp;
    	printf("swap_3:max = %d,min = %d\n", e1, f1);
    }
    
    
    ```

- 通过指针引用数组

  - 首先辨析数组元素的指针

    - 对于一维数组：int * p = &a[0] <==>int * p = a
    - 数组名不代表整个数组，只代表数组首元素的地址

  - 在引用数组元素时指针的运算

    - 对地址进行乘除是没有意义的，比大小在数组中还可以比较出数组元素下标的大小

    - 在指针指向数组元素时，可以进行加减运算，指针指向大象，指针移动时就移动一头大象的位置，指向老鼠就移动一只老鼠的大小，指针类型决定他指向谁，指针类型是在定义指针时指定的

    - ```c
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
      	int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
      	//方法1
      	for (int i = 0; i < 10; i++)
      	{
      		printf("%d", a[i]);
      	}
      	//方法2
      	for (int i = 0; i < 10; i++)
      	{
      		printf("%d", *(a + i));
      	}
      	//方法3
      	for (int *p = a; p < (a + 10); p++)
      	{
      		printf("%d", *p);
      	}
      	//法1和法2执行效率相同，C编译系统是将a[i]转化为*（a+i）处理的
      	//法3比前两种方法块一点，不必每次都计算地址
      	//使用下标法更加直观
      	//for （; a <(a+10); a++)
      	//{
      	//	printf("%d", a);
      	//}a 是指针常量，不能被当做左值
          system("pause");
      }
      ```

    - **在使用指针变量时注意如果已经对指针进行加减操作，再次引用时要注意将指针复位**

    - ```c
      //[]可以理解为变址运算符
      int a[10] = {1,2,3,4,5,6,7,8,9,10};
      int *p = a;
      1.p++;*p;//输出a[1]的值,p++使p指向下一个元素，在执行*p可以的到下一个元素的值
      2.*p++;//输出a[0]的值，由于* 和++同优先级，结合方形从右到左，因此等价于 *（p++）
      3.*(p++);//输出a[0]的值，相当于先将p指向的地址的值取出来，然后再执行p再执行自加运算
      4.*(++p);//输出a[1]的值，相当于先自加，再引用
      5.++(*p);//输出2，表示p所指向的元素加1
      6.(*p)++;//输出1，取出a[1]的值，先输出，在加1
      ```

  - 用数组名做参数

    - 在使用数组名做参数时，实参向形参传递的值是一个指向该实参数组的指针，也就是说，在子函数被调用时，传递进来的事是一个指针，对指针进行操作，也就是对数组进行操作，会改变数组在内存中的存储方式，而且要**注意**数组作为参数时没有副本机制，所以会直接主调函数中的数组也发生变化

    - 其实在我看来不是没有副本机制，是根本没把数组传递进来，怎么会保存副本呢

    - ```c
      在应用数组作为参数时，以下两种方法是等价的
      func(int arr[],int n)//arr是一个数组
      func(int *arr,int n)
      在该函数被调用时，系统会在func函数中建立一个指针变量arr，用来存放从主调函数传递过来的时参数组首元素的地址
      ```

    - ```c
      //将数组中的数进行逆序
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
      	void revarr(int *p, int n);
      	int n;
      	int a[11] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ,11};
      	n = 11;
      	revarr(a, n);//调用函数将内存中的数组逆序
      	for (int i = 0; i < n; i++)
      	{
      		printf("a[%d] = %d\n", i, a[i]);
      	}
      	system("pause");
      }
      //void reaver(int p[],int n)//与下面一样
      void revarr(int *p,int n)//定义形参时，可以不指定形参数组大小，形参数组名实际上是一个指针变量，并不是真正意义的开辟一个数组空间
      {
      	int temp;
      	for (int i = 0; i < n / 2; i++)
      	{
      		temp = p[i];
      		p[i] = p[n - i-1];
      		p[n - i - 1] = temp;
      	}
      }
      ```

    - 实际指针参数对应四种情况

      - ```c
        1.初阶版本就是数组直观好理解
        int main()
        {
            int a[10];
            . . . 
            func(a,10);
            . . .
        }
        void func(int x[],int n)
        {
        	. . .
        }
        2.形参为指针，调用时使用数组名
        int main()
        {
            int a[10];
            . . . 
            func(a,10);
            . . .
        }
        void func(int *x,int n)
        {
        	. . .
        }
        3.形参时指针，调用时用指向数组的指针
        int main()
        {
            int a[10];
            int *p = a;
            . . . 
            func(p,10);
            . . .
        }
        void func(int *x,int n)
        {
        	. . .
        }
        4.形参是数组，调用时传递指向数组的指针
        int main()
        {
            int a[10];
            int *p = a;
            . . . 
            func(p,10);
            . . .
        }
        void func(int x[],int n)
        {
        	. . .
        }
        ```

  - **注：**关于野指针的讨论

    - ```c
      void main()
      {
          int a,b;
          int *pointer_1,*pointer_2;//指针没有初始化，但是并没有被复制
          scanf("%d,%d",&a,&b);
          pointer_1 = &a;
          pointer_2 = &b;
      }
      void main()
      {
          int a,b;
          int *pointer_1,*pointer_2;
          scanf("%d,%d",pointer_1,pointer_1);//指针没有初始化，并不知道这个指针指向哪，能不能被赋值，这样使用必然是错误的，没有初始化就被使用的就是野指针
          pointer_1 = &a;
          pointer_2 = &b;
      }
      ```

  - 通过指针引用多维数组

    - TODO插入二维数组图

    - ！[二维数组](<https://github.com/HLhello/LearningNotes/blob/master/picture/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.png>)

    - ```c
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
      	int a[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ,11,12};
      	printf("%p,%p,%p\n", &a, a, *a);//地址相同
      	printf("%d,%d,%d\n", sizeof(*&a), sizeof(*a), sizeof(**a));//48,16,4
      	printf("%p,%p,%p\n", a, a[0], a[0]+0);//地址相同
      	printf("%d,%d,%d\n", sizeof(*a), sizeof(*a[0]), sizeof(*(a[0]+0)));//16,4,4
      	printf("%p,%p,%p\n", a, a+1, a+2);//地址相差16
      	printf("%p,%p,%p\n", *(a), *(a + 1), *(a + 2));//地址相差16
      	printf("%p,%p,%p,%p\n", *(a + 0), *(a + 0) + 1, *(a + 0) + 2, *(a + 0) + 3);//地址相差4--第一行四个元素的地址
      	printf("%p,%p,%p,%p\n", *(a + 1), *(a + 1) + 1, *(a + 1) + 2, *(a + 1) + 3);
      	printf("%p,%p,%p,%p\n", *(a + 2), *(a + 2) + 1, *(a + 2) + 2, *(a + 2) + 3);
      	printf("%d,%d,%d,%d\n", *(*(a + 0)), *(*(a + 0) + 1), *(*(a + 0) + 2), *(*(a + 0) + 3));
      	printf("%d,%d,%d,%d\n", *a[0], *a[0] + 1, *a[0] + 2, *a[0] + 3);
      	printf("%d,%d,%d,%d\n", *a[0], *(a[0] + 1), *(a[0] + 2), *(a[0] + 3));
      	printf("%d,%d,%d,%d\n", *a[1], *a[1] + 1, *a[1] + 2, *a[1] + 3);
      	printf("%d,%d,%d,%d\n", *a[2], *a[2] + 1, *a[2] + 2, *a[2] + 3);
      	system("pause");
      }
      
      ```

    - 仔细分析，应该没问题

  - 指向多维数组的指针变量

    - ```c
      //尝试多写几个，想到这三个，有待补充
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
      	int a[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
      	
      	//1.
      	for (int i = 0; i < 3; i++)
      	{
      		for (int j = 0; j < 4; j++)
      		{
      			printf("%4d", a[i][j]);
      		}
      		printf("\n");
      	}
      	//2.
      	for (int i = 0; i < 3; i++)
      	{
      		for (int j = 0; j < 4; j++)
      		{
      			printf("%4d", *(*(a + i) + j));
      		}
      		printf("\n");
      	}
      	//3.
      	for (int i = 0; i < 3; i++)
      	{
      		for (int j = 0; j < 4; j++)
      		{
      			printf("%4d", *(a[i] + j));//*a[i]+j是一种效果
      		}
      		printf("\n");
      	}
      	//4.
          int *pp[3];
          pp = 
      	/*for(int *p = a; p < a + 3; p++ )
      	{
      		for (int j = 0; j < 4; j++)
      		{
      			printf("%4d",*(*p+j));
      		}
      		printf("\n");
      	}*/
      	
      	//5.
      	for (int *p = a[0]; p<a[0] + 12; p++)
      	{
      		if ((p - a[0]) % 4 == 0)
      		{
      			printf("\n");
      		}
      		printf("%4d",*p);
      	}
      
      
      
      	system("pause");
      }
      
      ```

    - 一维数组的练习以及定义一个指针数组

    - ```c
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
      	//int a[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
      	int a[4] = {1,2,3,4};
      	printf("%d\n", sizeof(a));//16
      	int *p;
      	p = a;
      	for (int i = 0; i < 4; i++)
      	{
      		printf("%4d", *(p+i));
      	}
      	printf("\n");
      	for (int i = 0; i < 4; i++)
      	{
      		printf("%4d", p[i]);
      	}
      	printf("\n");
      	int(*pp)[4];//这是定义了一个指针数组
      	pp = &a;//pp指向a中第一个元素
      	printf("%d\n", sizeof(*pp));
      	printf("%d,%d", sizeof(*pp), sizeof(*&a));
      	printf("\n");
      	for (int i = 0; i < 4; i++)
      	{
      		printf("%4d", (*pp)[i]);
      	}
      	printf("\n");
      
      
      	system("pause");
      }
      
      ```

  - 用指向数组的指针做函数参数

    - 两种方法：用指向变量的指针变量，用指向一维数组的指针变量

    - ```c
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
      	void average(float *p, int n);
      	void search(float(*p)[4], int n);
      	float score[3][4] = { { 65, 67, 70, 60 }, { 80, 87, 90, 81 }, { 90, 99, 100, 98 } };
      	average(*score, 12);
      	search(score, 2);
      	system("pause");
      
      }
      void average(float *p, int n)
      {
          printf("%d",sizeof(p));
      	float *p_end;
      	float sum = 0;
      	float aver;
      	p_end = p + n - 1;
      	for (; p <= p_end; p++)
      	{
      		sum = sum + (*p);
      	}
      	aver = sum / n;
      	printf("average = %5.2f\n:",aver);
      }
      void search(float(*p)[4], int n)
      {
      	int i;
      	printf("THE score of No.%d are:\n", n);
      	for (i = 0; i<4; i++)
      	{
      		printf(" %5.2f\n", *(*(p + n) + i));
      	}
      }
      
      ```

- 通过指针引用字符串

  - **注：**在C语言中只有**字符变量**，**没有**字符串变量

  - **注：**通过字符数组名和字符指针变量可以输出一个字符串，而对于一个字符型数组，是不能企图用数组名输出他的全部元素

  - ```c
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	char str[] = "I love China !";
    	char *sstr = "I love China !";//在这里不是把"I love China !"当做变量放在sstr中，也不是把字符串赋值给*sstr，他的本质是把"I love China !"的第一个字符的地址赋值给指针变量sstr
        //sstr被定义成一个指针变量，基类型是字符型，只能把他指向一个字符类型的数据，而不能把他指向多个字符型数据，也就是不能指向整个字符串
        sstr = "I am a student"//这是对sstr的重新赋值，
    	printf("%s\n", str);
    	printf("%c\n", str[7]);
    	printf("%s\n", sstr);//在这里sstr是地址，但是输出可以不用*为啥，我也不知道TODO
    	system("pause");
    }
    ```

  - 将字符串a复制到字符串b，然后输出字符串b

    - ```c
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
          char a[] = "I am a student";
          char b[20];
          for(int i=o;(a+i)!= '\0';i++)
          {
              *(b+i) = *(a+i);
          }
          *(b+i) = '\0';
          printf("a: \n",a);
          printf("b: \n",b);
          
          system("pause");
      }
      ```

  - 字符指针做函数参数

    - ```c
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
      	void strcp_1(char from[], char to[]);
      	void strcp_2(char from[], char to[]);
      	void strcp_3(char *from, char *to);
      	char a[] = "I am a teacher";
      	char b[] = "Your are a student";
      	char *pa = a;
      	char *pb = b;
      	printf("%s,\n%s\n", a, b);
      	//strcp_1(a, b);
      	//strcp_2(a, b);
      	//strcp_3(a, b);
      	//strcp_1(pa, pb);
      	//strcp_2(pa, pb);
      	//strcp_3(pa, pb);
      	printf("%s,\n%s\n", a, b);
      	system("pause");
      }
      void strcp_1(char from[], char to[])
      {
      	int i = 0;
      	for (; from[i] != '\0'; i++)
      	{
      		to[i] = from[i];
      	}
      	to[i] = '\0';
      }
      void strcp_11(char from[], char to[])
      {
      	int i = 0;
      	while (from[i] != '\0')
      	{
      		to[i] = from[i];
      		i++;
      	}
      	to[i] = '\0';
      }
      void strcp_2(char from[], char to[])
      {
      	int i = 0;
      	for (; from[i] != '\0'; i++)
      	{
      		to[i] = from[i];
      	}
      	to[i] = '\0';
      }
      void strcp_21(char from[], char to[])
      {
      	int i = 0;
      	while (from[i] != 0)
      	{
      		to[i] = from[i];
      		i++;
      	}
      	to[i] = '\0';
      }
      void strcp_3(char *from, char *to)
      {
      	int i = 0;
      	for (; *(from + i) != '\0'; i++)
      	{
      		*(to + i) = *(from + i);
      	}
      	*(to + i) = '\0';
      }
      void strcp_31(char *from, char *to)
      {
      	for (; *from != '\0'; from++, to++)
      	{
      		*to = *from;
      	}
      	*to = '\0';
      }
      ```

    - 输入一个字符串，并且把它按照原样输出

    - ```c
      #define _CRT_SECURE_NO_WARNINGS
      #include<stdio.h>
      #include<stdlib.h>
      #include<crtdefs.h>
      
      void main()
      {	
      	char datain[100];
      	int i = 0;
      	for (;;i++)
      	{
      		scanf("%c", &datain[i]);
      		if (datain[i]=='\n') break;
      	}
      	for (int j = 0; j<i; j++)
      	{
      		printf("%c", datain[j]);
      	}
      	printf("%c", datain[0]);
      
      	system("pause");
      
      }
      ```

  - 使字符指针变量和字符数组的比较

    - 使用**字符数组**和**字符指针变量**都能实现字符串的存储和运算，但他们之间是有区别的。

    - 字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址

    - 不能对字符数组名赋值，可以对指针变量赋值

    - ```c
      //字符指针变量
      char *a;
      a = "I love China";//合法
      //字符数组
      char str[40];
      str = "I love China"l;//注意这是不合法的！！！！！！！
      str[0] = 'I';//这是可以的
      //注意：
      1.
      char *a = "I love China";//合法
      1.1.
      char *a;
      a = "I love China";//合法 1.与1.1等价
      2.char str[40] = "I love China";//合法
      2.1.
      char str[40];2.1 与2.不等价！！！！！
      str = "I love China"l;//注意这是不合法的！！！！！！！
      
      ```

    - 编译时为字符数组分配若干存储单元，以存放个元素的值，而对于指针变量，只分配了一个存储单元

    - ```c
      下面是错误的
      char *a;
      scanf("%s",a);
      编译时只给a分配了一个存储单元，存储单元内的值是不知道的，也就是说我们并不知道指针a指向谁，也就不知道其指向的内存的值是否是可读可写的
      我们可以使用下面这个方法来实现字符串的输入
      char *a, str[10];
      a = str;
      scanf("%s",a);
      ```

    - **指针变量的值是可以改变的，而数组名代表一个固定的值，不能改变，也就是说前者是变量，后者是常量**

    - 字符数组中各元素的值是可以改变的，但是字符指针变量所指向的字符串是不可以改变的，这个这么说吧，对于字符数组来说，每个存储单元相当于是存了一个变量名和变量值，这个变量名是**a[i]**，变量值就是第（i+1）个字符，对于指针变量来说，他指向的存储单元中并没有名字，只是在这个地址中存储了一个字符，所以说他是不能改变的，也就是说他就是个常量，所以不能改变

    - ```c
      #include<stdio.h>
      void main()
      {
      	char a[] = "I love China";
      	char *b = "I love China";
      	char *p = a;
      	a[2] = 'r';//正确，变量可以被重新赋值
      	//b[2] = 'r';//这不合法的，常量不能被赋值
      	printf("%c", b[2]);//可以使用指针变量加下标的方法访问元素
      	p[2] = 'r';//合法
      	system("pause");
      }
      ```

    - 用指针变量指向一个格式字符串，可以用它替代printf函数中的格式字符串

    - ```c
      char * format;
      format = "a = %d, b = %f\n";
      printf(format,a,b); //相当于printf（"a = %d, b = %f\n", a, b）;
      ```

- 指向函数的指针

  - 在程序中定义了一个函数，在编译时，编译系统为函数代码分配一段存储空间，这段存储空间的起始地址称为这个函数的指针

  - 定义一个函数指针变量

    - 类型名 （*指针变量名）（函数参数列表）
    - 这里的类型名是指函数返回值得类型
    - 该函数指针只能指向类型名，和函数参数列表相同的函数，也就是说指针不能随便指，但是他是个变量，**可以被赋值，也可以被重新赋值**，注意前一句话，这表明函数指针是有实际意义的
    - 对指针变量的赋值方法：指针变量名 = 函数名，不用加*，更不要加参数列表
    - 函数指针不能进行加减运算

  - 使用函数指针变量调用函数

    - ```c
      #define _CRT_SECURE_NO_WARNINGS
      #include<stdio.h>
      
      void main()
      {
      	int mymax(int a, int b);
      	int a, b;
      	int ans;
      	scanf("%d,%d", &a, &b);
      	//定义函数指针的括号不能省略，参数类型不能省略，参数名可以省略
      	int (*p)(int a, int b);//定义一个两输入的函数指针
      	//定义完函数指针之后还要进行赋值，函数名字就是地址，与数组名就是其地址是一样的
      	p = mymax;//将函数指针指向mymax
      	//（*p）就是调用函数，括号同样不能省略，括号意味着指针结合的优先级
      	ans = (*p)(a, b);//调用函数指针，使用ans接受返回值
      	printf("%d", ans);
      	system("pause");
      }
      int mymax(int a, int b)
      {
      	int max;
      	max = a>b ? a : b;
      	return max;
      }
      ```

  - 用直线函数的指针做函数参数

    - 指向函数的指针变量的一个重要的用途是把函数的地址做为参数传递到其他函数，这样就能在被调函数中使用实参函数，只是看起来复杂，我觉得没有二维数组和指针复杂

    - ```c
      #define _CRT_SECURE_NO_WARNINGS
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
      	int answer(int a, int b, int(*p)(int, int));
      	int jia(int a, int b);
      	int jian(int a, int b);
      	int cheng(int a, int b);
      	int chu(int a, int b);
      	int a, b;
      	char x;
      	scanf("%d", &a);
      	scanf("%c", &x);
      	scanf("%d", &b);
      	printf("%d %c %d= ?\n", a, x, b);
      	if (x == '+') answer(a, b, jia);
      	else if (x == '-') answer(a, b, jian);
      	else if (x == '*') answer(a, b, cheng);
      	else if (x == '/') answer(a, b, chu);
      	else printf("The input is error");
      
      	system("pause");
      
      }
      int answer(int a, int b, int(*p)(int, int))
      {
      	int ans;
      	ans = (*p)(a, b);
      	return ans;
      }
      int jia(int a, int b)
      {
      	int ans;
      	ans = a + b;
      	printf("%d + %d = %d", a, b, ans);
      	return ans;
      }
      
      int jian(int a, int b)
      {
      	int ans;
      	ans = a - b;
      	printf("%d - %d = %d", a, b, ans);
      	return ans;
      }
      
      int cheng(int a, int b)
      {
      	int ans;
      	ans = a * b;
      	printf("%d * %d = %d", a, b, ans);
      	return ans;
      }
      
      int chu(int a, int b)
      {
      	int ans;
      	ans = (int)a / b;
      	printf("%d / %d = %d", a, b, ans);
      	return ans;
      }
      ```

      ```c
      #define _CRT_SECURE_NO_WARNINGS
      #include<stdio.h>
      #include<stdlib.h>
      void main()
      {
      	void fun(int x, int y, int(*p)(int, int));
      	int mymax(int, int);
      	int mymin(int, int);
      	int add(int, int);
      	int a = 34, b = -21, n;
      	scanf("%d", &n);
      	if (n == 1)fun(a, b, mymax);
      	else if (n == 2)fun(a, b, mymin);
      	else if (n == 3)fun(a, b, add);
      	system("pause");
      }
      void fun(int x, int y, int(*p)(int, int))
      {
      	int result;
      	result = (*p)(x, y);
      	printf("%d", result);
      }
      int mymax(int x, int y)
      {
      	int z;
      	z = x > y ? x:y;
      	return z;
      }
      
      int mymin(int x, int y)
      {
      	int z;
      	z = x < y ? x:y;
      	return z;
      }
      int add(int x, int y)
      {
      	return x + y;
      }
      ```

- **返回指针的函数** TODO####

  - 一个函数可以返回一个整数值，字符型，实型值等，也可以返回指针型的数据，也就是地址，概念都一样，返回的值的类型是指针类型而已

  - 定义返回指针的函数的一般形式：类型名 * 函数名（参数列表）

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	float score[][4] = { { 60, 70, 90, 90 }, { 56, 89, 67, 88 }, { 34, 78, 90, 66 } };
    	float * mysearch(float (*pinter)[4], int n);
    	float *p;
    	int k;
    	scanf("%d", &k);	
    	p = mysearch(score, k);
    
    	for (int i = 0; i<4; i++)
    	{
    		printf("%5.2f\t", *(p + i));
    	}
    	system("pause");
    }
    float * mysearch(float (*pointer)[4], int n)
    {
    	float *pt;
    	pt = *(pointer + n);
    	return pt;
    }
    ```

    ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	float score[][4] = { { 90, 70, 90, 90 }, { 56, 89, 67, 88 }, { 34, 78, 90, 66 } };
    	float * mysearch(float (*pinter)[4]);//
    
    	for (int i = 0; i<3; i++)
    	{
    		p = mysearch(score+i);
    		if (p == *(score + i))
    		{
    			for (int j = 0; j < 4; j++)
    			{
    				printf("%5.2f\t", *(p + j));
    			}
    			printf("\n");
    		}
    		
    	}
    	system("pause");
    }
    float * mysearch(float (*pointer)[4])//输入的参数是列控制指针
    {
    	float *pt;
    	pt = NULL;
    	for (int i = 0; i < 4; i++)
    	{
    		if (*(*pointer+i) < 60)
    		{
    			pt = *pointer;
    			break;
    		}
    	}
    	return pt//返回的参数也是列控制指针
    }
    ```

- 指针数组和多重指针

  - 一个数组，若其元素均为指针类型数据，称为指针数组，也就是说，指针数组中每一个元素都存放一个地址，相当于一个指针变量，指针数组比较常用来指向某个字符串，使字符串的处理更加灵活方便，可以分别定义一些字符串，然后用指针数组中的元素分别指向字符串

  - 定义一维数组的一般形式为 **类型名 * 数组名 [指针长度]**

    - 注：没有括号，中括号的优先级比星号的优先级高，所以会先和中括号结合，然后在寻址取值

  - ```c
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	void print(char *name[], int n);
    	void sort(char *name[], int n);
    	char * name[] = { "BHaiLong", "Dhailou", "CLiHailong", "Ahello", "Elihailong" };
    	int n = 5;
    	sort(name, n);
    	print(name, n);
    	system("pause");
    }
    void sort(char *name[], int n)//程序肯定有错，但程序是通的 TODO
    {
    	char *temp;
    	int i,j, k;
    	for (i = 0; i < n - 1;i++)
    	{
    		k = i;
    		for (j = i + 1; j<n; j++)
    		{
    			if (strcmp(name[k], name[j])>=0) k = j;
    			if (k != j)
    			{
    				temp = name[i];
    				name[i] = name[k];
    				name[k] = temp;
    			}
    		}
    	}
    }
    void print(char *name[], int n)
    {
    	int i;
    	for (i = 0; i<n; i++)
    	{
    		printf("%s\n", name[i]);
    	}
    }
    ```

- 指向指针数据的指针

  - 顾名思义指向指针的指针

  - 定义一个指向指针的指针的一般形式 ：类型名 ** 指针变量名

  - ```c
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	char * name[] = { "BHaiLong", "Dhailou", "CLiHailong", "Ahello", "Elihailong" };
    	char **p;
    	for (int i = 0; i<5; i++)
    	{
    		p = name + i;
    		printf("%s\n", *p);
    	}
    	system("pause");
    }
    ```

  - ```c
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	int a[5] = { 1, 2, 3, 4, 5 };
    	int *num[5] = { &a[0], &a[1], &a[2], &a[3], &a[4] };//num[i] = &a[i]
    	int **p, i;
    	p = num;
    	for (i = 0; i<5; i++)
    	{
    		printf("%d", a[i]);
    		printf("%d", *num[i]);
    		printf("%d", *(*(p + i)));
    		printf("%d", *(*p + i));
    	}
    	system("pause");
    
    }
    ```

- 指针参数作main函数的形参

  - 通常main函数是没有参数的，但是有没有一种情况是我们在调用某个程序时要指定一些参数，比如我们使用cmd中的某些命令时：函数名 参数1，参数2，..... 这种情况

- 指针小结

  - 首先要准确的弄清楚指针的含义，**指针就是地址，凡是指针出现的地方，都可以用指针代替**，例如变量的指针就是变量的地址，指针变量就是地址变量
  - **指向**，地址就意味着指向，通过地址能找到具有该地址的对象，对于指针变量来说把谁的地址存放在指针变量中，就说此指针**指向**谁！
  - 指针变量的类型与含义



  - | 变量定义       | 类型表示      | 含义                                                    |
    | -------------- | ------------- | ------------------------------------------------------- |
    | int i          | int           | 定义整形变量i                                           |
    | int *p         | int *         | 定义p为指向整形数据的变量                               |
    | int a[5]       | int  [5]      | 定义有5个元素的整型数组a                                |
    | int *p[4]      | int  *  [4]   | 定义指针数组p，他由4个指向整型数据的指针元素组成        |
    | int （*p）[4]  | int  (*)  [4] | p为指向包含4个元素的一维数组的指针变量                  |
    | int func（）   | int ( )       | func为返回整型函数值得函数                              |
    | int *func（）  | int  * （）   | func为返回一个指针的函数，该指针指向整型数据            |
    | int （*p）（） | int （*）（） | p为指向函数的指针，该函数返回一个整型值                 |
    | int **p        | int **        | p为一个指针变量，它指向一个指向整型数据的指针变量       |
    | void * p       | void *        | p为一个指针变量，基类型为void（空类型）不指向具体的对象 |

  - 指整运算，加减运算，赋值运算

  - 指针变量可以有空值 **p = NULL**，即该指针变量不指向任何变量，在这里要注意，p的值是NULL与p未被赋值是两个不同的概念

# C语言指针的讨论

## 1.指整的概念辨析

## 2.指针与一维数组

## 3.指针与二维数组

## 4.指针与动态数组

## 5.指针数组

## 6. 指整与函数，形参，返回值

先熟悉一下概念，使劲把他们记下了

| 变量定义       | 类型表示      | 含义                                                    |
| -------------- | ------------- | ------------------------------------------------------- |
| int i          | int           | 定义整形变量i                                           |
| int *p         | int *         | 定义p为指向整形数据的变量                               |
| int a[5]       | int  [5]      | 定义有5个元素的整型数组a                                |
| int *p[4]      | int  *  [4]   | 定义指针数组p，他由4个指向整型数据的指针元素组成        |
| int （*p）[4]  | int  (*)  [4] | p为指向包含4个元素的一维数组的指针变量                  |
| int func（）   | int ( )       | func为返回整型函数值得函数                              |
| int *func（）  | int  * （）   | func为返回一个指针的函数，该指针指向整型数据            |
| int （*p）（） | int （*）（） | p为指向函数的指针，该函数返回一个整型值                 |
| int **p        | int **        | p为一个指针变量，它指向一个指向整型数据的指针变量       |
| void * p       | void *        | p为一个指针变量，基类型为void（空类型）不指向具体的对象 |

## 9.用户建立自己的数据类型

- C语言允许用户自加建立由不同类型数据组合成的组合型数据结构，称为结构体

- 定义一个结构体类型的一般形式为

  ​	**struct    结构体名**    //结构体名由用户指定，又称为结构体标签

  ​	**{**

  ​		**成员1；**	//成员列表又称域表，成员命名规则与变量命名相同

  ​		**成员2；**

  ​		**. . .**

  ​	**}；**

- 定义结构体类型变量的一般形式

  - 先声明结构体类型名，再定义该结构体类型的变量



  - |    结构体类型名     |    结构体变量名    |
    | :-----------------: | :----------------: |
    | struct     结构体名 |    结构体变量名    |
    | struct      student | student1，student2 |

- 成员可以属于另一个结构体类

  ​	**struct    结构体名**    //结构体名由用户指定，又称为结构体标签

  ​	**{**

  ​		**成员1；**	//成员列表又称域表，成员命名规则与变量命名相同

  ​		**成员2；**

  ​		**struct 结构体名 结构体变量名**

  ​		**. . .**

  ​	**}；**	

- 不指定类型名而直接定义结构体类型变量

  ​	**struct**

  ​	**{**

  ​		**成员列表**

  ​	**}；变量名列表**

  - **结构体类型**和**结构体变量**是不同的概念，不要混同。只能对变量赋值、存取、或运算，而不能对一个类型赋值、存取或运算，在编译时，对类型是不分配空间的，只对变量分配空间
  - 结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一个对象
  - 对结构体变量中的成员可以单独使用，他的作用与地位相当于与普通变量，只是引用方式不同

- 结构体变量的初始化和引用

  - ```c
    #include<stdio.h>
    int main()
    {
        struct Student  //声明一个结构体类型
        {
            long int num;  //以下4行结构体的成员
            char name[20];
            char sex;
            char addr[20];
        }a = {10101,"LiLIn",'M',"123 BeiJing Road"};//定义一个结构体变量a并初始化
        printf("No.:%ld\nname:%s\nsex:\naddress:%s\n".a.num,a.name,a.sex,a.addr)
    }
    //允许对某一成员初始化，为初始化的成员为零，与数组可以类比以下
    ```

  - 使用结构体白能量中成员的值，引用的一般方法为 

    ​	 **结构体变量名.成员名**，如：student1.num

  - "**.**" 是成员运算符，他在所有的运算符中**优先级最高**，因此无论什么情况点号**左右两边的值都可以看做一个整体**

  - 如果成员本身又属于一个结构体类型，则要用若干个成员运算符，一级一级的找到最低一级的成员，若果要把它当做一个变量来操作，就必须找到最低的一级。对**结构体变量的成员**可以当普通变量一样进行各种运算

  - 同类型的结构体变量可以互相赋值

  - ```C
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    struct person
    {
    	char name[20];
    	int count;
    }leader[3] = { "AA", 0, "BB", 0, "CC", 0 };//定义结构体变量
    
    void main()
    {
    	char leader_name[20];
    	//struct person leader[3] = { "AA", 0, "BB", 0, "CC", 0 };//在程序内声明同样可以
    	for (int i = 0; i<10; i++)
    	{
    		scanf("%s", &leader_name);
    		for (int j = 0; j<3; j++)
    		{
    			if (strcmp(leader_name, leader[j].name) == 0) leader[j].name,leader[j].count++;//使用strcmp判断输入的名字
    		}
    	}
    	printf("\nresult:");
    	for (int i = 0; i<3; i++)
    	{
    		printf("%5s:%d\n", leader[i].name, leader[i].count);
    	}
    	system("pause");
    }
    ```

  - 定义结构体变量数组的一般形式：**结构体类型  数组名[数组长度] = {初值列表}；**

  - 初值列表是数组长度个，怎么说呢，结构体变量的数组在内存中是挨个挨个排列的，而每个结构体变量数组元素中的成员在内存中也是挨个挨个排列的

  - 在这里复习**const int N = 5;** 与 **#define N 5;**这两句话在一般时候等效

- 结构体指针

  - 所谓结构体指针就是指向结构体变量的指针，一个结构体变量的起始地址就是这个结构体变量的指针，如果把一个结构体变量的起始地址存放在一个指针变量中，那么这个指针就是结构体指针

  - 指向结构体变量的指针定义的一般形式

    ​	struct Student * pt  //pt可以指向struct Student类型的变量或数组元素

  - ```c
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	struct Student  //声明一个结构体类型
    	{
    		long int num;  //以下4行结构体的成员
    		char name[20];
    		char sex;
    		int score;
    	};
    	struct Student stu_1;
    	struct Student *p;//定义一个指向该结构体类型的指针
    	p = &stu_1;
    	stu_1.num = 10101;
    	strcpy(stu_1.name, "Lilin");//注意这个字符串的赋值方式，不能使用等号赋值
    	stu_1.sex = 'M';
    	stu_1.score = 88;
    	printf("No.:%ld\nname:%s\nsex:%c\nscore%5d\n", stu_1.num, stu_1.name, stu_1.sex, stu_1.score);
    	printf("No.:%ld\nname:%s\nsex:%c\nscore%5d\n", (*p).num, p->name, (*p).sex, (*p).score);//(*p).name 等价与p->num 注意这一点，使用这一点更加直观 
    	system("pause");
    }
    ```

- 指向结构体数组的指针

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    struct person
    {
    	char name[20];
    	int count;
    }leader[3] = { "AA", 0, "BB", 0, "CC", 0 };//定义结构体变量
    
    void main()
    {
    	struct person *p;//该指针指向的类型是person
    	//在对p进行运算时，移动的内存就是结构体大小的内存
    	for (p = leader; p<leader + 3; p++)//将结构体变量数组的首地址leader赋值给p
    	{
    		printf("%s      %d\n", p->name, (*p).count);//这两种引用结构体成员的方式等价
    	}
    	
    	//定义pp是一个指向结构体的指针，如果给他赋值结构体变量成员的首地址，也就是对pp赋值为 p = leader[1].name,在编译时会发出警告信息，指针运算移动的大小仍然是一个结构体类型的大小
        struct person *pp;//该指针指向的类型是person
    	pp = (struct person *)leader[0].name;
    	for (int i = 0; i < 3; i++)
    	{
    		printf("%s\n", pp + i);
    	}
    
    
    	system("pause");
    }
    //(++p)->name 先自加在引用 
    //(p++)->name 先引用再自加
    ```

  - 用结构体变量和结构体变量的指针做函数参数

    - 将一个结构体变量的值传递给另一个参数有三种方法

      - 用结构体变量的成员做参数
      - 用结构体变量做实参
      - 用指向结构体变量的指针作为实参

    - ```、c
      #define _CRT_SECURE_NO_WARNINGS
      #include<stdio.h>
      #include<stdlib.h>
      #define N 3
      struct student
      {
      	int num;
      	char name[30];
      	float score[3];
      	float aver;
      };
      
      void main()
      {
      	void input(struct student stu[]);
      	struct student mymax(struct  student[]);
      	void print(struct student stu);
      	struct student stu[N];//定义一个结构体变脸数组
      	struct student *p = stu;	//定义的是指向结构体变量数组的指针
      	input(p);//传入的是指向结构体变量的
      	print(mymax(p));
      	system("pause");
      }
      //调用input时，实参是指针变量p，形参是结构体数组，传递的是结构体数组元素的首地址
      //调用max时，实参时指针变量p，形参是结构体数组，传递的是结构体元素的地址，返回值是结构体类型的数据
      //调用print时，实参是结构体变量（结构体数组元素），形参是结构体变量，传递的是结构体变量中各成员的值
      void input(struct student stu[])//参数为结构体变量数组
      {
      	float totalscore = 0;
      	for (int i = 0; i<N; i++)
      	{	
      		printf("student id: ");
      		scanf("%d", &stu[i].num);
      		printf("student name: ");
      		scanf("%s", &stu[i].name);
      		for (int j = 1; j <= 3; j++)
      		{
      			printf("score[%d]: ", j);
      			scanf("%f", &stu[i].score[j-1]);
      			totalscore = totalscore + stu[i].score[j-1];
      			printf("%f", totalscore);
      		}
      		stu[i].aver = totalscore / 3;
      		totalscore = 0;
      	}
      }
      struct student mymax(struct  student stu[])//参数为结构体变量数组
      {	
      	int m = 0;
      	for (int i = 0; i < N; i++)//比较之后取出下标
      	{
      		if (stu[i].aver>stu[m].aver) m = i;//m始终是比较大的下标
      	}
      	return stu[m];
      }
      void print(struct student stud)//参数为结构体变量
      {
      	printf("student id: %d\n", stud.num);
      	printf("student name: %s\n",stud.name);
      	for (int j = 1; j <= 3; j++)
      	{
      		printf("score[%d]: %f",j, stud.score[j-1]);
      	}
      	printf("\naver score: %f\n", stud.aver);
      }
      
      
      ```

- 链表

  - 链表是一种常见的数据结构，他是动态的进行存储分配的一种结构，从本质上来说，链表是结构体中的一种，可以说是嵌套，也可以说是递归，举个例子幼儿园的老师牵第一个小朋友，第一个小朋友牵第二个小朋友，以此类推.  .  .

  - 用数组存放数据时，必定实现固定数组的长度，如果无法确定数组元素的个数，便会将数组元素个数定义的足够大以适应每种不同的情况，这样做显然会浪费内存，链表则没有这种缺点，他根据需要开辟内存

  - 链表的一般结构

    - 每个节点包括两部分 **用户需要用的实际数据**和**下一个节点的地址**

    - head指向第一个元素，第一个元素指向下一个元素，表尾指向NULL，链表到此结束

  - | head                         | A(实际数据) | B(实际数据) | C(实际数据) | . . . . . .     | last(实际数据) |
    | ---------------------------- | ----------- | ----------- | ----------- | --------------- | -------------- |
    | 指针变量保存第一个元素的地址 | 地址        | 地址        | 地址        | **. . . . . .** | NULL           |

  - 显然，建立链表使用结构体变量是最合适的链表这种数据结构，必须利用指针才能实现，也就是一个节点应该包含一个指针变量，用来存放下一节点的地址

  - **struct     结构体名**

    **{**

    ​	**实际数据；**

    ​	**struct   结构体名 * next；		//next是指针变量，指向结构体变量**

    **}**；



  ```c
  //这是一个简单的静态列表，所有的节点都是在程序中定义的，不是临时开辟的，也不能用完后释放
    #include<stdio.h>
    struct student		//声明结构体变量
    {
    	int stuid;
    	float score;
    	struct student * next;
    };//注意这个；老忘
    void main()
    {
    	struct student a, b, c, *head, *p;//定义三个结构体变量作为链表的节点
    	a.stuid = 10101; a.score = 89.5;
    	b.stuid = 10103; b.score = 90;
    	c.stuid = 10105; c.score = 85.5;//对于结构体变量的成员赋值
    	head = &a;//指定链表的头，将链表的第一个节点赋值给链表的头
    	a.next = &b;//指定下一个节点的地址
    	b.next = &c;//指定下一个节点的地址
    	c.next = NULL;//链表结束，将下一个位置设置为NULL表示链表结束
    	p = head;//设置一个取值的指针，指向链表的头
    	do
    	{
    		printf("%ld %5.1f\n", p->stuid, p->score);
    		p = p->next;//等效于(*p).next
    	} while (p != NULL);
    	system("pause");
    }
  ```

  - 建立动态列表

    - 所谓建立动态列表是指在程序执行过程中，从无到有的建立起一个链表，也就是一个一个的开辟节点和输入各节点的数据并且建立前后相连的关系

    - ```c
      //这个程序不会，TODO没看懂，可能是这回心思比较乱吧
      #define _CRT_SECURE_NO_WARNINGS
      #include<stdio.h>
      #include<stdlib.h>
      #define LEN sizeof(struct student)
      struct student
      {
      	long stuid;
      	float score;
      	struct student *next;
      };
      int n;
      struct student *creat(void)
      {
      	struct student * head;
      	struct student *p1, *p2;
      	n = 0;
      	p1 = p2 = (struct student *)malloc(LEN);
      	scanf("%ld,%f", &p1->stuid, &p1->score);
      	head = NULL;
      	while (p1->stuid != 0)
      	{
      		n = n + 1;
      		if (n == 1) head = p1;
      		else p2->next = p1;
      		p2 = p1;
      		p1 = (struct student *)malloc(LEN);
      		scanf("%ld,%f", &p1->stuid, &p1->score);
      	}
      	p2->next = NULL;
      	return head;
      }
      //输出链表的函数
      void print(struct student *head)
      {
      	struct student *p;
      	printf("\nNow,these %d records are :\n", n);
      	p = head;
      	if (head != NULL)
      	{
      		do
      		{
      			printf("%ld %5.1f\n", p->stuid, p->score);
      			p = p->next;
      		} while (p != NULL);
      	}
      }
      
      int main()
      {
      	struct student *head;
      	head = creat();
      	print(head);
      	//printf("\nnum:%ld\nsocre:%5.1f\n", pt->stuid, pt->score);
      	system("pause");
      	return 0;
      }
      ```

- 共用体类型

  - 有时候想用同一段内存单元存储不同类型的变量，例如我们想把一个整型变量，一个字符型变量，和一个实型变量放在同一个内存地址开始的内存单元中，以上三个变量在内存中所占的字节数不同，但都从同一地址开始，也就是使用覆盖技术，后一个数据覆盖了前面的数据

  - 共用体变量的成员工用一段内存，这句话表明在 一个时刻共用体的成员只有一个具有有效值，存储单元只能有唯一的内容，

  - 共用体类型定义的一般形式

    ​	**union    共用体名** 

    ​	**{**

    ​		**成员列表**

    ​	**}变量列表；**

  - 共用体与结构体

    - 共用体与结构体的定义形式是相同的，但意义是不同的
    - 结构体变量所占内存长度是所有成员占内存长度之和，共用体变量所占内存长度是最长的成员长度
    - 结构体变量每个成员是有各自独立的内存单元，而**共用体成员共用一段内存**

- 枚举类型

  - 如果一个变量只有几个可能的值，则可以定义为枚举类型，所谓枚举，就是把所有可能的值一一列举出来，变量的值只限于列举的范围之内

  - 枚举类型定义的一般形式

    ​	**enum    枚举名   {枚举元素列表}**

    例：enum    weekday{sun, mon, tue, wed, thu, fri, sat}

    ​	定义枚举类型变量    enum weekday   workday， weekday

  - C编译对枚举类型的枚举元素按常量处理，故称枚举常量，既然常量那么他就不能被赋值，即枚举元素不能被赋值

  - 每一个枚举元素都代表一个整数，C语言编译按照定义时的顺序默认他们为0,1,2,3,4,5. . . 

    即：workday = mon； 也就是  workday = 1；printf（“%d”，workday）；输出为1

    也可以人为的指定枚举元素的数值，在定义变量时显式的指出

    即：enum    weekday{sun=7, mon=1, tue, wed, thu, fri, sat}  workday， week_day；

    指定枚举型常量sun的值为7，mon的值为1，以后顺序加1，sat为6

  - 枚举元素也可以用来作判断比较，在if语句中或者在switch语句中都是比较好用的

  - ```c
    //这个程序不会，TODO没看懂，可能是这回心思比较乱吧
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    
    enum color{red,yellow,blue,white,black};
    
    void main()
    {
    	enum color i, j, k, pri;
    	int n, loop;
    	n = 0;
    	for (i = red; i <= black; i++)
    	{
    		for (j = red; j <= black; j++)
    		{
    			if (i != j)
    			{
    				for (k = red; k <= black; k++)
    				{
    					if ((k != i) &&( k != j))
    					{
    						n = n + 1;
    						printf("%-4d", n);
    						for (loop = 1; loop <= 3; loop++)
    						{
    							switch (loop)
    							{
    							case 1:pri = i; break;
    							case 2:pri = j; break;
    							case 3:pri = k; break;
    							default:break;
    							}
    							switch (pri)
    							{
    							case red:printf("%-10s", "red"); break;
    							case yellow:printf("%-10s", "yellow"); break;
    							case blue:printf("%-10s", "blue"); break;
    							case white:printf("%-10s", "white"); break;
    							case black:printf("%-10s", "black"); break;
    							}
    						}printf("\n");
    					}
    				}
    			}
    		}
    	}
    	printf("\ntotal:%5d", n);
    	system("pause");
    }
    ```

- 使用typedef声明新类型名

  - 从前面已知，处理简单的类型，C程序中还会用到许多看起来比较复杂的类型，包括结构体类型，共用体类型，枚举类型，指针类型，数组类型等，这些类型形式复杂，在开发时不留神就会出错，所以我们可以使用typedef来将复杂的类型名用一个比较简单的名字重新声明

  - 注：使用typedef并不是新生成一种类型，而是将复杂类型名转换成简单类型名

  - 这样做的目的是便于使用，在程序开发时也能做到统一协调，能做到一改全改，不用再每个使用到该类型的地方都修改

  - 使用一个typedef定义一个新类型名的一般方法是

     	1. 先按照定义变量的方法写出定义体（如：int a[100]）
     	2. 将变量名转化为新类型名（如： int NUM[100]）

        ​      	3. 在最前面加上关键字typedef（如：typedef int NUM[100]）
           	4. 然后可以用新类型名去定义变量（如：NUM a，即等效于 int a[100]）

  - ```c
    struct Date
    {
        int month;
        int day;
        int year;
    };
    struct Date birthday;//定义结构体类型变量
    struct Date *ppp;//定义结构体类型变量指针
    
    struct 
    {
        int month;
        int day;
        int year;
    }Date;//匿名结构体只能在他后面定义结构体变量
    
    typedef struct
    {
        int month;
        int day;
        int year;
    }Date;
    
    Date birthday;
    Date * p;
    ```

  - typedef与#define有相似之处

    - 例如   typedef int count  与  #define count  int这两句话看似是一个意思，但事实上他们二者是不同的
    - #define是在预编译时处理的，他只能做简单的字符串替换，而typedef是在编译阶段处理的，他并不是简单地字符串替换，而是将某一种类型的名字换掉，在 程序执行时定义功能与之等效

## Cha10 对文件的输入输出

- 在程序设计中，文件主要有两种类型，程序文件和数据文件

  - 程序文件包括源程序文件.c，目标文件.obj，可执行文件.exe，每个文件的意义在开始的时候已经说过
  - 数据文件，文件内容不是程序，而是程序运行时需要读写的数据
  - C的数据文件由一连串的字符组成而不考虑行的界限，两行数据并不会自动加分隔符

- 文件名

  - 一个文件要有一个唯一的文件标识，以便用户识别和引用，文件标识包括三部分别
    - 文件路径，文件名主干，文件后缀
    - 例：D:\cc\temp\    file1    .    dat
  - TODO 插图

- 文件类型指针，文件指针

  - 每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的有关信息，这些信息都保存在一个结构体变量中，该结构体类型是由结构体声明的，在stdio.h中被声明

  - ```c
    typedef struct
    {
    	short level;					//缓冲区满或者空的程度
    	unsigned flags;					//文件状态标志
    	char fd;						//文件描述符
    	unsigned char;					//如缓冲区无内容不读取字符
    	short bsize;					//缓冲区的大小
    	unsigned char * buffer;			//数据缓冲区的位置
    	unsigned char * curp;			//指针当前的指向
    	unsigned istemp;				//临时文件指示器
    	short token;					//用于有效性检查
    }FILE;								//使用typedef重新声明，FILE文件可以定义该类型变量
    //例：
    FILE f1;							//定义了一个结构体变量
    FILE *fp							//定义了一个指向结构体的文件指针	
    ```

- 打开文件与关闭文件

  - 在打开文件的同时，一般指定一个指针变量指向该文件，也就是建立起指针变量与文件之间的练习，这样就可以通过该指针变量进行读写了

  - 所谓关闭是指撤销文件信息区和文件缓冲区，是文件指针变量不再指向该文件，显然就无法进行对文件的读写了

  - fopen函数

    - fopen("al","r");  //al是要打开文件的名字，使用文件方式为读入

    - fopen函数的返回值是指向al文件的文件指针（即al文件信息区的起始地址），通常将fopen函数的返回值赋值给文件指针

    - ```c
      FILE *fp;				//定义一个指向文件的指针指针
      fp = fopen("al","r");	//将fopen函数的返回值赋值给文件指针变量
      //这样fp就和文件al联系上了，也就是说fp指向了al文件
      ```

    - 

      | 文件使用方式参数  | 含义                                     | 如果指定的文件不存在 |
      | ----------------- | ---------------------------------------- | -------------------- |
      | “r”（只读）       | 为了输入数据，打开一个已经存在的文本文件 | error                |
      | “w”（只写）       | 为了输出数据，打开一个文本文件           | right                |
      | “a”（追加）       | 向文本文件尾添加数据                     | error                |
      | “r+”（读写）      | 为了读和写，打开一个文本文件             | error                |
      | “W+”（读写）      | 为了读和写，建立一个新的文本文件         | right                |
      | “a+”（读写）      | 为了读和写，打开一个文本文件             | error                |
      | “rb”（只读）      | 为了输入数据，打开一个二进制文件         | error                |
      | “wb”（只写）      | 为了输出数据，打开一个二进制文件         | right                |
      | “ab”（追加）      | 向二进制文件尾添加数据                   | error                |
      | “rb+”,“wb+”,“ab+” | 操作二进制文件                           | error，right，error  |

    - ```c
      #include<stdio.h>
      if(fp = fopen("file1","r")) == NULL)
      {
          printf("cannot open this file\n");
          exit(0);//exit函数的作用是关闭所有文件，终止正在执行的程序
      }
      ```

  - fclose函数

    - 在使用完一个文件后应该关闭它，以防止它再被误用，关闭就是撤销文件信息区，和文件缓冲区，使文件指针不再指向该文件
    - 关闭文件指针的一般形式：**fclose（文件指针）**

- 顺序读写数据文件

  - 对文件读写数据的顺序和数据在文件中的物理顺序是一致的，顺序读写需要用库函数实现

  - 

    | 函数名 | 调用形式        | 功能                                                         | 返回值                                                      |
    | ------ | --------------- | ------------------------------------------------------------ | ----------------------------------------------------------- |
    | fgetc  | fgetc(fp)       | 从fp指向的文件中读入一个字符                                 | 读成功，带回所读的字符；失败则返回文件结束标志EOF（即-1）   |
    | fputc  | fputc(fp)       | 把字符ch写到文件指针变量fp所指向的文件中                     | 输出成功，返回值就是输出的字符；输出失败，则返回EOF（即-1） |
    | fgets  | fgets(str,n,fp) | 从fp指向的文件中读入一个长度为（n-1）的字符串，存放到字符数组str中 | 读成功，则返回地址str；失败则返回NULL                       |
    | fputs  | fputs(str,fp)   | 把str所指向的字符串写到文件指针变量所指向的文件中            | 输出成功，返回0；否则返回非0值                              |

  - fgets函数的函数原型（函数头） **fgets( char *str, int n, FILE *fp)**

    - n为要求得到的字符个数

  - fputs函数的函数原型（函数头） **fputs( char *str, int n, FILE *fp)**

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	FILE *fp;
    	char ch, filename[10];
    	printf("输入文件名：");
    	scanf("%s", filename);
    	fp = fopen(filename, "w");//打开文件并使fp指向此文件
    	if (fp == NULL)//判断当fp为NULL时，则终止函数
    	{
    		printf("cannot open this file\n");
    		exit(0);
    	}
    	ch = getchar();//在使用scanf输入文件名时，回车后才能从缓冲区驶入到程序中，所以这个getchar用来接收一个回车
        //如果少一个getchar那么回车会最为输入文件的第一个字符
        printf("输入存入的字符串(以#结束):");//输入提示
    	ch = getchar();//接收从键盘输入的最后一个字符
    	while (ch != '#')//当输入#时结束循环
    	{
    		fputc(ch,fp);//向磁盘文件输出一个字符
    		putchar(ch);//将输出的字符显示在屏幕上
    		ch = getchar();//再接收从键盘输入的一个字符
    	}
    	fclose(fp);//关闭文件
    	putchar(10);//向屏幕输出一个换行符
    	system("pause");
    }
    ```

  - ```c
    //讲一个文件备份到另一个文件内容中
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	FILE *fp,*fto;
    	char ch, filename1[10], filename2[10];
    	printf("输入文件名：");
    	scanf("%s", filename1);
    	fp = fopen(filename1, "w");
    	if (fp == NULL)
    	{
    		printf("cannot open this file\n");
    		exit(0);
    	}
    	ch = getchar();
    	printf("输入存入的字符串(以#结束):");
    	ch = getchar();
    	while (ch != '#')
    	{
    		fputc(ch,fp);
    		putchar(ch);
    		ch = getchar();
    	}
    	fclose(fp);
    
    	printf("输入文件名：");
    	scanf("%s", filename2);
    	fto = fopen(filename2, "w");
    	if (fto == NULL)
    	{
    		printf("cannot open this file\n");
    		exit(0);
    	}
    	ch = getchar();
    	printf("输入存入的字符串(以#结束):");
    	fp = fopen(filename1, "r");
    	ch = fgetc(fp);//指针从当前读写位置自动后移
    	while (feof(fp))//ch != EOF,这两个条件一样，使用函数feof(fp)可以检测传入函数的文件指针是否结束
    	{
    		fputc(ch, fto);
    		putchar(ch);
    		ch = fgetc(fp);
    	}
    	fclose(fp);
    	fclose(fto);
    
    	putchar(10);
    	system("pause");
    }
    ```

  - ```c
    //课本上的//有错，也不知道哪有错，TODO     -_-!
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    void main()
    {
    	FILE *in, *out;
    	char ch, infile[10], outfile[10];
    	printf("输入读文件的名字：");
    	scanf("%s", infile);
    	printf("输入写文件的名字：");
    	scanf("%s", outfile);
    	in = fopen(infile, "r");
    	if (infile == NULL)//判断当fp为NULL时，则终止函数
    	{
    		printf("cannot open this file\n");
    		exit(0);
    	}
    	out = fopen(outfile, "w");
    	if (outfile == NULL)//判断当fp为NULL时，则终止函数
    	{
    		printf("cannot open this file\n");
    		exit(0);
    	}
    	ch = fgetc(in);
    	while (ch != EOF);
    	{
    		ch = fgetc(in);
    		fputc(ch, out);
    		putchar(ch);
    	}
    	putchar(10);
    	fclose(in);
    	fclose(out);
    	system("pause");
    }
    ```

  - ```c
    //从键盘读入若干个字符串，对他们按照字母大小写顺序排序，然后把拍好序的字符串送到磁盘文件保护
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    #include<string.h>
    void main()
    {
    	FILE *fp;
    	char str[3][10], temp[10];
    	int i, j, k, n = 3;
    	printf("Enter strings\n");
    	for (i = 0; i<n; i++)
    	{
    		gets(str[i]);
    	}
    	for (i = 0; i<n - 1; i++)
    	{
    		k = i;
    		for (j = i + 1; j<n; j++)
    		{
    			if (strcmp(str[k], str[j])>0)k = j;
    		}
    		if (k != i)
    		{
    			strcpy(temp, str[i]);
    			strcpy(str[i], str[j]);
    			strcpy(str[j], temp);
    		}
    	}
    	fp = fopen("string.dat", "w");
    	if (fp == NULL)
    	{
    		printf("cannot open file");
    		exit(0);
    	}
    	printf("\nThe new sequence:\n");
    	for (i = 0; i<n; i++)
    	{
    		fputs(str[i], fp);
    		fputs("\n", fp);
    		printf("%s\n", str[i]);
    	}
    	system("pause");
    }
    ```

  - ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    void main()
    {
    	FILE *fp;
    	char str[3][10];
    	int i = 0;
    	fp = fopen("string.dat", "r");
    	if (fp == NULL)
    	{
    		printf("cannot open file");
    		exit(0);
    	}
    	while (fgets(str[i], 10, fp) != NULL)
    	{
    		printf("%s", str[i]);
    		i++;
    	}
    	fclose(fp);
    	system("pause");
    
    }
    ```

- 使用格式化的方式读写文件

  - fprintf( 文件指针，格式字符串，输出列表 )
  - fscanf( 文件指针，格式字符串，输出列表 )
  - 使用fprintf和fscanf函数对磁盘文件进行读写，使用方便，容易理解，但由于输入时要将文件中的ASCII转换为二进制形式保存在内存变量中，在输入时又要将内存中的二进制形式转换为字符，要花费较多时间，因此在内存与磁盘频繁交换数据的情况下，最好不用fprintf和fscanf函数

- 使用二进制方式向文件读写一组数据

  - 在程序中不仅需要一次输入输出一个数据，而且常常需要一次输入输出一组数据，在这是我们使用fread和fwrite读写一个数据块

  - fread和fwrite函数在读写时是以二进制形式进行的，在向磁盘写数据时，直接将内存中一组数据原封不动，不加转换的赋值到磁盘文件上，在读入时也是将磁盘文件中若干字节的内容一批读入内存

  - fread( buffer, size, count, fp )

  - fwrite( buffer, size, count, fp ) 

  - buffer：是一个地址，对于fread来说，它是用来存放从文件读入数据的存储区的地址，对于fwrite来说，是要把从此地址开始的存储区中的数据向文件输出（以上指的是起始地址）

  - size：要读取的字节数

  - count：要读些多少个数据项，每个数据项长度为size

  - fp：FILE文件指针

  - ```c
    //这个程序能跑，但是没调好，也有不能理解的地方 TODO
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>
    #define size 3
    struct student
    {
    	char name[10];
    	int stuid;
    	int age;
    }stud[size],outstud[size];
    void save()
    {
    	FILE *fp;
    	int i;
    	fp = fopen("stu.dat", "wb");
    	if (fp == NULL)
    	{
    		printf("cannot open file");
    		exit(0);
    	}
    	for (i = 0; i<size; i++)
    	{
    		if (fwrite(&stud[i], sizeof(struct student), 1, fp) != 1)
    		{
    			printf("file write error");
    		}
    	}
    	fclose(fp);
    }
    
    void load(FILE *fp)
    {
    	FILE *fp;
    	int i;
    	fp = fopen("stu.dat", "rb");
    	if (fp == NULL)
    	{
    		printf("cannot open file");
    		exit(0);
    	}
    	printf("\n");
    	for (i = 0; i<size; i++)
    	{
    		fread(&outstud[i], sizeof(struct student), 1, fp);
    		printf("%-10s%4d%4d\n", outstud[i].name, outstud[i].stuid, outstud[i].age);
    	}
    }
    void main()
    {
    	int i;
    	printf("enter data of students:\n");
    	for (i = 0; i<size; i++)
    	{
    		scanf("%s%d%d", stud[i].name, stud[i].stuid, stud[i].age);
    	}
        FILE *pfrom  *pto;
        pfrom = fopen("stu.dat", "rb");
        pto = fopen("stu.dat", "rb");
        load(*pfrom)
    	save();
    	load(*pto);
    	system("pause");
    }
    ```

- 随机读写数据文件

  - 随机访问不是按照数据在文件中的物理位置次序进行读写，而是可以对任何位置上的数据进行访问，显然 这种方法比顺序访问有效的多

  - 文件位置标记

    - 为了对读写进行控制，系统为每个文件设置了一个文件读写位置标记，用来指示接下来要读些的下一个字符的位置
    - 一般情况下，在对字符文件进行顺序读写时，文件位置标志指向文件开头，这时对文件进行读写操作，就读一个字符，然后文件位置标记向后移一个位置

  - 文件位置标记的定位以及关于文件指针的函数

    - 可以强制是文件文件位置标记指向人们指定的位置

    - rewind（fp）：使用rewind函数使文件位置标记指向文件开头，该函数的作用就是使文件位置标志指向文件开头，该函数没有返回值

    - fseek( 文件类型指针，位移量， 起始点)：显而易见，该函数的作用是将文件指针从起始点移动位移量个单位后指向的位置

      - 注：位移量是long型数据，在数字 后要加大写L

      - 

        | 起始点       | 名字     | 数字代表 |
        | ------------ | -------- | -------- |
        | 文件开始位置 | SEEK_SET | 0        |
        | 文件当前位置 | SEEK_CUR | 1        |
        | 文件末尾位置 | SEEK_END | 2        |

      - ```c
        例：
        fseek(fp,100L,0);//将文件位置向前移动到距离文件开头100个字节处
        fseek(fp,50L,1); //将文件位置标记向前移到距离当前位置50个字节处
        fseek(fp,-10L,2);//将文件位置标记向后移动到距离文件结束10个字节处
        ```

    - ftell（fp）：使用ftell函数测定文件位置标标记的当前位置，返回值为long型数据，若返回-1则表明文件位置出错

    - ferror（fp）：在调用各种文件输入输出函数时，出现错误，除了这些函数自身的返回值外，还可以用ferror函数检查，返回值为0，表示没有出错 ，返回值为非零值，则表明有错。使用fopen函数打开文件时，ferror的初始值自动设置为0

    - clearerr(fp)：clearerr的作用是使文件错误标志和文件结束标志止为0

本书于2019年9月5日15:14:31读完成，习题与TODO内容会陆续补充


























































































