1. BCD数制的问题

   1. BCD 码中最常用的是 8421 码，其各个 bit 权值分别是 8d、 4d、 2d、 1d
   2. 同理 5421 码各位的权依次为 5d、 4d、 2d、 1d。 5421 码特点是最高位连续 5 个 0 后连续 5 个 1，故其当计数器采用这种编码时，最高位可产生对称方波输出
   3. 余 3 码是在 8421 码上加 0011b 的出来的；
   4. 格雷码的特点是任意两个相邻的代码只有一位二进制数不同，编码格式不唯一；
   5. 余 3 循环码具有格雷码的特点并且编码的首尾可以连接来进行循环，这样可用反馈移位寄存器来实现，硬件实现简单。 
   6. BCD码利于十进制的计算
      1. BCD 码的运算规则： BCD 码是十进制数，而运算器对数据做加减运算时，都是按二进制运算规则进行处理的。这样，当将 BCD 码传送给运算器进行运算时，其结果需要修正。修正的规则是：当两个 BCD 码相加，如果和等于或小于 1001b(即十进制数 9)，不需要修正；如果相加之和在 1010b 到 1111b(即十六进制数 0AH～0FH)之间，则需加 6d 也就是 0110 进行修正；如果相加时，本位产生了进位，也需加 6 进行修正。下面举例说明：计算 5+8，将 5和 8 转换为 8421 BCD 码后输入加法器，则运算如下： 0101 + 1000 = 1101 结果大于 9d，+0110b 即加 6d 修正得出 10011b，补充高位为 0001_0011b。 即 5+8=13，结论正确。
      2. BCD 码的主要应用之一就是数码管，假设要将十进制数 158 显示， 一般解决办法是把需要显示的十进制数的个、十、百、千位数等进行拆分，即把 158 拆分出 1、 5、 8，然后查出对应的数码管显示段码再送去给数码管连接的 IO 口。这个过程可以进行下面的运算：先进行除法运算 158/100 得出百位 1，再取余 158%100 = 58 后继续进行除法运算 58 / 10 得出十位 5，再进行一次取余 158%10 ，得到个位 8。以上过程可以看出需要除法，但是由于除法运算是比较消耗计算时间导致整体需要的指令周期太久。但是如果先将其转换为 BCD 码，则可大幅度减少运算时间。 具体应用将在数码管一讲中详细介绍。 

2. generate 语法块

   1. ```verilog 
      module pll_cnt_gen(
      	clk,
      	rst,
      	led
      );
      parameter cnt_max = 10'd10;
      
      input clk;
      input rst;
      
      output [3:0]led;
      
      reg [9:0]cnt[3:0];
      wire [3:0]clk_xm;
      wire rst_n;
      
      pll	pll (
      	.areset ( !rst ),
      	.inclk0 ( clk ),
      	.c0 ( clk_xm[0] ),
      	.c1 ( clk_xm[1] ),
      	.c2 ( clk_xm[2] ),
      	.c3 ( clk_xm[3] ),
      	.locked ( rst_n )
      	);
      
      genvar i;
      generate 
      	for(i=0; i<4; i=i+1)
      		begin : led_ctrl
      			always@(posedge clk_xm[i] or negedge rst_n)
      				if(!rst_n)
      					cnt[i] <= 10'd0;
      				else if(cnt[i] == cnt_max - 1'b1)	
      					cnt[i] <= 10'd0;
      				else 
      					cnt[i] <= cnt[i] + 1'd1;
      
      			assign led[i] = (cnt[i] <= ((cnt_max>>1) - 1'b1))? 1'b1 : 1'b0;
      		end
      endgenerate 
      
      
      endmodule 
      
      
      ```

