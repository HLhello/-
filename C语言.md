###强制类型转换
（类型）（表达式）
数据溢出的问题
数据盒子最多容纳两位
max ---->99  --->99+1 --->00
在加一位，进位数据被舍弃
所以得到的结果为00
###类型转换的二进制原理
printf打印的范围
#include <stdio.h>
#include <limit.h>

void main()
{
	//%d 有符号十进制的输出  int
	//%u 无符号十进制的输出 unsigned int
	printf
	//使用数据一定要在范围之内
	//越过数据极限，就输出意料之外的数据

}

数据复制本质上就是将二进制的数
short x = 255; 0000 0000 1111 1111
unsigned char ch = x; 1111 1111
short x = 256; 0000 0001 0000 0000
unsigned char ch = x; 0000 0000

数据的填充
char  类型 一个字节8位 0000 0

有符号的小数据向有符号的大数据转换，可以保证结果的正确
就像老鼠从小盒子到大盒子，可以保证老鼠的完整
大数据转小数据会产生截取。下数据转大数据会产生填充
有符号的小数据转有符号的大数据，旺旺按照符号填充
无法符号小数据转换无符号大数据
符号位为0就填充0，符号位为1就填充1
unsigned 要转换的数据没有符号位，就统一填充为0
有符号小数据转换无符号大数据
整数可以保证正确，负数按照二进制来解析，不能保证结果的正确
首先数据在极限范
围之内是正确的，在极限范围之内就不保证正确
负数在内存中是按照补码来显示的
 printf 本质是不管原来数据是什么类型，我统一按照我自己的方式来进行解析
指定是%d就是%d，指定是%u就是%u
正数是原码负数是补码，针对负数，跟据原码求补码，根据补码求原码
计算机赋值的时候，不管三七二十一
就是把二进制发的值赋值过来，
有符号才有补码，无符号不谈补码
 
 
 #标准库函数<stdlib.h>
 _itoa（num, str, 2）
 标准库第一个要转换的数据，第二个是字符串，第三个是转换的进制
####
所有数据的极限
printf（"%d,%d", INT_MAX, INT_MAIN)调用int的最值
 打印无符号，一定要使用%u
 数据类型只是一个盒子，决定其极限值
 数据类型的大小，不同类型占多少个字节
 ###
 类型提升
 char short 字符，无论有无符号，在表达式中，都会转换为int或者unsigned
 可以跨平台
 不同的平台，不同的编译器，同一整数数据类型可能大小不一样
 C语言提供了一个标准库<stdint.h>
 只要支持c99的编译器就都行
 <stdbool.h>支持C语言的bool变量
 bool型变量关注成立不成立
 
 ###运算符与表达式
 常用的运算符与表达式
 1+2，就是一个表达式，+是操作符，操作数就是1和2
  算术表达式，关系表达式，函数表达式
  函数的表达书sqrt（a+b）
  运算符规则
  运算符不能相邻，除了加减号
  乘号不能省略
  运算优先级使用（）
  算数，关系，逻辑，位操作
  操作数，运算符，表达式
  int整数运算只保留整数，
  C语言中要区分参与运算的类型
  参与运算的含有整数，
  在数学运算中，两个整数的运算结果一定是整数
  求余运算符%不能包含duble，float
  两边都必须是整型数据
  整数无发直接打印，需要转换成字符串
  main函数是程序入口点，int是函数返回值类型，一个函数可以没有返回值
  ++ 或者-- 不能用于常数或表达书
  ++在前是先自增在引用
  ++在后是先引用再自减
  运算符优先级和结合性
  优先级是指那种运算在前，括号可以改变优先级
   ++的优先级高于乘除法也高于加减法
   运算级，与自增自减的位置决定先引用还是自增
   ###赋值运算符
   常量不是左值不能被赋值
   赋值号会默认将赋值号右边的数据转换成左边变量额的类型，
   如果实数转整数会有精确度的损失
   复合数据运算符转换规则
   按照等价形式转换
   赋值运算符的值就是最终赋值以后变量的值
   赋值运算符是从右向左执行
   表达式的解析是从右向左
   赋值号的数据类型转换
   ###逗号运算符
   多个表达式的值用逗号连接在一起，就是逗号表打死
   按照顺序求值，值为最后一个表达式的值
   逗号运算符优先级最低
   int i= （1,2,3）； 正确
   int i= 1,2,3； 错误
   逗号分隔作用
   用于求值时，就是顺序求值，从左向右
   用于分隔多条语句时就是分隔作用从左向右
   
   
   ###
   关系表达式
   结合性就是计算方向是从左到右
   同样的运算符就是从左向右的
   一般形式：表达式|运算符|表达式
   关系运算符的优先级
   运算符先判断优先级，在按照从左向右运算
   ###
   关系运算符的特殊性
   关系表达式可以是整型浮点型也可以是字符型
   但是一般不用比较两个常量字符串
   对于浮点型数据，由于存储形式特殊，小数点采用近似结果
   因此不推荐使用 == 或者！=进行关系运算
   
   float最多精确到6-7位，double精确到小数点13-14位
   所以存在不精确
   
   定义常量，编译器为了节约内存，常量不可以修改
   无论常量多少个引用
   都是一个常量
   字符串之间，比较大小关系没有任何意义，只有相等或者不等才有意义
   相等的常量都存在一个地址
   针对字符串比较的是地址
   字符串变量会另外开辟地址，常量只有一个地址
   而判断等于或者不等于时
   判断的是地址一不一样
 
###
逻辑运算符
逻辑非运算符高于算数运算符
算数运算符高于关系运算符
关系运算符高于逻辑与运算符
逻辑与运算符高于逻辑或运算符
逻辑或运算符高于辅助运算符
###
理解短路表达式
计算机从左向右执行，
对于与来说，一个表达式为0，那么整个表达式的值就是0
有一个不符合剩下一个是否符合，都不符合
对于或来说，一个表达式为1，那么整个表达式的值就是1
一个符合剩下一个是否符合，都符合
在C语言总，若通过左边一个条件确定逻辑运算的值，右边的条件就不在执行
这就是短路效应
###
条件运算符
x = 1? x:y
条件运算符的优先级高于赋值运算符
条件运算符结合方向从右向左
若a<b<c<d
y = a > b ? a : c > d ? c : d
-->y = d 
###
左值和程序实体
程序实体是内存的一块克表示的区域
左值是左值表达式的简称
是指明一个程序实体的表达式
判断一个表达式是否是左值的方式就是看他能不能放在等号的左边
能放在左边就说明是左值
左值指明了一块内存区域
赋值运算其实是改变这一区域内容的操作
const int num 定义一个常量，初始化的时候就可以放在赋值号的左边
不能先定义在赋值，也就是上述方法是错误的
必须在定义时就进行赋值
const int num = 10；
只有在初始化的时候可以赋值
在C语言中不能直接赋值给寄存器没有任何意义
例如 a+1，等等这样的表达式没有程序实体
在cpu 寄存器里面
例如 float a 声明了一个浮点型的变量a
则a 是左值，因为他指明了一个内存实体，在内存中能找到，可以放在赋值号的左边
但表达式a+1 就不能放在赋值号的左边不是左值
他们在内存里面，C语言不能给cpu 的寄存器赋值，没有意义



###
数据输入输出
scanf("%d",&num)
printf 格式控制输出输入函数
getchar（）putchar（）字符输入输出函数
printf一一对应，  
输出表中的数据可以是合法的常量，变量与表达式
要与格式控制中的格式字符一一对应
printf("结果是：%d\n")
%后面：跟格式字符组成，将输出数据转换为指定格式输出
“结果是”：字符串原样输出，
“\n”：转义字符，对输出形式进行控制
###
格式说明
%d一以带符号的十进制形式输出整数
%o-以无符号的八进制形式输出整数
%x—以无符号的十六进制形式输出整数
%u—以无符号的十进制形式输出整数
%c-以字符形式输出单个字符
%s-输出字符串
%f— 以小数点形式输出单、双精度实数
%e-   以标准指数形式输出单、双精度实数
%g—选用输出宽度较小的格式输出实数



0就是填充数据的，如果有0，就用0填充






















































   
   
   
   
   
  
  


























10


