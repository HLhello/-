## CHA1 数据结构绪论

### 1.3 

- 程序设计 = 数据结构 + 算法

### 1.4

- 数据，数据元素，数据项，数据对象，数据结构

- 数据：是描述客观事务的符号，是计算机中可以操作的对象，能被计算机识别，并输入给计算机处理的符号集合

- 数据结构：数据元素之间存在一种或多种特定关系的数据元素的集合

### 1.5

- 逻辑结构：数据对象中数据元素之间的相互关系
  - 集合结构
  - 线性结构
  - 树形结构
  - 图形结构
- 物理结构（存储结构）：是指数据的逻辑结构在计算机中的存储形式
  - 顺序存储结构
  - 链式存储结构

### 1.6

- 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称
  - 原子类型
  - 结构类型
- 抽象数据类型（Abstract Data Type，ADT）是指一个数学模型及在定义该模型上的一组操作

## CH2 算法

- 2.1 数据结构与算法的关系
- 2.2 两种算法的比较
- 2.3 算法定义
  - 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
- 2.4 算法的特性

  - 输入输出，有穷性，确定性，可行性
- 2.5 算法设计的要求

  - 正确性，可读性，健壮性
  - 时间效率高和存储量第
- 2.6 算法效率的度量方法

  - 时候统计方法
    - 这种方法主要通过设计好的测试程序和数据，利用计算机计时对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
  - 事前分析估算法
    - 一个程序的运行时间，依赖于算法的好坏和问题的输入规模
- 2.7 函数的渐进增长

  - 这就是洛必达法则，其中自变量为执行一次的计算次数
- 2.8 算法时间复杂度 TODO

  - 即算法的时间度量，记作T(n) = O(f(n))
  - 在进行算法分析是，语句总的执行次数T(n)是关于问题的规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级
- 2.9 常见的时间复杂度
- 2.10 最坏情况与平均情况
- 2.11 算法的空间复杂度
  - 一般考虑时间复杂度二不考虑空间复杂度

## CHA3 线性表

- 3.1 线性表的定义

  - 线性表（List）零个或多个元素的有限序列
    - 前驱元素，直接前驱
    - 后继元素，直接后继
    - 线性表元素的个数n（n>=0）定义为线性表的长度，当n等于0时，称为空表
  - 在复杂的线性表中，一个数据元素可以由若干个数据项组成

- 3.2 线性表的抽象数据类型

  - ```
    ADT 线性表（List）
    Data
    	线性表的数据对象集合为{a1,a2,...,an},每个元素的类型均为datetype，其中，除了第一个元素，每一个元素都有且只有一个直接前驱元素，除了最后一个元素，每一个元素都有且只有一个直接后继元素，数据之间的关系是一对一的关系
    Operation
    	InitList（*L）：初始化操作，建立一个空的线性表L
    	ListEmpty（L）：若线性表为空，返回true，否则返回false
    	ClearList（*L）：将线性表清空
    	GetElem（L,i,*e）：将线性表L中第i个元素返回给e
    	LocateElem（L,e）：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功，否则，返回0表示失败
    	ListInsert（*L，i，e）：在线性表中第i个位置插入新元素e
    	ListDelete（*L,i,*e）：删除线性表L中第i个位置的元素，并用e返回其值
    	ListLength（L）：返回线性表L的元素个数
    endDat
    ```

  - 线性表顺序存储的优缺点

    - 优点
      - 无需为表示表中的元素之间的逻辑关系而增加额外的存储空间
      - 可以快速取出表中任意位置的数
    - 缺点
      - 插入和删除需要移动大量的元素
      - 当线性表长度变化较大时，难以确定存储空间的容量
      - 造成存储空间的碎片

  - 查找，插入和删除的时间复杂度

    - 无论查找哪一个数据时间负复杂度都是O(1)
    - 插入和删除最好情况将数据移动1次，时间复杂度O(1)
    - 插入和删除最坏情况将数据移动n次，时间复杂度O(n)
    - 所以插入和删除时间复杂度为O(n)

- 3.3 线性表的链式存储结构

  - 单链表的整表创建思路（头插法与尾插法）
    - 声明一指针p和计数器变量i
    - 初始化一个空链表
    - 让L的头结点指针指向NULL，即建立一个头结点的单链表
    - 循环
      - 生成一个新节点赋值给p
      - 随机生成一数字赋值给p的数据域
      - 将p插入到头结点与前一新节点之间
  - 单链表的整表删除
    - 声明一节点p和q
    - 将第一个几点赋值给p
    - 循环
      - 将下一个节点赋值给q
      - 释放p
      - 将q赋值给p
  - 单链表结构与顺序存储结构的优缺点
    - 存储方式的分配上
      - 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
      - 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
    - 时间性能
      - 查找
        - 顺序存储结构O(1)
        - 单链表O(n)
      - 插入和删除
        - 顺序存储结构需要平均移动表长一般的元素，时间为O(n)
        - 单链表在指出某位置的指针后，插入和删除的时间仅为O(1)
      - 空间性能
        - 顺序存储结构需要预先分配固定的内存，分大了，浪费，分小了，不够用
        - 单链表只在需要时分配内存空间
  - 总结
    - 在一些频繁查找，删除和插入较少的操作较少时，采用顺序存储结构
    - 表中元素变化比较大，建议使用链式存储

- 3.4 静态链表

  - 用数组描述的链表称为静态链表
  - 静态链表的优缺点
    - 优点——在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点
    - 缺点——没有解决了连续存储分配带来的表长难以确定的问题，失去顺序存储结构随机存取的特性

- 3.5 循环链表

  - 将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单循环链表，简称循环链表

  - 双向链表是在单链表的每个节点中，在设置一个指向其前驱节点的指针域

  - ```c
    typedef struct DulaNode
    {
        Elemtype data;
        struct DulaNode *perior;
        struct DulaNode *next;
    }
    ```

## CHA4 栈与队列

- 4.1 栈（stack）

  - 栈是限定仅在表尾进行插入和删除操作的线性表
    - 我们把允许插入和删除的一段称为栈顶，另一端称为栈底
    - 不含任何数据元素的栈称为空栈
    - 栈又称为后进先出（last in first out）的线性表，简称LIFO
    - 首先栈是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系
    - 其次栈是特殊的线性表，只能在表尾进行插入和删除的操作
    - 栈底是固定的，最先进栈的只能在栈底
  - 栈的插入操作叫做进栈，也称为压栈，入栈
  - 栈的删除操作，叫做出栈，也叫做弹栈

- 4.2 栈的抽象数据类型

  - ```
    ADT 栈（stack）
    Data
    	同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系
    Operation
    	InitStack(*s):初始化操作，建立一个空栈
    	DestoryStack(*s):若栈存在，则销毁他
    	ClearStack(*s):将栈清空
    	StackEmpty(s):若栈为空，返回true，否则返回false
    	GetTop(s,*e):若栈存在且非空，用e返回s的栈顶元素
    	Push(*s,e):若栈存在，且非空，插入新元素e到栈中并成为栈顶元素
    	Pop(*s,*e):删除栈s中栈定的元素，并用e返回其值
    	StackLength(s):返回栈s的个数
    endADT
    ```

- 4.3 顺序栈的实现以及共享栈的实现

- 4.4 栈的链式存储结构及实现

  - 栈的链式存储结构，简称为链栈
    - 将栈顶放在单链表的头部
    - 对于链栈来说基本不存在满栈的情况，除非内存已经没有可以使用的空间

- 4.5 比较链栈与普通栈

  - 链栈的进出栈时间复杂度均为O(1)
  - 顺序在和链栈的时间复杂度相同
  - 顺序在需要事先定义一个固定的长度，可能会存在内存空间浪费的问题，但他的优势是存取时定位很方便
  - 链栈要求每个元素有指针域，同样增加内存开销，但是在某些情况的下栈的长度变化很大，时大时小，使用链栈方便一些

- 4.6 栈的作用

  - 栈实现了递归

    - 回忆斐波那契数列，兔子，楼梯，汉诺塔，这些程序是如何实现的

    - 递归的定义：把一个直接调用自己，或者通过一系列的调用语句间接的调用自己的函数，称作递归函数
      - 每个递归函数必须至少有一个条件，满足时不再递归，开始出栈

  - 栈实现四则运算表达式求值

    - 先乘除，后加减，从左算到右

  - 一种不需要括号的后缀表示法，我们把它称之为逆波兰（RPN）
    - 例： 9 + ( 3 - 1 ) x 3 + 10 / 2（中缀表达式）（标准s四则运算表达式）
    - RPN表示：9 3 1 - 3 x + 10 2 / +（后缀表达式）
    - 运算规则
      - 从左到右遍历表达式的每个数字和符号，遇到数字进栈，遇到是符号，就将处于栈顶的两个数字出栈进行运算，运算结果进栈，一直到最终获得结构
    - 中缀表达式转后缀表达式
      - 从左到有遍历每个中缀表达式的数字和符号，
      - 若是数字就输出，即成为后缀表达式的一部分，
      - 若是符号则判断其与栈顶符号的优先级，
        - （A）优先级不高于栈顶符号，则栈顶元素依次出栈并输出，
          - 不高于==》小于等于就是不高于
        - （A）将当前符号进栈，
        - （B）若碰到（），左括号压入栈中，直到右括号准备入栈（配对成功）
        - （B）将左右括号之间的符号弹出
        - （B）一直把左括号也弹出，再压入下一个元素
      - 一直到最终输出后缀表达式为止

    计算机利用栈思想以及后缀表达式进行四则运算

    1. 将中缀表达式转换为后缀表达式
    2. 将后缀表达式进行运算得出结构

- 4.7 队列

  - 队列是只允许在一端进行插入操作，而在另一端进行删除惭怍的线性表

    - 队列是一种先入先出的线性表（first in first out）简称FIFO
    - 允许插入的一端称为队尾，允许删除的一端称为队头

  - 队列的抽象数据类型

    - ```
      ADT 队列（queue）
      Data
      	同线性表，元素具有相同的类型，相邻元素具有前驱和后继的关系
      Operation
      	InitQueue(*Q)初始化操作，建立一个空队列Q
      	DestroyQueue(*Q)若队列Q存在，则销毁他
      	ClearQueue(*Q)将队列清空
      	QueueEmpty(Q)若队列Q为空，返回True，否则返回False
      	GetHead(Q,*e)若队列存在且非空，用e返回队头元素
      	EnQueue(*Q,e)若队列存在，插入新元素e到队列中并成为队尾元素
      	DeQueue(*Q,e)删除队列Q中的队头元素，并用e返回其值
      	QueueLength(Q)返回队列的元素个数
      endADT
      ```

  - 线性表有两种存储方式，顺序存储和链式存储

    - 栈与队列都是线性表，所以都有顺序队列和链式队列
    - 虽然有两种实现方式，但是两种实现方式各有优缺点

  - 队列顺序存储的不足

    - 队列的顺序存储实现方式与线性表的的顺序存储相差不多，只不过是插入只能在队头，删除只能在队尾，线性表的顺序存储还可以在中间插入
    - 从时间复杂度看，在插入时，线性表的时间复杂度与队列的时间复杂度在一个量级上

  - 对于队列顺序存储不足的改进思路

    - 1. 设置队头
         - 和队尾指针，定义顺序存储的数组，这样做的目的是让队头元素不必只在下标为0的位置上，队头元素出队后，将队头指针向后移，这样做之后，在队列中插入和删除元素时间复杂度都变成O(1)
         - 缺点是这样使得顺序存储的数组利用率随着出队元素的增加而减，队列的长度越来越短，但是队头元素之前空着的存储位置也被浪费掉了，假溢出现象
    - 2. 循环对列的定义
         - 解决假溢出的办法解释后面满了，就从头开始，将队列的这种首尾相接的顺序存储结构称为循环队列
         - 这样的话头指针和尾指针有可能会指向同一个下标，在指向同一个下标时有两种情况，一种是队列是空的，一种是队列是满的，如何区分呢？有两种解法
           - 1） 可以设置一个flag信号，flag==0，队列空，flag==1队列满、
           - 2） 保留一个空元素，在(rear+1)%QueueSize == front 时就认为队列满了
    - 第一种解法判断简单，但是每个队列结构体得多定义一个flag信号，但问题是无法分辨当rear == flag时，队列到底是什么状态，这个到底怎么判断呢？？是不是加一个count， 进来一个加1，出去一个减1，对呀，设置一个计数器不就得了，或者可以这样，初始flag时将flag置0，当flag为0时不能进行出队操作，只能进队，然后只要有一个元素进队，就置1，不行还是计数器方便。进队加1，出队减1，初始化队列是置0，为0时只能进队，记满MAXSIZE只能出队不能进队，不用flag信号
    - 第二种解法是有一个空元素，这个比较好办，只要判断(rear+1)%QueueSize == front就可以了
    - 这么看来第二种解法是最简单的

- 4.8 队列的链式存储

  - 队列的链式存储其实就是线性表的单链表，但是只能从尾进头出而已
  - 如何初始化一个队列链表呢
    - 定义一个有结构体，成员是两个指针，一个头指针，一个尾指针，指针的类型是链表元素的结构体
    - 链表元素的结构体包含数据成员以及指向下一元素的指针成员
    - 初始化时将头指针和为指针都指向一个链表的的元素，data不做赋值，*next赋值为NULL
  - 总的来说，如果能确定队列长度最大值的情况下，建议使用循环队列，如果无法预估队列的长度，则使用链队列
  - 循环队列的入队出队操作以及链队列的入队出队操作本质上都是O(1)的，都是常数时间，链队列的每次出队和入队在节点内存的释放和申请上还是存在一定的时间开销的

- 知识点树

  - 顺序栈---》两栈共享空间
  - 顺序队列---》循环队列
  - 链式存储  ---》链栈，队列栈

## CHA5 串

- 5.1字符串的概念

  -  串是由零个或者多个字符组成的有限队列，又叫字符串
    -  一般记为 s = "a1a2...an"(n>=0)
    -  s是字符串的名称，用双引号括起来的字符序列是串的值，双引号不是字符串的内容
    -  所谓字符列，说明串的相邻字符之间具有前驱和后继的关系
    -  串中的字符数目n称为串的长度
    -  零个字符的串称为空串（null string）
  -  一些特别的概念
    - 空格串，只包含空格的串，不是空串，空格串是有内容有长度的，而且可能不止一个空格	
    - 子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应的包含所有子串的称为主串
    - 子串的位置，子串的第一个字符在主串中的序号
    - Unicode的前256个字符的编码与ASCII的完全相同
  -  与线性表比较
     -  串的逻辑结构和线性表很相似，不同之处是串针对的是字符集，也就是串中的元素都是字符，
     -  线性表更关注单个元素的操作
     -  串更多的是查找子串的位置，得到指定的字符串，替换子串在这样的操作

- 5.2 串的比较

  - 比如 silly 与 stupid

    - 在计算机中的大小取决于挨个字母的前后顺序，事实上是通过组成串的字符的编码来确定的
    - 第一个字母，相同
    - 第二个字母，i在t前，t>i
    - 于是silly<stupid
  - 字符串 s = "a1a2...an"; t = "b1b2...bm";
    - if(m=n && ai==bi)   s == t;  1<=i<=(m||n) ;  eg: happy = happy
    - if(m>n &&ai==bi)    s<t;  1<= i <= min{m,n};  eg: happ<happy
    - if(k<=min{m,n},ak<bk)    s<t;  eg: happen<happy

- 5.3 串的抽象数据类型

  - ```
    ADT 串（string）
    Data
    	串中元素仅由一个字符构成，相邻元素具有前驱和后继的关系
    Operation
    	StrAssign(T,*chars) 生成一个其值等于字符串常量chars的串T
    	StrCopy(T,S) 串S存在，由串S复制得串T
    	Clearstring(S) 串S存在，将串清空
    	StringEmpty(S) 串为空，返回True，否则返回True
    	StrLength(S) 返回串S的长度
    	StrCompare(S,T) 若S>T返回<0，若S=T返回0，若S<T返回>0
    	Concat(T,S1,S2) 由T返回S1和S1连接成的新串
    	Substring(Sub,S,pos,len) 串S存在，1<=pos<=StrLength(S)+1,且0<=len<=Strlength(S)-pos+1，用sub返回S的第pos个长度为Len的子串
    	Index(S,T,pos) 用pos返回S和T中相同子串的位置
    	Repalce(S,T,V) 使用V替换S中所有与T相等的不重叠的子串
    	StrInsert(S,pos,T) 在串S的第pos个字符之前插入T
    	StrDelete(S,pos,len) 从串S中删除pos位置长为len的子串
    ```

- 5.4 串的存储结构

  - 串的顺序存储结构
    - 串的顺序存储结构，使用一组地址连续的存储单元来存储串中的字符序列的
  - 串的链式存储结构
    - 由于串结构的特殊性，结构中每个元素都是一个字符，如果应用链表一个节点对应一个字符，会造成空间的浪费，所以一个节点存储一个子串，节点未被沾满使用#代替，
    - 这样一个节点存储多少个字符就会直接影响效率
    - 链式结构存储字符串除了在连接串和某些串操作有一定方便之外，总的来说不如顺序串灵活，性能也不如顺序存储结构好

- 5.5 模式匹配算法（子串的定位操作通常称为串的模式匹配）

  -  朴素的模式匹配算法

    - 朴素模式匹配算法的时间复杂度 为O((n-m+1)*m)
    - 十分低效

  - KMP模式匹配算法

    - 定义两个变量i，j，一个是主串的下标i，一个是子串下标j，
    - 在朴素匹配时，i是有回溯的的，
    - 在KMP匹配时，i取消了无效的回溯，变化的只有指向子串的下标的j
    - 那么j如何变化呢，我们考虑T串的首字符与自身后面字符的比较
    - 也就是说j的变化和主串没有什么关系，我们关注的是子串的结构以及是否重复的问题
    - 例如T = "abcdef",没有任何重复的字符，所以j就从6变到1
    - 例如T = "abcabx",前两个字符ab与x之前的ab是相等的，j就从6变到了3
    - 那么kmp算法做的就是调整j的值，让i不用回溯

  - 如何调整j的值呢？——next数组值推导

    - 有三条规则来找出next[j]

      - 1） 当j=1时，next[1] = 0;
      - 2） 当max{ k|1<k<j，且 'p1...'p(k-1)= 'p(j-k+1)...'p(j-1)} 不为空时，
      - 3） 其他情况，next[j] = 1;

    - 得到next[]这个数组后，在进行比较时，如果此时比较到了i=j=6不相等的时候，此时i不动，j=next[6]直接进行比较

    - eg 

      - | j       | 123456 |
        | ------- | ------ |
        | 模式串T | abcabx |
        | next[j] | 011123 |

      - 串T与s = "abcababca..."比较

      - 显然，比较到 i = j = 6 时不相等

      - 这时i不动，j = next[6] = 3,直接比较i=6 j=3时是否相等

    - **注：** KMP算法仅当模式与主串之间存在许多部分匹配的现象是才能体现出他的优势

  - KMP模式匹配算法的改进

    - 还是有缺陷，比如当比较s="aaaaabc"时会出现好多不必要的操作
    - 如何改进呢？
    - 将next的函数修正值存在nextval中

  - 算法理解了，但是没有代码实现，感觉字符串这块不太重要，以后有时间在说吧

## CHA6 树

- 6.1 树	
  - 一对一的为线性结构，还有一对多的情况需要处理
  - 树（Tree）是n（n>=0）个节点的有限集，n=0时称为空树
  - 在任意一个非空树中
    - 1） 有且仅有一个特定的称为根（root）的节点
    - 2） 当n>1时，其余节点可以分为m（m>0）个互不相交的有限集，T1,T2,...,Tm，其中每一个集合本身又是一颗树，并且称为根的子树
    - 插图TODO【树的图】
  - **注意：** 
    - n>0时根节点是唯一的，不能存在多个根节点
    - m>0时子树的个数没有限制，但他们一定是互不相交的
  - 节点分类
    - 度（degree）：节点拥有子树的数量称为度，树的度是树内各节点的度的最大值
    - 叶节点（Leaf）：度为0的节点
    - 度不为0的节点称为非终端节点或分支节点，除了根节点外，分支节点也是称为内部节点
  - 节点间的关系
    - 节点的子树的根称为该节点的孩子（child）
    - 该节点称为孩子的双亲（parents）
    - 同一个双亲的孩子之间互称为兄弟（sibling）
    - 节点的祖先是从根到该节点所经分支上的所有节点
    - 以某节点为根的子树中的任一节点都称为该节点的子孙
  - 树的其他概念
    - 节点的层次（level）：从根开始定义起，根为第一层，根的孩子为第二层，以此类推
    - 双亲在同一层的节点称为堂兄弟
    - 树的深度（depth）：树中节点的最大层次就是数的深度（高度）
    - 有序树：如果将树中节点的鸽子树看成是从左至右是有次序的，不能互换的，就是有序树，反之称为无序树
    - 森林（forest）：是（m>=0）棵互不相交的树，对于树中每个节点而言，其子树的集合就是森林

- 6.2 树的存储结构
  - 对于存储结构的设计，可以综合顺序存储和链式存储的特点，是一个非常灵活的过程，一个存储结构设计的是否合理，取决于基于该存储结构的运算是否适合，是否方便，时间复杂度好不好等
  - 双亲表示法（不一定有孩子，但一定有双亲）
    - 在每个节点中附设一个指示器只是其双亲节点在数组中的位置
  - 孩子表示法
    - 把每个节点的孩子节点排列起来，以单链表做存储结构，则n个节点右n个孩子链表，如果是叶子节点则此单链表为空，然后n个头指针有组成一个线性表，采用顺序存储结构，存放进一个一维数组中
    - 每个节点有多个指针域，其中每个指针指向一颗子树的根节点，我们把这种方法叫做多重链表表示法
    - 1）一种是指针域的个数就等于树的度，这种方法对于树中各节点的度相差很大时，显然是很浪费空间的，对于度相差很小时，那就意味着开辟的空间被充分利用了，缺点反而变成了优点
    - 2） 每个节点指针域的个数等于该节点的度，专门取一个位置来存储节点指针域的个数，这种方法空间利用率倒是上去了，可是数据结构的维护变得复杂了，在运算时间上会带来损耗
  - 孩子兄弟表示法
    - 任意一颗树，他的节点的第一个孩子如果存在就是唯一的，他的右兄弟如果存在也是唯一的，因此我们设置两个指针，分别指向该节点的第一个孩子和此节点的有兄弟
    - 这种方法最大的好处是他把一颗复杂的树变成了二叉树

- 6.3 二叉树（binary tree）
  - 二叉树（binary tree）：是是n（n>=0）个节点的有限集，n=0时称为空二叉树树，或者由一个根节点的和两颗互不相交的、分别称为左子树和右子树的二叉树组成

  - 二叉树特点
    - 每个节点最多有两颗子树，所以二叉树中不存在度大于2的节点，**不是只有两颗子树，而是最多有两颗**，没有子树或者有一颗子树也时可以的
    - 左子树和右子树是有顺序的，次序不能任意颠倒，就像人的左右手
    - 即使树中某节点只有一颗子树，也要区分是左子树还是右子树，

  - 二叉树的五种形态
    - 空二叉树
    - 只有一个根节点
    - 根节点只有左子树
    - 根节点只有右子树
    - 根节点既有左子树又有右子树

  - 特殊的二叉树
    - 斜树
      - 所有节点都只有左子树的二叉树称为左斜树
      - 所有节点都只有右子树的二叉树称为右斜树
    - 满二叉树
      - 在一颗二叉树中，所有分支节点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树
      - 满二叉树的特点
        - 叶子节点只能出现在最下一层
        - 叶子节点的度一定是2
        - 同样深度的二叉树中，满二叉树节点最多，叶子节点也最多
    - 完全二叉树
      - 对一颗具有n个节点的二叉树按层序编号，如果编号为i（1<=i<=n）的节点同与同言样深度的满二叉树中编号为i的节点在二叉树中位置完全相同，则称这颗二叉树为完全二叉树
      - 注：满二叉树一定是完全的，完全二叉树不一定是满的
      - 特点
        - 1）叶子节点只能出现在最下面两层
        - 2）最下层的叶子一定集中在左部连续
        - 3）倒数二层，若有叶子节点，一点都在右部连续位置
        - 4）如果节点的度为1，则该节点只有左孩子，即不存在只有右子树的情况
        - 5）同样节点数的二叉树，完全二叉树的深度最小

  - 二叉树的性质

    - 1）在二叉树的第i层上至多有2^(i-1) 个节点，（i>=1）

    - 2）深度为k的二叉树至多有((2^k) -1) 个节点，（k>=1）

    - 3）对于任意一颗二叉树T，如果其终端节点数为n0，度为2的节点数为n2，则n0=n2+1，树T的节点总数n=n0+n1+n2，n1为度为1的节点数

    - 4）具有n个节点的完全二叉树的深度为 
      $$
      [log_2n]+1，log_2n为向下取整
      $$

    - 5）如果有一颗有n个节点的完全二叉树，其节点按层序编号，对任意节点i有

      - 如果i=1，则节点i是二叉树的根，无双亲；如果i>1；则其双亲节点是i/2向下取整
      - 如果2i>n，则节点无左孩子，否则其左孩子是节点2i
      - 如果2i+1>n，则节点无右孩子，否则其右孩子是节点2i+1

- 6.4二叉树的存储结构

  - 二叉树的顺序存储结构
    - 二叉树的顺序存储结构就是用一维数组存储二叉树中的节点，并且节点的存储位置也就是数组的下标要能完全体现节点之间的逻辑关系
    - 由于完全二叉树定义严格，所以用顺序结构也可以表现出二叉树的结构
    - 对于一般的二叉树也可以按照完全二叉树编号，没有的节点空出来就行，
    - 会造成存储空间的浪费
  - 二叉链表
    - 二叉树的每个节点最多有两个孩子，所以为他设计一个数据域和两个指针域，我们称这样的链表为二叉链表

- 6.5 遍历二叉树

  - 二叉树的遍历原理
    - 二叉树的遍历（traversing binary tree）是指从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次
    - **注：访问和次序**

  - 二叉树遍历的几种方法（前提是限制从左到右的习惯方式）

    - 如果有一棵树，按照从根节点到最后一层的叶子节点，从左到右为每个节点排序，我们可以想象有一棵树，1234567（前中后是相对于根节点的，使用递归思想）

    - 前序遍历--->根左右，1 245 367
      - 规则是若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，在前序遍历右子树
    - 中序遍历--->左根右，425 1 637
      - 规则是若二叉树为空，则空操作返回，否则从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树
    - 后序遍历--->左右根，452 673 1
      - 规则是若树为空，则空操作返回，否则从左到右先叶子后节点的方式遍历访问左子树，最后是访问根节点
    - 层序遍历
      - 规则是若树为空，则空操作返回，否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按照从左到右的顺序对节点逐个访问

  - 遍历方法的意义

    - 其实都是把树中的节点变成某种意义的线性序列，这就给程序的实现带来了好处

  - 推导遍历结果
    - 已知前序遍历序列和中序遍历序列，可以唯一确定一颗二叉树
    - 已知后序遍历序列和中序遍历序列，可以唯一确定一颗二叉树
    - 已知前序和后序，不能唯一确定一颗二叉树

- 6.6二叉树的建立

  - 为了能让每个节点确认是否有左右孩子，我们对他进行了扩展，也就是将二叉树中每个节点的空指针引出一个虚节点，其值为一个特定值，比如#，我们称这种处理后的二叉树为原二叉树的扩展二叉树，扩展二叉树就可以做到一个遍历序列确定一个二叉树
  - 利用这一节可以快速建立一个二叉树

- 6.7线索二叉树（threaded binary tree）

  - 把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就成为线索二叉树
  - 起始线索二叉树，等于是把一颗额二叉树转变成了一个双向链表，这样对我们插入和删除节点，查找某个节点都带来了方便
  - 我们称对二叉树以某种次序遍历使其变为线索二叉树的过程就称为线索化
  - 如果所用的二叉树需要经常遍历或者查找节点时需要某种遍历中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择

- 6.8树、森林与二叉树的转换

  - 树转换为二叉树  <---> 二叉树转换为树
  - 森林转换为二叉树 <---> 二叉树转换为森林
  - 树与森林的遍历

- 6.9赫夫曼树及应用（最基本的压缩编码方法）

- ```
  ADT 树（tree）
  Data
  	树是由一个根节点和若干颗子树构成，树中节点具有相同数据类型及层次关系
  Operation
  	InitTree(*T)
  	DestortyTree(*T)
  	CreateTree(*T,definition)
  	ClearTree(*T)
  	TreeEmpty(T)
  	TreeDepth(T)
  	Root(T)
  	Value(T,*cur_e)
  	Assign(T,cur_e,value)
  	Parent(T,cur_e)
  	LiftChild(T,cur_e)
  	RightSibling(T,cur_e)
  	InsertChild(*T,*p,i,c)
  	DeleteChild(*T,*p,i)
  endADT
  ```

## CHA7 图

## CHA8 查找

- 8.1 查找概论
  - 查找表是由同一类型的数据元素（或记录）构成的集合，关键字是数据元素中某个数据项的值
  - 若关键字可以唯一的标识一个记录，则称此关键字为主关键字（primary key），对于可以识别多个数据元素的关键字称为次关键字（secondary key）
  - 查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的元素
  - 静态查找表（static search table）：只作查找操作的查找表
    - 查询某个特定的数据元素是否在查找表中
    - 检索某个特定的数据元素和各种属性
  - 动态查找表（Dynamic search table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素
    - 查找时插入数据元素
    - 查找时删除数据元素
  - 静态表--->线性结构组织数据--->顺序查找--->主关键字排序--->折半查找
  - 动态表--->二叉树--->遍历查找删除插入---> 线索二叉树--->利用算法

- 8.2 顺序查找表
  - 顺序查找（sequential search）：最基本的查找技术。查找过程：从表中的第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；如果直到最后一个（或第一个）记录，关键字和给定值比较都不相等，则表中没有所查找的记录，查找不成功
  - 顺序查找表优化
    - 每次查找都需要比较i，不够方便，所以设置一个哨兵值，这样不用每次都设置i，免去了在查找过程中每一次比较后都需要查找位置是否越界

- 8.3有序表查找
  - 折半查找
    - 折半查找（Binary Search）技术：又称为二分查找。
      - 前提是
        - 线性表中的记录必须是关键字有序
        - 线性表必须是顺序查找
      - 在有序表中，取中间记录作为比较对象
        - 若相等，结束查找
        - 若小于，则在中间的左边查找
        - 若大于，则在中间的右边查找
        - 递归，不断查找，找到结束，返回查找到的数据；直到所有数据被遍历完结束查找，返回没有找到的状态
    - 优缺点
      - 折半查找前提是有序的，对于动态表，必须要维护排序否则不能用，所以对于静态表来说，优势是显而易见的
  - 插值查找
    - 对于数据分布不均匀的数据，使用插值查找法是比较好的
    - 就是将折半查找的系数改变，使其更适应数组的结构
  - 斐波那契数列查找
    - 斐波那契数列的查找是利用黄金分割原理来实现的
    - 适用于数据结构更加分散的数据
  - 时间复杂度
    - 顺序查找O(n)
    - 折半查找O(log(n))
    - 斐波那契查找O(log((n))
  - 本质上三种查找方法并没有本质区别，只是划分查找区间的方法不一样
  - 区间划分方法操作时分别有加减法，乘除法，前两种方法都有乘除匀速，在查找海量数据时，只有加减法的斐波那契查找会优于前两种方法
  - 平均性能来说，斐波那契查找要优于折半查找，但是在极端情况下，比如查找最小的记录，折半查找会优于斐波那契查找法，各有优劣势，开发时注意选择

- 8.4 线性索引查找
  - 索引就是把一个关键字与他对应的记录相关联的过程
  - 所谓线性索引就是将索引集合组织成线性结构，也称为索引表
  - 稠密索引
    - 稠密索引指的是在线性索引中，将数据集中的每个记录对应一个索引项
    - 对于稠密索引这个索引表来说，索引项一定是按照关键字的有序排列，
    - 索引项是有序的排列意味着我们查找关键字时，可以用到之前的三种算法来进行查找
  - 分块索引
    - 将数据集分成若干块，并且是块内无序，块间有序。
    - 这样做是为了减少索引个数，稠密索引对每个数据元素都创建索引，所以空间代价比较大
    - 索引项结构分为三个数据集
      - 最大关键码，每一块中最大的关键字，下一个块中最小的关键字也比上一个块中的大
      - 块长，块中数据的个数，循环时使用
      - 指针，指向快首元素的指针，便于对这一块中元素进行遍历
    - 分块索引的步骤
      - 在分块索引表中查找目标关键字所在的块，折半，插值，斐波那契
      - 根据块首指针找到相应的块，并且在块中查找目标关键字
    - 每个分块的长度
      - n个记录的数据集均分成m个块，每块有t个元素
      - x为平均查找索引表的长度，最好最差等概原则，平均长度(m+1)/2
      - y为平均查找块中元素的长度，(t+1)/2
      - z为分块索引平均查找长度，z = x+y
      - 由此可知最佳分块长度应该是m = t，z = n^(1/2) + 1；
    - 分块索引比顺序索引高了不少，但是距离折半查找还是有一定的差距
  - 倒序索引
    - 倒序索引源于实际应用中需要根据属性的值（比如或字段，次关键码）来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的个记录的地址，由于不是用记录来确定属性值，而是通过属性值来确定记录值，因为称为倒序索引
    - 索引项的结构
      - 次关键字，例如文章中的单词
      - 记录好表，例如文章编号

- 8.5 二叉排序树

  - 二叉排序树又称为二叉查找树
    - 若他的左子树不为空，则左子树上所有节点的值均小于他根节点的值
    - 若他的右子树不为空，则右子树上所有节点的值均大于他根节点的值
    - 他的左右子树也是二叉排序树
  - 二叉排序树的查找和插入的操作都比较方便，但是其删除操作需要考虑的点比较多
    - 1. 删除节点为叶子节点
      2. 删除节点仅有左子树或者右子树的节点
      3. 左右子树都有的节点
  - 在构造二叉排序树时会遇到一些极端情况，比如一颗左斜树，一颗右斜树，这种极端情况是不希望看到的，我们希望二叉排序树是平衡的，也就是深度与完全二叉树的深度相同，那么查找的时间复杂度与折半查找的复杂度大致相同，二叉排序树的查找的时间复杂度O(n)

- 8.6平衡二叉树

  - 平衡二叉树（self-balance binary search tree）
    - 是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1
  - 平衡因子（balance factor）
    - 二叉树节点的左子树深度减去右子树深度
  - AVL树的BF只可能是-1，0，1，不是这个，二叉树不平衡
  - 距离插入节点最近的且平衡因子的绝对值大于1的节点为根的子树，我们成为最小不平衡子树
  - 平衡二叉树的实现原理
    - 在构建二叉排序树的过程中，每当插入一个节点，先检查是否因插入而破坏了数的平衡性，若是找出最小不平衡子树，在保持二叉排序树特性的前提下，调整最小不平衡子树中各节点之间的链接关系，进行相应的旋转，使之成为新的平衡子树

- 8.7 多路查找树

  - 每一个节点的孩子树可以多于两个，且每个节点处可以存储多个元素

- 8.8 散列表查找概述

  - 散列函数
    - 存储位置 = f（关键字）
    - 散列技术是在记录的存储位置和他的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）
  - 采用散列技术将记录存储在一块连续的存储中，这块连续存储空间被称为散列表或哈希函数
  - 散列技术既是一种存储方法，越是一种查找方法，与现线性表，树，图等结构不同的是前面几种结构数据元素之间都存在某种逻辑关系，可以用连线图表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联，因此散列主要是面向查找的存储结构
  - 散列函数最适合的是查找与给定值相等的记录
  - 冲突
    - 两个关键字可以用一个映射函数对应起来，这样在存储位置上就发生了冲突，到底该存哪个呢？这种情况称为冲突，把这两个冲突的关键字称为这个散列函数的同义词

- 8.9 散列函数的构造方法

  - 构造函数的要求

    - 计算简单
    - 散列地址分布均匀

  - 直接定址法

    - $$
      f(key) = a * key + b （a，b为常数）
      $$

  - 数字分析法

    - 比如电话号
    - 抽取——使用关键字的一部分来计算散列存储位置的方法

  - 平方取中法

    - 将关键字平法，然后取出某几位来计算散列存储位置的方法

  - 折叠法

    - 将关键字分成等长的几段，然后将这些分段的数据加起来取出某几位计算散列存储位置的方法
    - 折叠法事先不需要知道关键字的分布，适合关键字位数比较多的情况

  - 除留余数法

    - 对于散列表长为m的散列函数公式

    - 
      $$
      f(key) = key mod p (p<=m)
      $$

  - 随机数法

    - f(key) = random(key)

  - 解决冲突的方法

    - 开放定址法
      - 一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到
    - 一直找直到找到为止，这种寻找存储地址的方法称为线性探测法
    - 上述方法可能造成本来不是同义词的的两个关键字冲突，我们称这种现象为堆积
    - 再散列函数法——准备多个散列函数
    - 连地址法——将同义词的关键字以链式存储的方法存储在发生冲突的地址上
    - 公共溢出法——将冲突的关键字放在另一片区域

  - 散列查找表的性能分析

    - 如果没有冲突——O(1)
    - 散列函数的平均查找长度取决于哪些因素
      - 散列函数是否均匀
      - 处理冲突的方法
      - 散列表的装填因子——装填因子 = 填入表中的记录的个数 / 散列表的长度

## CHA9 排序

- 9.1排序的基本概念与分类
  - 使序列称为按照关键字有序（非递减或者非递增）的序列称为2排序，排序可以看成是线性表的一种操作
  - 排序的稳定性
    - 假设表中的两个排序的关键字相等，在排序之前这两个关键字的前后关系与排序后这两个关键字的排序关系没有发生变化成为稳定的排序，否则称为不稳定排序
  - 内排序与外排序
    - 内排序——在计算机内存中进行排序
    - 外排序——由于数据过多，不能同时放在内存整个排序过程需要在内外存之间多次交换数据才能进行
  - 性能
    - 时间性能——比较和移动两种操作
    - 辅助空间——除了存放待排序所占用的内存之外，执行算法所需要的其他内存空间
    - 算法的复杂性——插入排序，交换排序，选择排序，归并排序
- 9.2 冒泡排序（bubble sort）——三种一一实现（TODO）
  - 交换排序的一种
  - 冒泡排序算法的复杂度
    - 在最优的冒泡排序下最好的情况是序列已经有序，需要比较(n-1)次，时间复杂度O(n)
    - 最坏的情况下n*(n+1)/2——时间复杂度O(n^2)
- 9.3 简单选择排序（simple selection sort）
  - 通过n-i次关键字之间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录进行交换
  - 时间复杂度为O(n^2)
- 9.4 直接插入排序（straight insertion sort）
  - 基本操作是见一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的标
  - 时间复杂度为O(n^2)
- 9.6 希尔排序（shell sort）
  - 希尔排序并不是一种稳定的排序方法
  - 时间复杂度为O(n^(3/2))
- 9.7 堆排序（heap sort）